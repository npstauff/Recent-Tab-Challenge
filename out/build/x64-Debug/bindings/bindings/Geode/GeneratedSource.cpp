
#include <stdexcept>
#include <Geode/Bindings.hpp>
#include <Geode/utils/addresser.hpp>
#include <Geode/modify/Traits.hpp>
#include <Geode/loader/Tulip.hpp>

using namespace geode;
using namespace geode::modifier;
using cocos2d::CCDestructor;

std::unordered_map<void*, bool>& CCDestructor::destructorLock() {{
	static auto ret = new std::unordered_map<void*, bool>;
	return *ret;
}}
bool& CCDestructor::globalLock() {{
	static thread_local bool ret = false;
	return ret; 
}}
bool& CCDestructor::lock(void* self) {
	return destructorLock()[self];
}
CCDestructor::~CCDestructor() {{
	destructorLock().erase(this);
}}

auto wrapFunction(uintptr_t address, tulip::hook::WrapperMetadata const& metadata) {
	auto wrapped = geode::hook::createWrapper(reinterpret_cast<void*>(address), metadata);
	if (wrapped.isErr()) {{
		throw std::runtime_error(wrapped.unwrapErr());
	}}
	return wrapped.unwrap();
}

// So apparently Clang considers cdecl to return floats through ST0, whereas 
// MSVC thinks they are returned through XMM0. This has caused a lot of pain 
// and misery for me


auto GJDropDownLayer::init(char const* p0, float p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(GJDropDownLayer*, char const*, float, bool);
	static auto func = wrapFunction(base::get() + 0x1d6700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

bool GJDropDownLayer::init(char const* title) {
		return init(title, 220.0f, false);
	}

GJDropDownLayer* GJDropDownLayer::create(const char* title, float height, bool p2) {
        GJDropDownLayer* pRet = new GJDropDownLayer();
        if (pRet && pRet->init(title, height, p2)) {
            pRet->autorelease();
            return pRet;
        }
        CC_SAFE_DELETE(pRet);
        return nullptr;
    }

GJDropDownLayer* GJDropDownLayer::create(const char* title) {
		GJDropDownLayer* pRet = new GJDropDownLayer();
        if (pRet && pRet->init(title)) {
            pRet->autorelease();
            return pRet;
        }
        CC_SAFE_DELETE(pRet);
        return nullptr;
	}

auto GJDropDownLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::draw), this);
	using FunctionType = decltype(draw())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x230a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJDropDownLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJDropDownLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x230d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJDropDownLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("GJDropDownLayer::ccTouchMoved not implemented");
}

auto GJDropDownLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("GJDropDownLayer::ccTouchEnded not implemented");
}

auto GJDropDownLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("GJDropDownLayer::ccTouchCancelled not implemented");
}

auto GJDropDownLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x22fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x1d6b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("GJDropDownLayer::customSetup not implemented");
}

auto GJDropDownLayer::enterLayer() -> decltype(enterLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::enterLayer), this);
	using FunctionType = decltype(enterLayer())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x22fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&GJDropDownLayer::exitLayer), this);
	using FunctionType = decltype(exitLayer(p0))(*)(GJDropDownLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1d6b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJDropDownLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(GJDropDownLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x1d6b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJDropDownLayer::hideLayer), this);
	using FunctionType = decltype(hideLayer(p0))(*)(GJDropDownLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x1d6c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::layerVisible() -> decltype(layerVisible()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::layerVisible), this);
	using FunctionType = decltype(layerVisible())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x23060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x1d6d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	throw std::runtime_error("GJDropDownLayer::enterAnimFinished not implemented");
}

auto GJDropDownLayer::disableUI() -> decltype(disableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::disableUI), this);
	using FunctionType = decltype(disableUI())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x1d6ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::enableUI() -> decltype(enableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::enableUI), this);
	using FunctionType = decltype(enableUI())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x1d6b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJAccountDelegate::accountStatusChanged() -> decltype(accountStatusChanged()) {
	throw std::runtime_error("GJAccountDelegate::accountStatusChanged not implemented");
}

void FLAlertLayerProtocol::FLAlert_Clicked(FLAlertLayer* p0, bool p1) {}

auto AccountHelpLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x58a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AccountHelpLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountHelpLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AccountHelpLayer*);
	static auto func = wrapFunction(base::get() + 0x58b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountHelpLayer::layerHidden() -> decltype(layerHidden()) {
	throw std::runtime_error("AccountHelpLayer::layerHidden not implemented");
}

auto AccountHelpLayer::accountStatusChanged() -> decltype(accountStatusChanged()) {
	throw std::runtime_error("AccountHelpLayer::accountStatusChanged not implemented");
}

auto AccountHelpLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("AccountHelpLayer::FLAlert_Clicked not implemented");
}

auto GJAccountBackupDelegate::backupAccountFinished() -> decltype(backupAccountFinished()) {
	throw std::runtime_error("GJAccountBackupDelegate::backupAccountFinished not implemented");
}

auto GJAccountBackupDelegate::backupAccountFailed(BackupAccountError p0, int p1) -> decltype(backupAccountFailed(p0, p1)) {
	throw std::runtime_error("GJAccountBackupDelegate::backupAccountFailed not implemented");
}

auto GJAccountSyncDelegate::syncAccountFinished() -> decltype(syncAccountFinished()) {
	throw std::runtime_error("GJAccountSyncDelegate::syncAccountFinished not implemented");
}

auto GJAccountSyncDelegate::syncAccountFailed(BackupAccountError p0, int p1) -> decltype(syncAccountFailed(p0, p1)) {
	throw std::runtime_error("GJAccountSyncDelegate::syncAccountFailed not implemented");
}

auto AccountLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x573e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AccountLayer::doBackup() -> decltype(doBackup()) {
	using FunctionType = decltype(doBackup())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0x57dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AccountLayer::doSync() -> decltype(doSync()) {
	using FunctionType = decltype(doSync())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0x57f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AccountLayer::onBackup(cocos2d::CCObject* sender) -> decltype(onBackup(sender)) {
	using FunctionType = decltype(onBackup(sender))(*)(AccountLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x57c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AccountLayer::onLogin(cocos2d::CCObject* sender) -> decltype(onLogin(sender)) {
	using FunctionType = decltype(onLogin(sender))(*)(AccountLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x57c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AccountLayer::onMore(cocos2d::CCObject* sender) -> decltype(onMore(sender)) {
	using FunctionType = decltype(onMore(sender))(*)(AccountLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x58010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AccountLayer::onSync(cocos2d::CCObject* sender) -> decltype(onSync(sender)) {
	using FunctionType = decltype(onSync(sender))(*)(AccountLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x57e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AccountLayer::updatePage(bool p0) -> decltype(updatePage(p0)) {
	using FunctionType = decltype(updatePage(p0))(*)(AccountLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x58060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AccountLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0x575c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0x589b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::backupAccountFinished() -> decltype(backupAccountFinished()) {
	throw std::runtime_error("AccountLayer::backupAccountFinished not implemented");
}

auto AccountLayer::backupAccountFailed(BackupAccountError p0, int p1) -> decltype(backupAccountFailed(p0, p1)) {
	throw std::runtime_error("AccountLayer::backupAccountFailed not implemented");
}

auto AccountLayer::syncAccountFinished() -> decltype(syncAccountFinished()) {
	throw std::runtime_error("AccountLayer::syncAccountFinished not implemented");
}

auto AccountLayer::syncAccountFailed(BackupAccountError p0, int p1) -> decltype(syncAccountFailed(p0, p1)) {
	throw std::runtime_error("AccountLayer::syncAccountFailed not implemented");
}

auto AccountLayer::accountStatusChanged() -> decltype(accountStatusChanged()) {
	throw std::runtime_error("AccountLayer::accountStatusChanged not implemented");
}

auto AccountLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("AccountLayer::FLAlert_Clicked not implemented");
}

FLAlertLayer::~FLAlertLayer() {
		if (m_forcePrioRegistered) {
			cocos2d::CCTouchDispatcher::get()->unregisterForcePrio(this);
		}
	}

FLAlertLayer::FLAlertLayer() {
		m_buttonMenu = nullptr;
		m_controlConnected = -1;
		m_mainLayer = nullptr;
		m_ZOrder = 0;
		m_noElasticity = false;
		m_reverseKeyBack = false;
		m_scene = nullptr;
		m_alertProtocol = nullptr;
		m_scrollingLayer = nullptr;
		m_button2 = nullptr;
		m_button1 = nullptr;
		m_joystickConnected = -1;
		m_containsBorder = 0;
		m_forcePrioRegistered = false;
	}

auto FLAlertLayer::create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width, bool scroll, float height, float textScale) -> decltype(create(delegate, title, desc, btn1, btn2, width, scroll, height, textScale)) {
	using FunctionType = decltype(create(delegate, title, desc, btn1, btn2, width, scroll, height, textScale))(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float, float);
	static auto func = wrapFunction(base::get() + 0x30da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(delegate, title, desc, btn1, btn2, width, scroll, height, textScale);
}

auto FLAlertLayer::create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2, float width) -> decltype(create(delegate, title, desc, btn1, btn2, width)) {
	using FunctionType = decltype(create(delegate, title, desc, btn1, btn2, width))(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x30cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(delegate, title, desc, btn1, btn2, width);
}

auto FLAlertLayer::create(FLAlertLayerProtocol* delegate, char const* title, gd::string desc, char const* btn1, char const* btn2) -> decltype(create(delegate, title, desc, btn1, btn2)) {
	using FunctionType = decltype(create(delegate, title, desc, btn1, btn2))(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x30c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(delegate, title, desc, btn1, btn2);
}

FLAlertLayer* FLAlertLayer::create(char const* title, const gd::string& desc, char const* btn) {
		return FLAlertLayer::create(nullptr, title, desc, btn, nullptr, 300.0);
	}

auto FLAlertLayer::init(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5, bool p6, float p7, float p8) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(FLAlertLayer*, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float, float);
	static auto func = wrapFunction(base::get() + 0x30f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto FLAlertLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FLAlertLayer*, int);
	static auto func = wrapFunction(base::get() + 0x30ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FLAlertLayer::onBtn1(cocos2d::CCObject* sender) -> decltype(onBtn1(sender)) {
	using FunctionType = decltype(onBtn1(sender))(*)(FLAlertLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x31ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FLAlertLayer::onBtn2(cocos2d::CCObject* sender) -> decltype(onBtn2(sender)) {
	using FunctionType = decltype(onBtn2(sender))(*)(FLAlertLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x31af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FLAlertLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x31b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x31c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x31bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x31c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x31e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FLAlertLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x31a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FLAlertLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&FLAlertLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(FLAlertLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x319a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FLAlertLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::show), this);
	using FunctionType = decltype(show())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x31cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void TextInputDelegate::textChanged(CCTextInputNode* p0) {}

void TextInputDelegate::textInputOpened(CCTextInputNode* p0) {}

void TextInputDelegate::textInputClosed(CCTextInputNode* p0) {}

void TextInputDelegate::textInputShouldOffset(CCTextInputNode* p0, float p1) {}

void TextInputDelegate::textInputReturn(CCTextInputNode* p0) {}

bool TextInputDelegate::allowTextInput(CCTextInputNode* p0) { return true; }

void TextInputDelegate::enterPressed(CCTextInputNode* p0) {}

auto GJAccountLoginDelegate::loginAccountFinished(int p0, int p1) -> decltype(loginAccountFinished(p0, p1)) {
	throw std::runtime_error("GJAccountLoginDelegate::loginAccountFinished not implemented");
}

auto GJAccountLoginDelegate::loginAccountFailed(AccountError p0) -> decltype(loginAccountFailed(p0)) {
	throw std::runtime_error("GJAccountLoginDelegate::loginAccountFailed not implemented");
}

auto AccountLoginLayer::create(gd::string p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x55bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto AccountLoginLayer::init(gd::string p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(AccountLoginLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x55cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AccountLoginLayer::onForgotPassword(cocos2d::CCObject* sender) -> decltype(onForgotPassword(sender)) {
	using FunctionType = decltype(onForgotPassword(sender))(*)(AccountLoginLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x56440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AccountLoginLayer::onForgotUser(cocos2d::CCObject* sender) -> decltype(onForgotUser(sender)) {
	using FunctionType = decltype(onForgotUser(sender))(*)(AccountLoginLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x56420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AccountLoginLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("AccountLoginLayer::registerWithTouchDispatcher not implemented");
}

auto AccountLoginLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("AccountLoginLayer::keyBackClicked not implemented");
}

auto AccountLoginLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("AccountLoginLayer::FLAlert_Clicked not implemented");
}

auto AccountLoginLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("AccountLoginLayer::textInputOpened not implemented");
}

auto AccountLoginLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("AccountLoginLayer::textInputClosed not implemented");
}

auto AccountLoginLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("AccountLoginLayer::textChanged not implemented");
}

auto AccountLoginLayer::loginAccountFinished(int p0, int p1) -> decltype(loginAccountFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&AccountLoginLayer::loginAccountFinished), this);
	using FunctionType = decltype(loginAccountFinished(p0, p1))(*)(AccountLoginLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x56680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountLoginLayer::loginAccountFailed(AccountError p0) -> decltype(loginAccountFailed(p0)) {
	throw std::runtime_error("AccountLoginLayer::loginAccountFailed not implemented");
}

auto GJAccountRegisterDelegate::registerAccountFinished() -> decltype(registerAccountFinished()) {
	throw std::runtime_error("GJAccountRegisterDelegate::registerAccountFinished not implemented");
}

auto GJAccountRegisterDelegate::registerAccountFailed(AccountError p0) -> decltype(registerAccountFailed(p0)) {
	throw std::runtime_error("GJAccountRegisterDelegate::registerAccountFailed not implemented");
}

auto AccountRegisterLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x53b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AccountRegisterLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountRegisterLayer::init), this);
	using FunctionType = decltype(init())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x53c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountRegisterLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("AccountRegisterLayer::registerWithTouchDispatcher not implemented");
}

auto AccountRegisterLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("AccountRegisterLayer::keyBackClicked not implemented");
}

auto AccountRegisterLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("AccountRegisterLayer::FLAlert_Clicked not implemented");
}

auto AccountRegisterLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("AccountRegisterLayer::textInputOpened not implemented");
}

auto AccountRegisterLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("AccountRegisterLayer::textInputClosed not implemented");
}

auto AccountRegisterLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("AccountRegisterLayer::textChanged not implemented");
}

auto AccountRegisterLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("AccountRegisterLayer::textInputShouldOffset not implemented");
}

auto AccountRegisterLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("AccountRegisterLayer::textInputReturn not implemented");
}

auto AccountRegisterLayer::allowTextInput(CCTextInputNode* p0) -> decltype(allowTextInput(p0)) {
	throw std::runtime_error("AccountRegisterLayer::allowTextInput not implemented");
}

auto AccountRegisterLayer::registerAccountFinished() -> decltype(registerAccountFinished()) {
	throw std::runtime_error("AccountRegisterLayer::registerAccountFinished not implemented");
}

auto AccountRegisterLayer::registerAccountFailed(AccountError p0) -> decltype(registerAccountFailed(p0)) {
	throw std::runtime_error("AccountRegisterLayer::registerAccountFailed not implemented");
}

auto AchievementBar::create(char const* title, char const* desc, char const* icon, bool quest) -> decltype(create(title, desc, icon, quest)) {
	using FunctionType = decltype(create(title, desc, icon, quest))(*)(char const*, char const*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x59720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(title, desc, icon, quest);
}

auto AchievementBar::init(char const* title, char const* desc, char const* icon, bool quest) -> decltype(init(title, desc, icon, quest)) {
	using FunctionType = decltype(init(title, desc, icon, quest))(*)(AchievementBar*, char const*, char const*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x59800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, title, desc, icon, quest);
}

auto AchievementBar::show() -> decltype(show()) {
	using FunctionType = decltype(show())(*)(AchievementBar*);
	static auto func = wrapFunction(base::get() + 0x5a610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AchievementBar::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("AchievementBar::setOpacity not implemented");
}

CCIndexPath::CCIndexPath() {}

TableViewCell::TableViewCell(char const* p0, float p1, float p2) : TableViewCell(geode::CutoffConstructor, sizeof(TableViewCell)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	TableViewCell::~TableViewCell();
	using FunctionType = void(*)(TableViewCell*, char const*, float, float);
	static auto func = wrapFunction(base::get() + 0x51db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto AchievementCell::loadFromDict(cocos2d::CCDictionary* p0) -> decltype(loadFromDict(p0)) {
	using FunctionType = decltype(loadFromDict(p0))(*)(AchievementCell*, cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x7c730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementCell::init() -> decltype(init()) {
	throw std::runtime_error("AchievementCell::init not implemented");
}

auto AchievementCell::draw() -> decltype(draw()) {
	throw std::runtime_error("AchievementCell::draw not implemented");
}

auto AchievementManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x9ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AchievementManager::addAchievement(gd::string p0, gd::string p1, gd::string p2, gd::string p3, gd::string p4, int p5) -> decltype(addAchievement(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(addAchievement(p0, p1, p2, p3, p4, p5))(*)(AchievementManager*, gd::string, gd::string, gd::string, gd::string, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x9bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto AchievementManager::addManualAchievements() -> decltype(addManualAchievements()) {
	using FunctionType = decltype(addManualAchievements())(*)(AchievementManager*);
	static auto func = wrapFunction(base::get() + 0xf74a, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AchievementManager::notifyAchievementWithID(char const* p0) -> decltype(notifyAchievementWithID(p0)) {
	using FunctionType = decltype(notifyAchievementWithID(p0))(*)(AchievementManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1b550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementManager::percentForAchievement(char const* p0) -> decltype(percentForAchievement(p0)) {
	using FunctionType = decltype(percentForAchievement(p0))(*)(AchievementManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1ab50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementManager::reportAchievementWithID(char const* p0, int p1, bool p2) -> decltype(reportAchievementWithID(p0, p1, p2)) {
	using FunctionType = decltype(reportAchievementWithID(p0, p1, p2))(*)(AchievementManager*, char const*, int, bool);
	static auto func = wrapFunction(base::get() + 0x1b7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto AchievementManager::reportPlatformAchievementWithID(char const* p0, int p1) -> decltype(reportPlatformAchievementWithID(p0, p1)) {
	using FunctionType = decltype(reportPlatformAchievementWithID(p0, p1))(*)(AchievementManager*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x1b8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto AchievementManager::resetAchievement(char const* p0) -> decltype(resetAchievement(p0)) {
	using FunctionType = decltype(resetAchievement(p0))(*)(AchievementManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1b730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementManager::init() -> decltype(init()) {
	throw std::runtime_error("AchievementManager::init not implemented");
}

auto AchievementNotifier::showNextAchievement() -> decltype(showNextAchievement()) {
	using FunctionType = decltype(showNextAchievement())(*)(AchievementNotifier*);
	static auto func = wrapFunction(base::get() + 0x1c0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AchievementNotifier::willSwitchToScene(cocos2d::CCScene* p0) -> decltype(willSwitchToScene(p0)) {
	using FunctionType = decltype(willSwitchToScene(p0))(*)(AchievementNotifier*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x1c200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementNotifier::init() -> decltype(init()) {
	throw std::runtime_error("AchievementNotifier::init not implemented");
}

auto AchievementsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x5a9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AchievementsLayer::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(AchievementsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x5adc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementsLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(AchievementsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5b040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AchievementsLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(AchievementsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5b050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto AchievementsLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	throw std::runtime_error("AchievementsLayer::keyDown not implemented");
}

auto AchievementsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AchievementsLayer*);
	static auto func = wrapFunction(base::get() + 0x5aab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpritePlus::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x28c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x28c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x28d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&CCSpritePlus::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(CCSpritePlus*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x288f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x28950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x289d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x28a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	throw std::runtime_error("CCSpritePlus::initWithTexture not implemented");
}

auto CCSpritePlus::initWithSpriteFrameName(char const* p0) -> decltype(initWithSpriteFrameName(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&CCSpritePlus::initWithSpriteFrameName), this);
	using FunctionType = decltype(initWithSpriteFrameName(p0))(*)(CCSpritePlus*, char const*);
	static auto func = wrapFunction(base::get() + 0x288b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	throw std::runtime_error("CCSpritePlus::setFlipX not implemented");
}

auto CCSpritePlus::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	throw std::runtime_error("CCSpritePlus::setFlipY not implemented");
}

auto GameObject::colorForMode(int p0, bool p1) -> decltype(colorForMode(p0, p1)) {
	using FunctionType = decltype(colorForMode(p0, p1))(*)(GameObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x142a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameObject::commonSetup() -> decltype(commonSetup()) {
	using FunctionType = decltype(commonSetup())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1310c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::copyGroups(GameObject* p0) -> decltype(copyGroups(p0)) {
	using FunctionType = decltype(copyGroups(p0))(*)(GameObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x13d8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::createAndAddParticle(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) -> decltype(createAndAddParticle(p0, p1, p2, p3)) {
	using FunctionType = decltype(createAndAddParticle(p0, p1, p2, p3))(*)(GameObject*, int, char const*, int, cocos2d::tCCPositionType);
	static auto func = wrapFunction(base::get() + 0x13b790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameObject::createGroupContainer(int p0) -> decltype(createGroupContainer(p0)) {
	using FunctionType = decltype(createGroupContainer(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x13d790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::createWithFrame(char const* p0) -> decltype(createWithFrame(p0)) {
	using FunctionType = decltype(createWithFrame(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x130fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameObject::createWithKey(int p0) -> decltype(createWithKey(p0)) {
	using FunctionType = decltype(createWithKey(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x130330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameObject::determineSlopeDirection() -> decltype(determineSlopeDirection()) {
	using FunctionType = decltype(determineSlopeDirection())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x13d3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::duplicateColorMode(GameObject* p0) -> decltype(duplicateColorMode(p0)) {
	using FunctionType = decltype(duplicateColorMode(p0))(*)(GameObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1424c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::duplicateValues(GameObject* p0) -> decltype(duplicateValues(p0)) {
	using FunctionType = decltype(duplicateValues(p0))(*)(GameObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1426f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::getActiveColorForMode(int p0, bool p1) -> decltype(getActiveColorForMode(p0, p1)) {
	using FunctionType = decltype(getActiveColorForMode(p0, p1))(*)(GameObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x142d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameObject::getColorKey(bool p0, bool p1) -> decltype(getColorKey(p0, p1)) {
	using FunctionType = decltype(getColorKey(p0, p1))(*)(GameObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x13df90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameObject::getParentMode() -> decltype(getParentMode()) {
	using FunctionType = decltype(getParentMode())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x13ca30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::getRelativeSpriteColor(int p0) -> decltype(getRelativeSpriteColor(p0)) {
	using FunctionType = decltype(getRelativeSpriteColor(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x142320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::groupOpacityMod() -> decltype(groupOpacityMod()) {
	using FunctionType = decltype(groupOpacityMod())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x13dd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::isFacingDown() -> decltype(isFacingDown()) {
	using FunctionType = decltype(isFacingDown())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x142180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::isSpeedObject() -> decltype(isSpeedObject()) {
	using FunctionType = decltype(isSpeedObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x143970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::isTrigger() -> decltype(isTrigger()) {
	using FunctionType = decltype(isTrigger())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x142ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::loadGroupsFromString(gd::string p0) -> decltype(loadGroupsFromString(p0)) {
	using FunctionType = decltype(loadGroupsFromString(p0))(*)(GameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x13dc20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::objectFromVector(gd::vector<gd::string>& p0, gd::vector<void*>& p1, GJBaseGameLayer* p2, bool p3) -> decltype(objectFromVector(p0, p1, p2, p3)) {
	using FunctionType = decltype(objectFromVector(p0, p1, p2, p3))(*)(GameObject*, gd::vector<gd::string>&, gd::vector<void*>&, GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x13e420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameObject::playShineEffect() -> decltype(playShineEffect()) {
	using FunctionType = decltype(playShineEffect())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x13bf40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::shouldBlendColor(GJSpriteColor* p0, bool p1) -> decltype(shouldBlendColor(p0, p1)) {
	using FunctionType = decltype(shouldBlendColor(p0, p1))(*)(GameObject*, GJSpriteColor*, bool);
	static auto func = wrapFunction(base::get() + 0x133880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameObject::shouldLockX() -> decltype(shouldLockX()) {
	using FunctionType = decltype(shouldLockX())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x139d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::updateBlendMode() -> decltype(updateBlendMode()) {
	using FunctionType = decltype(updateBlendMode())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x13cf30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::updateCustomScaleX(float p0) -> decltype(updateCustomScaleX(p0)) {
	using FunctionType = decltype(updateCustomScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x13b290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::updateCustomScaleY(float p0) -> decltype(updateCustomScaleY(p0)) {
	using FunctionType = decltype(updateCustomScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x13b350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::updateIsOriented() -> decltype(updateIsOriented()) {
	using FunctionType = decltype(updateIsOriented())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x141fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::updateObjectEditorColor() -> decltype(updateObjectEditorColor()) {
	using FunctionType = decltype(updateObjectEditorColor())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x141b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::updateStartPos() -> decltype(updateStartPos()) {
	using FunctionType = decltype(updateStartPos())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x133160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("GameObject::update not implemented");
}

auto GameObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x13af80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x13b010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x13b0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&GameObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(GameObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x13aa40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x13b890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x13ac30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x13ad30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x13ae30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x13b490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&GameObject::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0))(*)(GameObject*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x131080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setChildColor(cocos2d::ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::setChildColor), this);
	using FunctionType = decltype(setChildColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x141630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setFlipX), this);
	using FunctionType = decltype(setFlipX(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x13af00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setFlipY), this);
	using FunctionType = decltype(setFlipY(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x13af40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::firstSetup() -> decltype(firstSetup()) {
	throw std::runtime_error("GameObject::firstSetup not implemented");
}

auto GameObject::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("GameObject::customSetup not implemented");
}

auto GameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	throw std::runtime_error("GameObject::setupCustomSprites not implemented");
}

auto GameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::addMainSpriteToParent), this);
	using FunctionType = decltype(addMainSpriteToParent(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x13cf90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("GameObject::resetObject not implemented");
}

auto GameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("GameObject::triggerObject not implemented");
}

auto GameObject::activateObject() -> decltype(activateObject()) {
	throw std::runtime_error("GameObject::activateObject not implemented");
}

auto GameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::deactivateObject), this);
	using FunctionType = decltype(deactivateObject(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x133790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::transferObjectRect(cocos2d::CCRect& p0) -> decltype(transferObjectRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect&>::func(&GameObject::transferObjectRect), this);
	using FunctionType = decltype(transferObjectRect(p0))(*)(GameObject*, cocos2d::CCRect&);
	static auto func = wrapFunction(base::get() + 0x13a500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getObjectRect() -> decltype(getObjectRect()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectRect), this);
	using FunctionType = decltype(getObjectRect())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x13a570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getObjectRect(float p0, float p1) -> decltype(getObjectRect(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&GameObject::getObjectRect), this);
	using FunctionType = decltype(getObjectRect(p0, p1))(*)(GameObject*, float, float);
	static auto func = wrapFunction(base::get() + 0x13a570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GameObject::getObjectRect2(float p0, float p1) -> decltype(getObjectRect2(p0, p1)) {
	throw std::runtime_error("GameObject::getObjectRect2 not implemented");
}

auto GameObject::getObjectTextureRect() -> decltype(getObjectTextureRect()) {
	throw std::runtime_error("GameObject::getObjectTextureRect not implemented");
}

auto GameObject::getRealPosition() -> decltype(getRealPosition()) {
	throw std::runtime_error("GameObject::getRealPosition not implemented");
}

auto GameObject::setStartPos(cocos2d::CCPoint p0) -> decltype(setStartPos(p0)) {
	throw std::runtime_error("GameObject::setStartPos not implemented");
}

auto GameObject::updateStartValues() -> decltype(updateStartValues()) {
	throw std::runtime_error("GameObject::updateStartValues not implemented");
}

auto GameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("GameObject::customObjectSetup not implemented");
}

auto GameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&GameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(GameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x13f9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::claimParticle() -> decltype(claimParticle()) {
	throw std::runtime_error("GameObject::claimParticle not implemented");
}

auto GameObject::unclaimParticle() -> decltype(unclaimParticle()) {
	throw std::runtime_error("GameObject::unclaimParticle not implemented");
}

auto GameObject::particleWasActivated() -> decltype(particleWasActivated()) {
	throw std::runtime_error("GameObject::particleWasActivated not implemented");
}

auto GameObject::isFlipX() -> decltype(isFlipX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::isFlipX), this);
	using FunctionType = decltype(isFlipX())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x13aee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::isFlipY() -> decltype(isFlipY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::isFlipY), this);
	using FunctionType = decltype(isFlipY())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x13aef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setRScaleX(float p0) -> decltype(setRScaleX(p0)) {
	throw std::runtime_error("GameObject::setRScaleX not implemented");
}

auto GameObject::setRScaleY(float p0) -> decltype(setRScaleY(p0)) {
	throw std::runtime_error("GameObject::setRScaleY not implemented");
}

auto GameObject::setRScale(float p0) -> decltype(setRScale(p0)) {
	throw std::runtime_error("GameObject::setRScale not implemented");
}

auto GameObject::getRScaleX() -> decltype(getRScaleX()) {
	throw std::runtime_error("GameObject::getRScaleX not implemented");
}

auto GameObject::getRScaleY() -> decltype(getRScaleY()) {
	throw std::runtime_error("GameObject::getRScaleY not implemented");
}

auto GameObject::setRRotation(float p0) -> decltype(setRRotation(p0)) {
	throw std::runtime_error("GameObject::setRRotation not implemented");
}

auto GameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	throw std::runtime_error("GameObject::triggerActivated not implemented");
}

auto GameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&GameObject::setObjectColor), this);
	using FunctionType = decltype(setObjectColor(p0))(*)(GameObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x141300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setGlowColor(cocos2d::ccColor3B const& p0) -> decltype(setGlowColor(p0)) {
	throw std::runtime_error("GameObject::setGlowColor not implemented");
}

auto GameObject::restoreObject() -> decltype(restoreObject()) {
	throw std::runtime_error("GameObject::restoreObject not implemented");
}

auto GameObject::animationTriggered() -> decltype(animationTriggered()) {
	throw std::runtime_error("GameObject::animationTriggered not implemented");
}

auto GameObject::selectObject(cocos2d::ccColor3B p0) -> decltype(selectObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B>::func(&GameObject::selectObject), this);
	using FunctionType = decltype(selectObject(p0))(*)(GameObject*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x141690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::activatedByPlayer(PlayerObject* p0) -> decltype(activatedByPlayer(p0)) {
	throw std::runtime_error("GameObject::activatedByPlayer not implemented");
}

auto GameObject::hasBeenActivatedByPlayer(PlayerObject* p0) -> decltype(hasBeenActivatedByPlayer(p0)) {
	throw std::runtime_error("GameObject::hasBeenActivatedByPlayer not implemented");
}

auto GameObject::hasBeenActivated() -> decltype(hasBeenActivated()) {
	throw std::runtime_error("GameObject::hasBeenActivated not implemented");
}

auto GameObject::getOrientedBox() -> decltype(getOrientedBox()) {
	throw std::runtime_error("GameObject::getOrientedBox not implemented");
}

auto GameObject::updateOrientedBox() -> decltype(updateOrientedBox()) {
	throw std::runtime_error("GameObject::updateOrientedBox not implemented");
}

auto GameObject::getObjectRotation() -> decltype(getObjectRotation()) {
	throw std::runtime_error("GameObject::getObjectRotation not implemented");
}

auto GameObject::updateMainColor(cocos2d::ccColor3B const& p0) -> decltype(updateMainColor(p0)) {
	throw std::runtime_error("GameObject::updateMainColor not implemented");
}

auto GameObject::updateSecondaryColor(cocos2d::ccColor3B const& p0) -> decltype(updateSecondaryColor(p0)) {
	throw std::runtime_error("GameObject::updateSecondaryColor not implemented");
}

auto GameObject::addToGroup(int p0) -> decltype(addToGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameObject::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x13d7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::removeFromGroup(int p0) -> decltype(removeFromGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameObject::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x13d870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::saveActiveColors() -> decltype(saveActiveColors()) {
	throw std::runtime_error("GameObject::saveActiveColors not implemented");
}

auto GameObject::spawnXPosition() -> decltype(spawnXPosition()) {
	throw std::runtime_error("GameObject::spawnXPosition not implemented");
}

auto GameObject::canAllowMultiActivate() -> decltype(canAllowMultiActivate()) {
	throw std::runtime_error("GameObject::canAllowMultiActivate not implemented");
}

auto GameObject::blendModeChanged() -> decltype(blendModeChanged()) {
	throw std::runtime_error("GameObject::blendModeChanged not implemented");
}

auto GameObject::updateParticleColor(cocos2d::ccColor3B const& p0) -> decltype(updateParticleColor(p0)) {
	throw std::runtime_error("GameObject::updateParticleColor not implemented");
}

auto GameObject::updateParticleOpacity(unsigned char p0) -> decltype(updateParticleOpacity(p0)) {
	throw std::runtime_error("GameObject::updateParticleOpacity not implemented");
}

auto GameObject::updateMainParticleOpacity(unsigned char p0) -> decltype(updateMainParticleOpacity(p0)) {
	throw std::runtime_error("GameObject::updateMainParticleOpacity not implemented");
}

auto GameObject::updateSecondaryParticleOpacity(unsigned char p0) -> decltype(updateSecondaryParticleOpacity(p0)) {
	throw std::runtime_error("GameObject::updateSecondaryParticleOpacity not implemented");
}

auto GameObject::canReverse() -> decltype(canReverse()) {
	throw std::runtime_error("GameObject::canReverse not implemented");
}

auto GameObject::isSpecialSpawnObject() -> decltype(isSpecialSpawnObject()) {
	throw std::runtime_error("GameObject::isSpecialSpawnObject not implemented");
}

auto GameObject::canBeOrdered() -> decltype(canBeOrdered()) {
	throw std::runtime_error("GameObject::canBeOrdered not implemented");
}

auto GameObject::getObjectLabel() -> decltype(getObjectLabel()) {
	throw std::runtime_error("GameObject::getObjectLabel not implemented");
}

auto GameObject::setObjectLabel(cocos2d::CCLabelBMFont* p0) -> decltype(setObjectLabel(p0)) {
	throw std::runtime_error("GameObject::setObjectLabel not implemented");
}

auto GameObject::shouldDrawEditorHitbox() -> decltype(shouldDrawEditorHitbox()) {
	throw std::runtime_error("GameObject::shouldDrawEditorHitbox not implemented");
}

auto GameObject::getHasSyncedAnimation() -> decltype(getHasSyncedAnimation()) {
	throw std::runtime_error("GameObject::getHasSyncedAnimation not implemented");
}

auto GameObject::getHasRotateAction() -> decltype(getHasRotateAction()) {
	throw std::runtime_error("GameObject::getHasRotateAction not implemented");
}

auto GameObject::canMultiActivate(bool p0) -> decltype(canMultiActivate(p0)) {
	throw std::runtime_error("GameObject::canMultiActivate not implemented");
}

auto GameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	throw std::runtime_error("GameObject::updateTextKerning not implemented");
}

auto GameObject::getTextKerning() -> decltype(getTextKerning()) {
	throw std::runtime_error("GameObject::getTextKerning not implemented");
}

auto GameObject::setObjectRectDirty(bool p0) -> decltype(setObjectRectDirty(p0)) {
	throw std::runtime_error("GameObject::setObjectRectDirty not implemented");
}

auto GameObject::setOrientedRectDirty(bool p0) -> decltype(setOrientedRectDirty(p0)) {
	throw std::runtime_error("GameObject::setOrientedRectDirty not implemented");
}

auto GameObject::setType(GameObjectType p0) -> decltype(setType(p0)) {
	throw std::runtime_error("GameObject::setType not implemented");
}

auto EnhancedGameObject::updateUserCoin() -> decltype(updateUserCoin()) {
	using FunctionType = decltype(updateUserCoin())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x1473b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EnhancedGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x145af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x145510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EnhancedGameObject::deactivateObject), this);
	using FunctionType = decltype(deactivateObject(p0))(*)(EnhancedGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1474c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&EnhancedGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EnhancedGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1457b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EnhancedGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EnhancedGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EnhancedGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x147520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	throw std::runtime_error("EnhancedGameObject::triggerActivated not implemented");
}

auto EnhancedGameObject::restoreObject() -> decltype(restoreObject()) {
	throw std::runtime_error("EnhancedGameObject::restoreObject not implemented");
}

auto EnhancedGameObject::animationTriggered() -> decltype(animationTriggered()) {
	throw std::runtime_error("EnhancedGameObject::animationTriggered not implemented");
}

auto EnhancedGameObject::activatedByPlayer(PlayerObject* p0) -> decltype(activatedByPlayer(p0)) {
	throw std::runtime_error("EnhancedGameObject::activatedByPlayer not implemented");
}

auto EnhancedGameObject::hasBeenActivatedByPlayer(PlayerObject* p0) -> decltype(hasBeenActivatedByPlayer(p0)) {
	throw std::runtime_error("EnhancedGameObject::hasBeenActivatedByPlayer not implemented");
}

auto EnhancedGameObject::hasBeenActivated() -> decltype(hasBeenActivated()) {
	throw std::runtime_error("EnhancedGameObject::hasBeenActivated not implemented");
}

auto EnhancedGameObject::saveActiveColors() -> decltype(saveActiveColors()) {
	throw std::runtime_error("EnhancedGameObject::saveActiveColors not implemented");
}

auto EnhancedGameObject::canAllowMultiActivate() -> decltype(canAllowMultiActivate()) {
	throw std::runtime_error("EnhancedGameObject::canAllowMultiActivate not implemented");
}

auto EnhancedGameObject::getHasSyncedAnimation() -> decltype(getHasSyncedAnimation()) {
	throw std::runtime_error("EnhancedGameObject::getHasSyncedAnimation not implemented");
}

auto EnhancedGameObject::getHasRotateAction() -> decltype(getHasRotateAction()) {
	throw std::runtime_error("EnhancedGameObject::getHasRotateAction not implemented");
}

auto EnhancedGameObject::canMultiActivate(bool p0) -> decltype(canMultiActivate(p0)) {
	throw std::runtime_error("EnhancedGameObject::canMultiActivate not implemented");
}

auto EnhancedGameObject::powerOnObject(int p0) -> decltype(powerOnObject(p0)) {
	throw std::runtime_error("EnhancedGameObject::powerOnObject not implemented");
}

auto EnhancedGameObject::powerOffObject() -> decltype(powerOffObject()) {
	throw std::runtime_error("EnhancedGameObject::powerOffObject not implemented");
}

auto EnhancedGameObject::stateSensitiveOff(GJBaseGameLayer* p0) -> decltype(stateSensitiveOff(p0)) {
	throw std::runtime_error("EnhancedGameObject::stateSensitiveOff not implemented");
}

auto EnhancedGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	throw std::runtime_error("EnhancedGameObject::updateSyncedAnimation not implemented");
}

auto EnhancedGameObject::updateAnimateOnTrigger(bool p0) -> decltype(updateAnimateOnTrigger(p0)) {
	throw std::runtime_error("EnhancedGameObject::updateAnimateOnTrigger not implemented");
}

auto EffectGameObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x39c8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto EffectGameObject::init(char const* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EffectGameObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x39c950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EffectGameObject::playTriggerEffect() -> decltype(playTriggerEffect()) {
	using FunctionType = decltype(playTriggerEffect())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x39ca70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EffectGameObject::triggerEffectFinished() -> decltype(triggerEffectFinished()) {
	using FunctionType = decltype(triggerEffectFinished())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x39cca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EffectGameObject::updateSpecialColor() -> decltype(updateSpecialColor()) {
	using FunctionType = decltype(updateSpecialColor())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x39e750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EffectGameObject::updateSpeedModType() -> decltype(updateSpeedModType()) {
	using FunctionType = decltype(updateSpeedModType())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x3a1c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EffectGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("EffectGameObject::setOpacity not implemented");
}

auto EffectGameObject::firstSetup() -> decltype(firstSetup()) {
	throw std::runtime_error("EffectGameObject::firstSetup not implemented");
}

auto EffectGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x39e950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&EffectGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(EffectGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x39ccf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto EffectGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&EffectGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EffectGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x39eb70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EffectGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EffectGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EffectGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x3a1df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::setRScaleX(float p0) -> decltype(setRScaleX(p0)) {
	throw std::runtime_error("EffectGameObject::setRScaleX not implemented");
}

auto EffectGameObject::setRScaleY(float p0) -> decltype(setRScaleY(p0)) {
	throw std::runtime_error("EffectGameObject::setRScaleY not implemented");
}

auto EffectGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	throw std::runtime_error("EffectGameObject::triggerActivated not implemented");
}

auto EffectGameObject::restoreObject() -> decltype(restoreObject()) {
	throw std::runtime_error("EffectGameObject::restoreObject not implemented");
}

auto EffectGameObject::spawnXPosition() -> decltype(spawnXPosition()) {
	throw std::runtime_error("EffectGameObject::spawnXPosition not implemented");
}

auto EffectGameObject::canReverse() -> decltype(canReverse()) {
	throw std::runtime_error("EffectGameObject::canReverse not implemented");
}

auto EffectGameObject::isSpecialSpawnObject() -> decltype(isSpecialSpawnObject()) {
	throw std::runtime_error("EffectGameObject::isSpecialSpawnObject not implemented");
}

auto EffectGameObject::canBeOrdered() -> decltype(canBeOrdered()) {
	throw std::runtime_error("EffectGameObject::canBeOrdered not implemented");
}

auto EffectGameObject::getObjectLabel() -> decltype(getObjectLabel()) {
	throw std::runtime_error("EffectGameObject::getObjectLabel not implemented");
}

auto EffectGameObject::setObjectLabel(cocos2d::CCLabelBMFont* p0) -> decltype(setObjectLabel(p0)) {
	throw std::runtime_error("EffectGameObject::setObjectLabel not implemented");
}

auto EffectGameObject::stateSensitiveOff(GJBaseGameLayer* p0) -> decltype(stateSensitiveOff(p0)) {
	throw std::runtime_error("EffectGameObject::stateSensitiveOff not implemented");
}

auto AdvancedFollowTriggerObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x393950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto AdvancedFollowTriggerObject::getAdvancedFollowID() -> decltype(getAdvancedFollowID()) {
	using FunctionType = decltype(getAdvancedFollowID())(*)(AdvancedFollowTriggerObject*);
	static auto func = wrapFunction(base::get() + 0x3939f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AdvancedFollowTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&AdvancedFollowTriggerObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(AdvancedFollowTriggerObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x395bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AdvancedFollowTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&AdvancedFollowTriggerObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(AdvancedFollowTriggerObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x393a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AdvancedFollowEditObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x396ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto AdvancedFollowEditObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&AdvancedFollowEditObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(AdvancedFollowEditObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x397030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AdvancedFollowEditObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&AdvancedFollowEditObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(AdvancedFollowEditObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x396c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedSpriteDelegate::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	throw std::runtime_error("AnimatedSpriteDelegate::animationFinished not implemented");
}

auto SpritePartDelegate::displayFrameChanged(cocos2d::CCObject* p0, gd::string p1) -> decltype(displayFrameChanged(p0, p1)) {
	throw std::runtime_error("SpritePartDelegate::displayFrameChanged not implemented");
}

auto AnimatedGameObject::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x39ab70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto AnimatedGameObject::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(AnimatedGameObject*, int);
	static auto func = wrapFunction(base::get() + 0x39ac10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AnimatedGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("AnimatedGameObject::setOpacity not implemented");
}

auto AnimatedGameObject::setChildColor(cocos2d::ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	throw std::runtime_error("AnimatedGameObject::setChildColor not implemented");
}

auto AnimatedGameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("AnimatedGameObject::resetObject not implemented");
}

auto AnimatedGameObject::activateObject() -> decltype(activateObject()) {
	throw std::runtime_error("AnimatedGameObject::activateObject not implemented");
}

auto AnimatedGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	throw std::runtime_error("AnimatedGameObject::deactivateObject not implemented");
}

auto AnimatedGameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	throw std::runtime_error("AnimatedGameObject::setObjectColor not implemented");
}

auto AnimatedGameObject::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	throw std::runtime_error("AnimatedGameObject::animationFinished not implemented");
}

auto AnimatedGameObject::displayFrameChanged(cocos2d::CCObject* p0, gd::string p1) -> decltype(displayFrameChanged(p0, p1)) {
	throw std::runtime_error("AnimatedGameObject::displayFrameChanged not implemented");
}

auto CCAnimatedSprite::cleanupSprite() -> decltype(cleanupSprite()) {
	using FunctionType = decltype(cleanupSprite())(*)(CCAnimatedSprite*);
	static auto func = wrapFunction(base::get() + 0x21440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCAnimatedSprite::createWithType(char const* p0, cocos2d::CCTexture2D* p1, bool p2) -> decltype(createWithType(p0, p1, p2)) {
	using FunctionType = decltype(createWithType(p0, p1, p2))(*)(CCAnimatedSprite*, char const*, cocos2d::CCTexture2D*, bool);
	static auto func = wrapFunction(base::get() + 0x20c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CCAnimatedSprite::initWithType(char const* p0, cocos2d::CCTexture2D* p1, bool p2) -> decltype(initWithType(p0, p1, p2)) {
	using FunctionType = decltype(initWithType(p0, p1, p2))(*)(CCAnimatedSprite*, char const*, cocos2d::CCTexture2D*, bool);
	static auto func = wrapFunction(base::get() + 0x20d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CCAnimatedSprite::loadType(char const* p0, cocos2d::CCTexture2D* p1, bool p2) -> decltype(loadType(p0, p1, p2)) {
	using FunctionType = decltype(loadType(p0, p1, p2))(*)(CCAnimatedSprite*, char const*, cocos2d::CCTexture2D*, bool);
	static auto func = wrapFunction(base::get() + 0x20ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CCAnimatedSprite::runAnimation(gd::string p0) -> decltype(runAnimation(p0)) {
	using FunctionType = decltype(runAnimation(p0))(*)(CCAnimatedSprite*, gd::string);
	static auto func = wrapFunction(base::get() + 0x21640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCAnimatedSprite::runAnimationForced(gd::string p0) -> decltype(runAnimationForced(p0)) {
	using FunctionType = decltype(runAnimationForced(p0))(*)(CCAnimatedSprite*, gd::string);
	static auto func = wrapFunction(base::get() + 0x216c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCAnimatedSprite::switchToMode(spriteMode p0) -> decltype(switchToMode(p0)) {
	using FunctionType = decltype(switchToMode(p0))(*)(CCAnimatedSprite*, spriteMode);
	static auto func = wrapFunction(base::get() + 0x214f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCAnimatedSprite::tweenToAnimation(gd::string p0, float p1) -> decltype(tweenToAnimation(p0, p1)) {
	using FunctionType = decltype(tweenToAnimation(p0, p1))(*)(CCAnimatedSprite*, gd::string, float);
	static auto func = wrapFunction(base::get() + 0x21750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CCAnimatedSprite::tweenToAnimationFinished() -> decltype(tweenToAnimationFinished()) {
	using FunctionType = decltype(tweenToAnimationFinished())(*)(CCAnimatedSprite*);
	static auto func = wrapFunction(base::get() + 0x219c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCAnimatedSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("CCAnimatedSprite::setOpacity not implemented");
}

auto CCAnimatedSprite::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	throw std::runtime_error("CCAnimatedSprite::setColor not implemented");
}

auto CCAnimatedSprite::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	throw std::runtime_error("CCAnimatedSprite::animationFinished not implemented");
}

auto CCAnimatedSprite::animationFinishedO(cocos2d::CCObject* p0) -> decltype(animationFinishedO(p0)) {
	throw std::runtime_error("CCAnimatedSprite::animationFinishedO not implemented");
}

auto AnimatedShopKeeper::create(ShopType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(ShopType);
	static auto func = wrapFunction(base::get() + 0x21d880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto AnimatedShopKeeper::init(ShopType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(AnimatedShopKeeper*, ShopType);
	static auto func = wrapFunction(base::get() + 0x21d920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AnimatedShopKeeper::playReactAnimation() -> decltype(playReactAnimation()) {
	using FunctionType = decltype(playReactAnimation())(*)(AnimatedShopKeeper*);
	static auto func = wrapFunction(base::get() + 0x21da20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AnimatedShopKeeper::startAnimating() -> decltype(startAnimating()) {
	using FunctionType = decltype(startAnimating())(*)(AnimatedShopKeeper*);
	static auto func = wrapFunction(base::get() + 0x21db40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AnimatedShopKeeper::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&AnimatedShopKeeper::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(AnimatedShopKeeper*, char const*);
	static auto func = wrapFunction(base::get() + 0x21db80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AppDelegate::musicTest() -> decltype(musicTest()) {
	using FunctionType = decltype(musicTest())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x5b710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AppDelegate::pauseGame() -> decltype(pauseGame()) {
	using FunctionType = decltype(pauseGame())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x5b5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AppDelegate::pauseSound() -> decltype(pauseSound()) {
	using FunctionType = decltype(pauseSound())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x5b640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AppDelegate::resumeSound() -> decltype(resumeSound()) {
	using FunctionType = decltype(resumeSound())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x5b6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AppDelegate::applicationDidFinishLaunching() -> decltype(applicationDidFinishLaunching()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationDidFinishLaunching), this);
	using FunctionType = decltype(applicationDidFinishLaunching())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x5b320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationDidEnterBackground() -> decltype(applicationDidEnterBackground()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationDidEnterBackground), this);
	using FunctionType = decltype(applicationDidEnterBackground())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x5b4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillEnterForeground() -> decltype(applicationWillEnterForeground()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationWillEnterForeground), this);
	using FunctionType = decltype(applicationWillEnterForeground())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x5b530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillBecomeActive() -> decltype(applicationWillBecomeActive()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationWillBecomeActive), this);
	using FunctionType = decltype(applicationWillBecomeActive())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x5b4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillResignActive() -> decltype(applicationWillResignActive()) {
	throw std::runtime_error("AppDelegate::applicationWillResignActive not implemented");
}

auto AppDelegate::trySaveGame(bool p0) -> decltype(trySaveGame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&AppDelegate::trySaveGame), this);
	using FunctionType = decltype(trySaveGame(p0))(*)(AppDelegate*, bool);
	static auto func = wrapFunction(base::get() + 0x5b790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AppDelegate::willSwitchToScene(cocos2d::CCScene* p0) -> decltype(willSwitchToScene(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCScene*>::func(&AppDelegate::willSwitchToScene), this);
	using FunctionType = decltype(willSwitchToScene(p0))(*)(AppDelegate*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x5b930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ArtistCell::loadFromObject(SongInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(ArtistCell*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x83eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ArtistCell::updateBGColor(int p0) -> decltype(updateBGColor(p0)) {
	using FunctionType = decltype(updateBGColor(p0))(*)(ArtistCell*, int);
	static auto func = wrapFunction(base::get() + 0x80e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ArtistCell::init() -> decltype(init()) {
	throw std::runtime_error("ArtistCell::init not implemented");
}

auto ArtistCell::draw() -> decltype(draw()) {
	throw std::runtime_error("ArtistCell::draw not implemented");
}

auto ArtTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("ArtTriggerGameObject::triggerObject not implemented");
}

auto ArtTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("ArtTriggerGameObject::customObjectSetup not implemented");
}

auto ArtTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("ArtTriggerGameObject::getSaveString not implemented");
}

auto AudioEffectsLayer::create(gd::string p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x5bc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto AudioEffectsLayer::audioStep(float p0) -> decltype(audioStep(p0)) {
	using FunctionType = decltype(audioStep(p0))(*)(AudioEffectsLayer*, float);
	static auto func = wrapFunction(base::get() + 0x5beb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AudioEffectsLayer::init(gd::string p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(AudioEffectsLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x5bd20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AudioEffectsLayer::triggerEffect(float p0) -> decltype(triggerEffect(p0)) {
	using FunctionType = decltype(triggerEffect(p0))(*)(AudioEffectsLayer*, float);
	static auto func = wrapFunction(base::get() + 0x5bf70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AudioEffectsLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("AudioEffectsLayer::draw not implemented");
}

auto AudioEffectsLayer::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&AudioEffectsLayer::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(p0, p1))(*)(AudioEffectsLayer*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x5c0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AudioLineGuideGameObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3b6730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AudioLineGuideGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AudioLineGuideGameObject::init), this);
	using FunctionType = decltype(init())(*)(AudioLineGuideGameObject*);
	static auto func = wrapFunction(base::get() + 0x3b67d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AudioLineGuideGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("AudioLineGuideGameObject::customObjectSetup not implemented");
}

auto AudioLineGuideGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("AudioLineGuideGameObject::getSaveString not implemented");
}

void TableViewDelegate::willTweenToIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::didEndTweenToIndexPath(CCIndexPath& p0, TableView* p1) {}

void TableViewDelegate::TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::TableViewDidDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

float TableViewDelegate::cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) { return 0; }

void TableViewDelegate::didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {}

int TableViewDataSource::numberOfRowsInSection(unsigned int p0, TableView* p1) { return 0; }

unsigned int TableViewDataSource::numberOfSectionsInTableView(TableView* p0) { return 0; }

void TableViewDataSource::TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) {}

TableViewCell* TableViewDataSource::cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) { return nullptr; }

BoomListView::BoomListView() {}

BoomListView::~BoomListView() {
		CC_SAFE_RELEASE(m_entries);
	}

auto BoomListView::init(cocos2d::CCArray* p0, TableViewCellDelegate* p1, float p2, float p3, int p4, BoomListType p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(BoomListView*, cocos2d::CCArray*, TableViewCellDelegate*, float, float, int, BoomListType, float);
	static auto func = wrapFunction(base::get() + 0x1d400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

bool BoomListView::init(cocos2d::CCArray* entries, BoomListType type, float width, float height) {
		return this->init(entries, nullptr, height, width, 0, type, 0.0f);
	}

void BoomListView::draw() {}

auto BoomListView::setupList(float p0) -> decltype(setupList(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&BoomListView::setupList), this);
	using FunctionType = decltype(setupList(p0))(*)(BoomListView*, float);
	static auto func = wrapFunction(base::get() + 0x1d5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void BoomListView::TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

auto BoomListView::cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) -> decltype(cellHeightForRowAtIndexPath(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCIndexPath&, TableView*>::func(&BoomListView::cellHeightForRowAtIndexPath), this);
	using FunctionType = decltype(cellHeightForRowAtIndexPath(p0, p1))(*)(BoomListView*, CCIndexPath&, TableView*);
	static auto func = wrapFunction(base::get() + 0x1d650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void BoomListView::didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {}

auto BoomListView::numberOfRowsInSection(unsigned p0, TableView* p1) -> decltype(numberOfRowsInSection(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned, TableView*>::func(&BoomListView::numberOfRowsInSection), this);
	using FunctionType = decltype(numberOfRowsInSection(p0, p1))(*)(BoomListView*, unsigned, TableView*);
	static auto func = wrapFunction(base::get() + 0x1d660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

unsigned int BoomListView::numberOfSectionsInTableView(TableView* p0) { return 1; }

auto BoomListView::cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) -> decltype(cellForRowAtIndexPath(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCIndexPath&, TableView*>::func(&BoomListView::cellForRowAtIndexPath), this);
	using FunctionType = decltype(cellForRowAtIndexPath(p0, p1))(*)(BoomListView*, CCIndexPath&, TableView*);
	static auto func = wrapFunction(base::get() + 0x1d670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) {}

void BoomListView::TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

auto BoomListView::getListCell(char const* p0) -> decltype(getListCell(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&BoomListView::getListCell), this);
	using FunctionType = decltype(getListCell(p0))(*)(BoomListView*, char const*);
	static auto func = wrapFunction(base::get() + 0x1d6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto BoomListView::loadCell(TableViewCell* p0, int p1) -> decltype(loadCell(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int>::func(&BoomListView::loadCell), this);
	using FunctionType = decltype(loadCell(p0, p1))(*)(BoomListView*, TableViewCell*, int);
	static auto func = wrapFunction(base::get() + 0x1d7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::visit() -> decltype(visit()) {
	throw std::runtime_error("BoomScrollLayer::visit not implemented");
}

auto BoomScrollLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("BoomScrollLayer::ccTouchBegan not implemented");
}

auto BoomScrollLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("BoomScrollLayer::ccTouchMoved not implemented");
}

auto BoomScrollLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("BoomScrollLayer::ccTouchEnded not implemented");
}

auto BoomScrollLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("BoomScrollLayer::ccTouchCancelled not implemented");
}

auto BoomScrollLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("BoomScrollLayer::registerWithTouchDispatcher not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerScrollingStarted(BoomScrollLayer* p0) -> decltype(scrollLayerScrollingStarted(p0)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerScrollingStarted not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerScrolledToPage not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerMoved not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerWillScrollToPage not implemented");
}

auto BrowseSmartTemplateLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("BrowseSmartTemplateLayer::keyBackClicked not implemented");
}

auto BrowseSmartTemplateLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	throw std::runtime_error("BrowseSmartTemplateLayer::onBack not implemented");
}

auto BrowseSmartKeyLayer::create(GJSmartTemplate* p0, gd::string p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GJSmartTemplate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x35c240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto BrowseSmartKeyLayer::init(GJSmartTemplate* p0, gd::string p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(BrowseSmartKeyLayer*, GJSmartTemplate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x35c310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto BrowseSmartKeyLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	throw std::runtime_error("BrowseSmartKeyLayer::onBack not implemented");
}

ButtonSprite* ButtonSprite::create(cocos2d::CCSprite* topSprite, int width, bool absolute, float height, const char* texture, float scale) {
		return create(topSprite, width, 0, height, scale, absolute, texture, true);
	}

ButtonSprite* ButtonSprite::create(const char* caption, int width, bool absolute, const char* font, const char* texture, float height, float scale) {
		return create(caption, width, 0, scale, absolute, font, texture, height);
	}

ButtonSprite* ButtonSprite::create(char const* caption) {
		return ButtonSprite::create(caption, 0, 0, "goldFont.fnt", "GJ_button_01.png", .0f, 1.f);
	}

ButtonSprite* ButtonSprite::create(char const* caption, const char* font, const char* texture) {
		return ButtonSprite::create(caption, 0, 0, font, texture, .0f, 1.f);
	}

ButtonSprite* ButtonSprite::create(char const* caption, const char* font, const char* texture, float scale) {
		return ButtonSprite::create(caption, 0, 0, font, texture, .0f, scale);
	}

auto ButtonSprite::create(char const* p0, int p1, int p2, float p3, bool p4, char const* p5, char const* p6, float p7) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7))(*)(char const*, int, int, float, bool, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x1feb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7);
}

auto ButtonSprite::create(cocos2d::CCSprite* topSprite, int width, int unused, float height, float p4, bool p5, char const* bgSprite, bool noScaleSpriteForBG) -> decltype(create(topSprite, width, unused, height, p4, p5, bgSprite, noScaleSpriteForBG)) {
	using FunctionType = decltype(create(topSprite, width, unused, height, p4, p5, bgSprite, noScaleSpriteForBG))(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x1fb90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(topSprite, width, unused, height, p4, p5, bgSprite, noScaleSpriteForBG);
}

auto ButtonSprite::init(char const* p0, int p1, int p2, float p3, bool p4, char const* p5, char const* p6, float p7) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7))(*)(ButtonSprite*, char const*, int, int, float, bool, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x1ff80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto ButtonSprite::init(cocos2d::CCSprite* topSprite, int width, int unused, float scale, float height, bool unkBool, char const* bgSprite, bool useNormalCCSpriteForBG) -> decltype(init(topSprite, width, unused, scale, height, unkBool, bgSprite, useNormalCCSpriteForBG)) {
	using FunctionType = decltype(init(topSprite, width, unused, scale, height, unkBool, bgSprite, useNormalCCSpriteForBG))(*)(ButtonSprite*, cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x1fc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, topSprite, width, unused, scale, height, unkBool, bgSprite, useNormalCCSpriteForBG);
}

auto ButtonSprite::setColor(cocos2d::ccColor3B p0) -> decltype(setColor(p0)) {
	using FunctionType = decltype(setColor(p0))(*)(ButtonSprite*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x20b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ButtonSprite::setString(char const* p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(ButtonSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x20770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ButtonSprite::updateBGImage(char const* p0) -> decltype(updateBGImage(p0)) {
	using FunctionType = decltype(updateBGImage(p0))(*)(ButtonSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x20230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ButtonSprite::updateSpriteBGSize() -> decltype(updateSpriteBGSize()) {
	using FunctionType = decltype(updateSpriteBGSize())(*)(ButtonSprite*);
	static auto func = wrapFunction(base::get() + 0x20340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CameraTriggerGameObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3b2aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto CameraTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("CameraTriggerGameObject::triggerObject not implemented");
}

auto CameraTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("CameraTriggerGameObject::customObjectSetup not implemented");
}

auto CameraTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("CameraTriggerGameObject::getSaveString not implemented");
}

auto CCAlertCircle::init() -> decltype(init()) {
	throw std::runtime_error("CCAlertCircle::init not implemented");
}

auto CCAlertCircle::draw() -> decltype(draw()) {
	throw std::runtime_error("CCAlertCircle::draw not implemented");
}

auto CCBlockLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::init), this);
	using FunctionType = decltype(init())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x22f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::draw), this);
	using FunctionType = decltype(draw())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x230a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("CCBlockLayer::ccTouchBegan not implemented");
}

auto CCBlockLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("CCBlockLayer::ccTouchMoved not implemented");
}

auto CCBlockLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("CCBlockLayer::ccTouchEnded not implemented");
}

auto CCBlockLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("CCBlockLayer::ccTouchCancelled not implemented");
}

auto CCBlockLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("CCBlockLayer::registerWithTouchDispatcher not implemented");
}

auto CCBlockLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("CCBlockLayer::keyBackClicked not implemented");
}

auto CCBlockLayer::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("CCBlockLayer::customSetup not implemented");
}

auto CCBlockLayer::enterLayer() -> decltype(enterLayer()) {
	throw std::runtime_error("CCBlockLayer::enterLayer not implemented");
}

auto CCBlockLayer::exitLayer() -> decltype(exitLayer()) {
	throw std::runtime_error("CCBlockLayer::exitLayer not implemented");
}

auto CCBlockLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	throw std::runtime_error("CCBlockLayer::showLayer not implemented");
}

auto CCBlockLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	throw std::runtime_error("CCBlockLayer::hideLayer not implemented");
}

auto CCBlockLayer::layerVisible() -> decltype(layerVisible()) {
	throw std::runtime_error("CCBlockLayer::layerVisible not implemented");
}

auto CCBlockLayer::layerHidden() -> decltype(layerHidden()) {
	throw std::runtime_error("CCBlockLayer::layerHidden not implemented");
}

auto CCBlockLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	throw std::runtime_error("CCBlockLayer::enterAnimFinished not implemented");
}

auto CCBlockLayer::disableUI() -> decltype(disableUI()) {
	throw std::runtime_error("CCBlockLayer::disableUI not implemented");
}

auto CCBlockLayer::enableUI() -> decltype(enableUI()) {
	throw std::runtime_error("CCBlockLayer::enableUI not implemented");
}

auto CCCircleWave::create(float p0, float p1, float p2, bool p3, bool p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(float, float, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x23220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto CCCircleWave::followObject(cocos2d::CCNode* p0, bool p1) -> decltype(followObject(p0, p1)) {
	using FunctionType = decltype(followObject(p0, p1))(*)(CCCircleWave*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x23540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CCCircleWave::init(float p0, float p1, float p2, bool p3, bool p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(CCCircleWave*, float, float, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x232f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto CCCircleWave::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	throw std::runtime_error("CCCircleWave::setPosition not implemented");
}

auto CCCircleWave::removeMeAndCleanup() -> decltype(removeMeAndCleanup()) {
	throw std::runtime_error("CCCircleWave::removeMeAndCleanup not implemented");
}

auto CCCircleWave::draw() -> decltype(draw()) {
	throw std::runtime_error("CCCircleWave::draw not implemented");
}

auto CCCircleWave::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&CCCircleWave::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(p0, p1))(*)(CCCircleWave*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x235b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCCircleWaveDelegate::circleWaveWillBeRemoved(CCCircleWave* p0) -> decltype(circleWaveWillBeRemoved(p0)) {
	throw std::runtime_error("CCCircleWaveDelegate::circleWaveWillBeRemoved not implemented");
}

auto CCContentLayer::create(cocos2d::ccColor4B const& p0, float p1, float p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(cocos2d::ccColor4B const&, float, float);
	static auto func = wrapFunction(base::get() + 0x239c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto CCContentLayer::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&CCContentLayer::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(CCContentLayer*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x23b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCCountdown::init() -> decltype(init()) {
	throw std::runtime_error("CCCountdown::init not implemented");
}

auto CCCountdown::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("CCCountdown::setOpacity not implemented");
}

auto CCCounterLabel::create(int p0, char const* p1, FormatterType p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(int, char const*, FormatterType);
	static auto func = wrapFunction(base::get() + 0x23d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto CCCounterLabel::init(int p0, char const* p1, FormatterType p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(CCCounterLabel*, int, char const*, FormatterType);
	static auto func = wrapFunction(base::get() + 0x23db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CCCounterLabel::setTargetCount(int p0) -> decltype(setTargetCount(p0)) {
	using FunctionType = decltype(setTargetCount(p0))(*)(CCCounterLabel*, int);
	static auto func = wrapFunction(base::get() + 0x23e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCLightFlash::init() -> decltype(init()) {
	throw std::runtime_error("CCLightFlash::init not implemented");
}

auto CCLightStrip::draw() -> decltype(draw()) {
	throw std::runtime_error("CCLightStrip::draw not implemented");
}

auto CCLightStrip::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	throw std::runtime_error("CCLightStrip::updateTweenAction not implemented");
}

CCMenuItemSpriteExtra::~CCMenuItemSpriteExtra() {}

CCMenuItemSpriteExtra::CCMenuItemSpriteExtra() {
		m_scaleMultiplier = 1.0f;
		m_baseScale = 1.0f;
		m_animationEnabled = true;
		m_colorEnabled = false;
		m_unknown1 = 0.0f;
		m_colorDip = 0.0f;
		m_animationType = MenuAnimationType::Scale;
		m_unknown4 = 0;
	}

auto CCMenuItemSpriteExtra::create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x25830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

CCMenuItemSpriteExtra* CCMenuItemSpriteExtra::create(cocos2d::CCNode* sprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) {
		return CCMenuItemSpriteExtra::create(sprite, nullptr, target, callback);
	}

auto CCMenuItemSpriteExtra::init(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(CCMenuItemSpriteExtra*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x258f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto CCMenuItemSpriteExtra::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::activate), this);
	using FunctionType = decltype(activate())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x259d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemSpriteExtra::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::selected), this);
	using FunctionType = decltype(selected())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x25aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemSpriteExtra::unselected() -> decltype(unselected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::unselected), this);
	using FunctionType = decltype(unselected())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x25c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

CCMenuItemToggler::CCMenuItemToggler() {}

auto CCMenuItemToggler::create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x25e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

CCMenuItemToggler* CCMenuItemToggler::createWithSize(const char* spr1, const char* spr2, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
		auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName(spr1);
		auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName(spr2);

		sprOff->setScale(scale);
		sprOn->setScale(scale);

		return create(sprOff, sprOn, target, callback);
	}

CCMenuItemToggler* CCMenuItemToggler::createWithStandardSprites(cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
		auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
		auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");

		sprOff->setScale(scale);
		sprOn->setScale(scale);

		return create(sprOff, sprOn, target, callback);
	}

auto CCMenuItemToggler::init(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(CCMenuItemToggler*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x25f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

void CCMenuItemToggler::setSizeMult(float mult) {
		m_offButton->setSizeMult(mult);
		m_onButton->setSizeMult(mult);

		this->toggle(this->m_toggled);
	}

auto CCMenuItemToggler::toggle(bool p0) -> decltype(toggle(p0)) {
	using FunctionType = decltype(toggle(p0))(*)(CCMenuItemToggler*, bool);
	static auto func = wrapFunction(base::get() + 0x261e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

bool CCMenuItemToggler::isToggled() {
		return m_toggled;
	}

bool CCMenuItemToggler::isOn() {
		return m_toggled;
	}

void CCMenuItemToggler::setClickable(bool on) {
		m_notClickable = !on;
	}

void CCMenuItemToggler::toggleWithCallback(bool on) {
		this->activate();
		this->toggle(on);
	}

auto CCMenuItemToggler::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::activate), this);
	using FunctionType = decltype(activate())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x26100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemToggler::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::selected), this);
	using FunctionType = decltype(selected())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x260d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemToggler::unselected() -> decltype(unselected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::unselected), this);
	using FunctionType = decltype(unselected())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x26130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemToggler::setEnabled(bool p0) -> decltype(setEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCMenuItemToggler::setEnabled), this);
	using FunctionType = decltype(setEnabled(p0))(*)(CCMenuItemToggler*, bool);
	static auto func = wrapFunction(base::get() + 0x26160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCMoveCNode::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x1dedf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto CCNodeContainer::init() -> decltype(init()) {
	throw std::runtime_error("CCNodeContainer::init not implemented");
}

auto CCNodeContainer::visit() -> decltype(visit()) {
	throw std::runtime_error("CCNodeContainer::visit not implemented");
}

auto CCPartAnimSprite::setColor(cocos2d::ccColor3B p0) -> decltype(setColor(p0)) {
	using FunctionType = decltype(setColor(p0))(*)(CCPartAnimSprite*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x27270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCPartAnimSprite::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	throw std::runtime_error("CCPartAnimSprite::setScaleX not implemented");
}

auto CCPartAnimSprite::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	throw std::runtime_error("CCPartAnimSprite::setScaleY not implemented");
}

auto CCPartAnimSprite::setScale(float p0) -> decltype(setScale(p0)) {
	throw std::runtime_error("CCPartAnimSprite::setScale not implemented");
}

auto CCPartAnimSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("CCPartAnimSprite::setOpacity not implemented");
}

auto CCPartAnimSprite::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	throw std::runtime_error("CCPartAnimSprite::setBlendFunc not implemented");
}

auto CCPartAnimSprite::setDisplayFrame(cocos2d::CCSpriteFrame* p0) -> decltype(setDisplayFrame(p0)) {
	throw std::runtime_error("CCPartAnimSprite::setDisplayFrame not implemented");
}

auto CCPartAnimSprite::isFrameDisplayed(cocos2d::CCSpriteFrame* p0) -> decltype(isFrameDisplayed(p0)) {
	throw std::runtime_error("CCPartAnimSprite::isFrameDisplayed not implemented");
}

auto CCPartAnimSprite::displayFrame() -> decltype(displayFrame()) {
	throw std::runtime_error("CCPartAnimSprite::displayFrame not implemented");
}

CCScrollLayerExt::CCScrollLayerExt(cocos2d::CCRect p0) : CCScrollLayerExt(geode::CutoffConstructor, sizeof(CCScrollLayerExt)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	CCScrollLayerExt::~CCScrollLayerExt();
	using FunctionType = void(*)(CCScrollLayerExt*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x276e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCScrollLayerExt::moveToTop() -> decltype(moveToTop()) {
	using FunctionType = decltype(moveToTop())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x27b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCScrollLayerExt::moveToTopWithOffset(float p0) -> decltype(moveToTopWithOffset(p0)) {
	using FunctionType = decltype(moveToTopWithOffset(p0))(*)(CCScrollLayerExt*, float);
	static auto func = wrapFunction(base::get() + 0x27ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCScrollLayerExt::scrollLayer(float p0) -> decltype(scrollLayer(p0)) {
	using FunctionType = decltype(scrollLayer(p0))(*)(CCScrollLayerExt*, float);
	static auto func = wrapFunction(base::get() + 0x28550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCScrollLayerExt::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::visit), this);
	using FunctionType = decltype(visit())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x28600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCScrollLayerExt::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x280d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x28410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x281c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x283e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x280a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCScrollLayerExt::preVisitWithClippingRect(cocos2d::CCRect p0) -> decltype(preVisitWithClippingRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect>::func(&CCScrollLayerExt::preVisitWithClippingRect), this);
	using FunctionType = decltype(preVisitWithClippingRect(p0))(*)(CCScrollLayerExt*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x286d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCScrollLayerExt::postVisit() -> decltype(postVisit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::postVisit), this);
	using FunctionType = decltype(postVisit())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x28760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCScrollLayerExtDelegate::scrllViewWillBeginDecelerating(CCScrollLayerExt* p0) -> decltype(scrllViewWillBeginDecelerating(p0)) {
	throw std::runtime_error("CCScrollLayerExtDelegate::scrllViewWillBeginDecelerating not implemented");
}

auto CCScrollLayerExtDelegate::scrollViewDidEndDecelerating(CCScrollLayerExt* p0) -> decltype(scrollViewDidEndDecelerating(p0)) {
	throw std::runtime_error("CCScrollLayerExtDelegate::scrollViewDidEndDecelerating not implemented");
}

auto CCScrollLayerExtDelegate::scrollViewTouchMoving(CCScrollLayerExt* p0) -> decltype(scrollViewTouchMoving(p0)) {
	throw std::runtime_error("CCScrollLayerExtDelegate::scrollViewTouchMoving not implemented");
}

auto CCScrollLayerExtDelegate::scrollViewDidEndMoving(CCScrollLayerExt* p0) -> decltype(scrollViewDidEndMoving(p0)) {
	throw std::runtime_error("CCScrollLayerExtDelegate::scrollViewDidEndMoving not implemented");
}

auto CCScrollLayerExtDelegate::scrollViewTouchBegin(CCScrollLayerExt* p0) -> decltype(scrollViewTouchBegin(p0)) {
	throw std::runtime_error("CCScrollLayerExtDelegate::scrollViewTouchBegin not implemented");
}

auto CCScrollLayerExtDelegate::scrollViewTouchEnd(CCScrollLayerExt* p0) -> decltype(scrollViewTouchEnd(p0)) {
	throw std::runtime_error("CCScrollLayerExtDelegate::scrollViewTouchEnd not implemented");
}

auto CCSpriteCOpacity::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("CCSpriteCOpacity::setOpacity not implemented");
}

auto CCSpriteWithHue::draw() -> decltype(draw()) {
	throw std::runtime_error("CCSpriteWithHue::draw not implemented");
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	throw std::runtime_error("CCSpriteWithHue::initWithTexture not implemented");
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) -> decltype(initWithTexture(p0, p1)) {
	throw std::runtime_error("CCSpriteWithHue::initWithTexture not implemented");
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) -> decltype(initWithTexture(p0, p1, p2)) {
	throw std::runtime_error("CCSpriteWithHue::initWithTexture not implemented");
}

auto CCSpriteWithHue::initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(initWithSpriteFrame(p0)) {
	throw std::runtime_error("CCSpriteWithHue::initWithSpriteFrame not implemented");
}

auto CCSpriteWithHue::getShaderName() -> decltype(getShaderName()) {
	throw std::runtime_error("CCSpriteWithHue::getShaderName not implemented");
}

auto CCSpriteWithHue::shaderBody() -> decltype(shaderBody()) {
	throw std::runtime_error("CCSpriteWithHue::shaderBody not implemented");
}

auto CCSpriteWithHue::updateColor() -> decltype(updateColor()) {
	throw std::runtime_error("CCSpriteWithHue::updateColor not implemented");
}

auto CCSpriteGrayscale::createWithSpriteFrameName(gd::string const& p0) -> decltype(createWithSpriteFrameName(p0)) {
	using FunctionType = decltype(createWithSpriteFrameName(p0))(*)(gd::string const&);
	static auto func = wrapFunction(base::get() + 0x29c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto CCSpriteGrayscale::getShaderName() -> decltype(getShaderName()) {
	throw std::runtime_error("CCSpriteGrayscale::getShaderName not implemented");
}

auto CCSpriteGrayscale::shaderBody() -> decltype(shaderBody()) {
	throw std::runtime_error("CCSpriteGrayscale::shaderBody not implemented");
}

auto CCSpritePart::setVisible(bool p0) -> decltype(setVisible(p0)) {
	throw std::runtime_error("CCSpritePart::setVisible not implemented");
}

CCTextInputNode::CCTextInputNode() {
		m_numberInput = false;
		m_caption = "";
		m_unknown1 = 0;
		m_selected = false;
		m_unknown2 = false;
		m_fontValue1 = -0.5f;
		m_fontValue2 = 8.0f;
		m_isChatFont = false;
		m_allowedChars = "";
		m_maxLabelWidth = 0.0f;
		m_maxLabelScale = 0.0f;
		m_placeholderScale = 0.0f;
		m_placeholderColor = cocos2d::ccc3(0, 0, 0);
		m_textColor = cocos2d::ccc3(0, 0, 0);
		m_cursor = nullptr;
		m_textField = nullptr;
		m_delegate = nullptr;
		m_maxLabelLength = 0;
		m_placeholderLabel = nullptr;
		m_filterSwearWords = false;
		m_usePasswordChar = false;
		m_forceOffset = false;
		m_textArea = nullptr;
	}

auto CCTextInputNode::create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(float, float, char const*, char const*, int, char const*);
	static auto func = wrapFunction(base::get() + 0x2e440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

CCTextInputNode* CCTextInputNode::create(float width, float height, char const* placeholder, char const* fontPath) {
		return CCTextInputNode::create(width, height, placeholder, 0x18, fontPath);
	}

CCTextInputNode* CCTextInputNode::create(float width, float height, char const* placeholder, int fontSize, char const* fontPath) {
		return CCTextInputNode::create(width, height, placeholder, "Thonburi", fontSize, fontPath);
	}

void CCTextInputNode::setDelegate(TextInputDelegate* delegate) {
		m_delegate = delegate;
	}

void CCTextInputNode::setMaxLabelScale(float v) {
		m_maxLabelScale = v;
		this->refreshLabel();
	}

void CCTextInputNode::setMaxLabelWidth(float v) {
		m_maxLabelWidth = v;
		this->refreshLabel();
	}

void CCTextInputNode::setMaxLabelLength(int v) {
		m_maxLabelLength = v;
		this->refreshLabel();
	}

void CCTextInputNode::setLabelPlaceholderScale(float v) {
		m_placeholderScale = v;
		this->refreshLabel();
	}

void CCTextInputNode::setLabelPlaceholderColor(cocos2d::ccColor3B color) {
		m_placeholderColor = color;
		this->refreshLabel();
	}

void CCTextInputNode::setAllowedChars(gd::string filter) {
        	m_allowedChars = filter;
    	}

cocos2d::CCLabelBMFont* CCTextInputNode::getPlaceholderLabel() {
        	return m_placeholderLabel;
    	}

auto CCTextInputNode::addTextArea(TextArea* p0) -> decltype(addTextArea(p0)) {
	using FunctionType = decltype(addTextArea(p0))(*)(CCTextInputNode*, TextArea*);
	static auto func = wrapFunction(base::get() + 0x2e6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

gd::string CCTextInputNode::getString() {
		return m_textField->getString();
	}

auto CCTextInputNode::init(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(CCTextInputNode*, float, float, char const*, char const*, int, char const*);
	static auto func = wrapFunction(base::get() + 0x2e500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto CCTextInputNode::refreshLabel() -> decltype(refreshLabel()) {
	using FunctionType = decltype(refreshLabel())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2ede0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void CCTextInputNode::setLabelNormalColor(cocos2d::ccColor3B color) {
        	m_textColor = color;
        	this->refreshLabel();
    	}

auto CCTextInputNode::setString(gd::string p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(CCTextInputNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x2e9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::updateCursorPosition(cocos2d::CCPoint p0, cocos2d::CCRect p1) -> decltype(updateCursorPosition(p0, p1)) {
	using FunctionType = decltype(updateCursorPosition(p0, p1))(*)(CCTextInputNode*, cocos2d::CCPoint, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x2ff50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CCTextInputNode::updateDefaultFontValues(gd::string p0) -> decltype(updateDefaultFontValues(p0)) {
	using FunctionType = decltype(updateDefaultFontValues(p0))(*)(CCTextInputNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x2e7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::updateLabel(gd::string p0) -> decltype(updateLabel(p0)) {
	using FunctionType = decltype(updateLabel(p0))(*)(CCTextInputNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x2eac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::visit), this);
	using FunctionType = decltype(visit())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2e930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCTextInputNode::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x304f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void CCTextInputNode::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void CCTextInputNode::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

void CCTextInputNode::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) {}

auto CCTextInputNode::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x306d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::textChanged() -> decltype(textChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::textChanged), this);
	using FunctionType = decltype(textChanged())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2f630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::onClickTrackNode(bool p0) -> decltype(onClickTrackNode(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCTextInputNode::onClickTrackNode), this);
	using FunctionType = decltype(onClickTrackNode(p0))(*)(CCTextInputNode*, bool);
	static auto func = wrapFunction(base::get() + 0x2f600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::keyboardWillShow(cocos2d::CCIMEKeyboardNotificationInfo& p0) -> decltype(keyboardWillShow(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCIMEKeyboardNotificationInfo&>::func(&CCTextInputNode::keyboardWillShow), this);
	using FunctionType = decltype(keyboardWillShow(p0))(*)(CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
	static auto func = wrapFunction(base::get() + 0x2f4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::keyboardWillHide(cocos2d::CCIMEKeyboardNotificationInfo& p0) -> decltype(keyboardWillHide(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCIMEKeyboardNotificationInfo&>::func(&CCTextInputNode::keyboardWillHide), this);
	using FunctionType = decltype(keyboardWillHide(p0))(*)(CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
	static auto func = wrapFunction(base::get() + 0x2f5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::onTextFieldInsertText(cocos2d::CCTextFieldTTF* pSender, char const* text, int nLen, cocos2d::enumKeyCodes keyCodes) -> decltype(onTextFieldInsertText(pSender, text, nLen, keyCodes)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*, char const*, int, cocos2d::enumKeyCodes>::func(&CCTextInputNode::onTextFieldInsertText), this);
	using FunctionType = decltype(onTextFieldInsertText(pSender, text, nLen, keyCodes))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*, char const*, int, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x2f6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, pSender, text, nLen, keyCodes);
}

auto CCTextInputNode::onTextFieldAttachWithIME(cocos2d::CCTextFieldTTF* tField) -> decltype(onTextFieldAttachWithIME(tField)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*>::func(&CCTextInputNode::onTextFieldAttachWithIME), this);
	using FunctionType = decltype(onTextFieldAttachWithIME(tField))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*);
	static auto func = wrapFunction(base::get() + 0x2fa30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, tField);
}

auto CCTextInputNode::onTextFieldDetachWithIME(cocos2d::CCTextFieldTTF* tField) -> decltype(onTextFieldDetachWithIME(tField)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*>::func(&CCTextInputNode::onTextFieldDetachWithIME), this);
	using FunctionType = decltype(onTextFieldDetachWithIME(tField))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*);
	static auto func = wrapFunction(base::get() + 0x2fd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, tField);
}

auto GJChallengeDelegate::challengeStatusFinished() -> decltype(challengeStatusFinished()) {
	throw std::runtime_error("GJChallengeDelegate::challengeStatusFinished not implemented");
}

auto GJChallengeDelegate::challengeStatusFailed() -> decltype(challengeStatusFailed()) {
	throw std::runtime_error("GJChallengeDelegate::challengeStatusFailed not implemented");
}

auto CurrencyRewardDelegate::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	throw std::runtime_error("CurrencyRewardDelegate::currencyWillExit not implemented");
}

auto ChallengesPage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x5c4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ChallengesPage::createChallengeNode(int number, bool skipAnimation, float animLength, bool isNew) -> decltype(createChallengeNode(number, skipAnimation, animLength, isNew)) {
	using FunctionType = decltype(createChallengeNode(number, skipAnimation, animLength, isNew))(*)(ChallengesPage*, int, bool, float, bool);
	static auto func = wrapFunction(base::get() + 0x5d190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, number, skipAnimation, animLength, isNew);
}

auto ChallengesPage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ChallengesPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5d830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ChallengesPage::updateTimers(float p0) -> decltype(updateTimers(p0)) {
	using FunctionType = decltype(updateTimers(p0))(*)(ChallengesPage*, float);
	static auto func = wrapFunction(base::get() + 0x5d450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ChallengesPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::init), this);
	using FunctionType = decltype(init())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x5c560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("ChallengesPage::registerWithTouchDispatcher not implemented");
}

auto ChallengesPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ChallengesPage::keyBackClicked not implemented");
}

auto ChallengesPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::show), this);
	using FunctionType = decltype(show())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x5d6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("ChallengesPage::FLAlert_Clicked not implemented");
}

auto ChallengesPage::challengeStatusFinished() -> decltype(challengeStatusFinished()) {
	throw std::runtime_error("ChallengesPage::challengeStatusFinished not implemented");
}

auto ChallengesPage::challengeStatusFailed() -> decltype(challengeStatusFailed()) {
	throw std::runtime_error("ChallengesPage::challengeStatusFailed not implemented");
}

auto ChallengesPage::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	throw std::runtime_error("ChallengesPage::currencyWillExit not implemented");
}

auto GJChallengeItem::create(GJChallengeType p0, int p1, int p2, int p3, gd::string p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(GJChallengeType, int, int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x182900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto GJChallengeItem::createFromString(gd::string p0) -> decltype(createFromString(p0)) {
	using FunctionType = decltype(createFromString(p0))(*)(GJChallengeItem*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1827c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJChallengeItem::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(GJChallengeItem*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x182ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJChallengeItem::init(GJChallengeType p0, int p1, int p2, int p3, gd::string p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(GJChallengeItem*, GJChallengeType, int, int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x1829d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto GJChallengeItem::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	throw std::runtime_error("GJChallengeItem::encodeWithCoder not implemented");
}

auto GJChallengeItem::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJChallengeItem::canEncode not implemented");
}

auto ChallengeNode::create(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) -> decltype(create(challengeItem, challengesPage, isNew)) {
	using FunctionType = decltype(create(challengeItem, challengesPage, isNew))(*)(GJChallengeItem*, ChallengesPage*, bool);
	static auto func = wrapFunction(base::get() + 0x5da50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(challengeItem, challengesPage, isNew);
}

auto ChallengeNode::init(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) -> decltype(init(challengeItem, challengesPage, isNew)) {
	using FunctionType = decltype(init(challengeItem, challengesPage, isNew))(*)(ChallengeNode*, GJChallengeItem*, ChallengesPage*, bool);
	static auto func = wrapFunction(base::get() + 0x5db30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, challengeItem, challengesPage, isNew);
}

auto CharacterColorDelegate::playerColorChanged() -> decltype(playerColorChanged()) {
	throw std::runtime_error("CharacterColorDelegate::playerColorChanged not implemented");
}

auto CharacterColorDelegate::showUnlockPopup(int p0, UnlockType p1) -> decltype(showUnlockPopup(p0, p1)) {
	throw std::runtime_error("CharacterColorDelegate::showUnlockPopup not implemented");
}

auto CharacterColorPage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x5e9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto CharacterColorPage::activeColorForMode(int mode) -> decltype(activeColorForMode(mode)) {
	using FunctionType = decltype(activeColorForMode(mode))(*)(CharacterColorPage*, int);
	static auto func = wrapFunction(base::get() + 0x5fa50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, mode);
}

auto CharacterColorPage::createColorMenu() -> decltype(createColorMenu()) {
	using FunctionType = decltype(createColorMenu())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x5f630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CharacterColorPage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x608a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CharacterColorPage::onMode(cocos2d::CCObject* sender) -> decltype(onMode(sender)) {
	using FunctionType = decltype(onMode(sender))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5fab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CharacterColorPage::onPlayerColor(cocos2d::CCObject* sender) -> decltype(onPlayerColor(sender)) {
	using FunctionType = decltype(onPlayerColor(sender))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x60000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CharacterColorPage::toggleGlow(cocos2d::CCObject* p0) -> decltype(toggleGlow(p0)) {
	using FunctionType = decltype(toggleGlow(p0))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::toggleShip(cocos2d::CCObject* p0) -> decltype(toggleShip(p0)) {
	using FunctionType = decltype(toggleShip(p0))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::updateColorMode(int p0) -> decltype(updateColorMode(p0)) {
	using FunctionType = decltype(updateColorMode(p0))(*)(CharacterColorPage*, int);
	static auto func = wrapFunction(base::get() + 0x5fc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::updateIconColors() -> decltype(updateIconColors()) {
	using FunctionType = decltype(updateIconColors())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x60700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CharacterColorPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::init), this);
	using FunctionType = decltype(init())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x5ea50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CharacterColorPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("CharacterColorPage::registerWithTouchDispatcher not implemented");
}

auto CharacterColorPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("CharacterColorPage::keyBackClicked not implemented");
}

auto CharacterColorPage::show() -> decltype(show()) {
	throw std::runtime_error("CharacterColorPage::show not implemented");
}

auto CheckpointGameObject::init() -> decltype(init()) {
	throw std::runtime_error("CheckpointGameObject::init not implemented");
}

auto CheckpointGameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	throw std::runtime_error("CheckpointGameObject::setupCustomSprites not implemented");
}

auto CheckpointGameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("CheckpointGameObject::resetObject not implemented");
}

auto CheckpointGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("CheckpointGameObject::triggerObject not implemented");
}

auto CheckpointGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("CheckpointGameObject::customObjectSetup not implemented");
}

auto CheckpointGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("CheckpointGameObject::getSaveString not implemented");
}

auto CheckpointGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	throw std::runtime_error("CheckpointGameObject::triggerActivated not implemented");
}

auto CheckpointGameObject::restoreObject() -> decltype(restoreObject()) {
	throw std::runtime_error("CheckpointGameObject::restoreObject not implemented");
}

auto CheckpointGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	throw std::runtime_error("CheckpointGameObject::updateSyncedAnimation not implemented");
}

auto CheckpointObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2eb9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto CheckpointObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CheckpointObject::init), this);
	using FunctionType = decltype(init())(*)(CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0x52e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CollisionBlockPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x60ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto CollisionBlockPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(CollisionBlockPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x60b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CollisionBlockPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("CollisionBlockPopup::keyBackClicked not implemented");
}

auto CollisionBlockPopup::show() -> decltype(show()) {
	throw std::runtime_error("CollisionBlockPopup::show not implemented");
}

auto CollisionBlockPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CollisionBlockPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(CollisionBlockPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x61660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CollisionBlockPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("CollisionBlockPopup::textChanged not implemented");
}

auto CollisionBlockPopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("CollisionBlockPopup::textInputShouldOffset not implemented");
}

auto CollisionBlockPopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("CollisionBlockPopup::textInputReturn not implemented");
}

auto ColorAction::isInUse() -> decltype(isInUse()) {
	using FunctionType = decltype(isInUse())(*)(ColorAction*);
	static auto func = wrapFunction(base::get() + 0x1d8fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ColorAction::loadFromState(CAState& p0) -> decltype(loadFromState(p0)) {
	using FunctionType = decltype(loadFromState(p0))(*)(ColorAction*, CAState&);
	static auto func = wrapFunction(base::get() + 0x1d9090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorAction::saveToState(CAState& p0) -> decltype(saveToState(p0)) {
	using FunctionType = decltype(saveToState(p0))(*)(ColorAction*, CAState&);
	static auto func = wrapFunction(base::get() + 0x1d8ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorAction::setupFromMap(gd::map<gd::string, gd::string>& p0) -> decltype(setupFromMap(p0)) {
	using FunctionType = decltype(setupFromMap(p0))(*)(ColorAction*, gd::map<gd::string, gd::string>&);
	static auto func = wrapFunction(base::get() + 0x1d9a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorAction::setupFromString(gd::string p0) -> decltype(setupFromString(p0)) {
	using FunctionType = decltype(setupFromString(p0))(*)(ColorAction*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1d9950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorActionSprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x1d8bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ColorActionSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorActionSprite::init), this);
	using FunctionType = decltype(init())(*)(ColorActionSprite*);
	static auto func = wrapFunction(base::get() + 0x1d8cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorChannelSprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x1d85c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ColorChannelSprite::updateBlending(bool p0) -> decltype(updateBlending(p0)) {
	using FunctionType = decltype(updateBlending(p0))(*)(ColorChannelSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x1d8990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorChannelSprite::updateCopyLabel(int p0, bool p1) -> decltype(updateCopyLabel(p0, p1)) {
	using FunctionType = decltype(updateCopyLabel(p0, p1))(*)(ColorChannelSprite*, int, bool);
	static auto func = wrapFunction(base::get() + 0x1d86c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ColorChannelSprite::updateOpacity(float p0) -> decltype(updateOpacity(p0)) {
	using FunctionType = decltype(updateOpacity(p0))(*)(ColorChannelSprite*, float);
	static auto func = wrapFunction(base::get() + 0x1d8840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorChannelSprite::updateValues(ColorAction* p0) -> decltype(updateValues(p0)) {
	using FunctionType = decltype(updateValues(p0))(*)(ColorChannelSprite*, ColorAction*);
	static auto func = wrapFunction(base::get() + 0x1d8a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorChannelSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorChannelSprite::init), this);
	using FunctionType = decltype(init())(*)(ColorChannelSprite*);
	static auto func = wrapFunction(base::get() + 0x1d86a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectDelegate::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	throw std::runtime_error("ColorSelectDelegate::colorSelectClosed not implemented");
}

auto ColorSelectLiveOverlay::create(ColorAction* p0, ColorAction* p1, EffectGameObject* p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(ColorAction*, ColorAction*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x61b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto ColorSelectLiveOverlay::init(ColorAction* p0, ColorAction* p1, EffectGameObject* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(ColorSelectLiveOverlay*, ColorAction*, ColorAction*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x61bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ColorSelectLiveOverlay::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ColorSelectLiveOverlay::keyBackClicked not implemented");
}

auto ColorSelectLiveOverlay::show() -> decltype(show()) {
	throw std::runtime_error("ColorSelectLiveOverlay::show not implemented");
}

auto ConfigureValuePopupDelegate::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("ConfigureValuePopupDelegate::valuePopupClosed not implemented");
}

auto SliderDelegate::sliderBegan(Slider* p0) -> decltype(sliderBegan(p0)) {
	throw std::runtime_error("SliderDelegate::sliderBegan not implemented");
}

auto SliderDelegate::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	throw std::runtime_error("SliderDelegate::sliderEnded not implemented");
}

auto SetupTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1, float p2, float p3, int p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(SetupTriggerPopup*, EffectGameObject*, cocos2d::CCArray*, float, float, int);
	static auto func = wrapFunction(base::get() + 0x36e210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto SetupTriggerPopup::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("SetupTriggerPopup::ccTouchBegan not implemented");
}

auto SetupTriggerPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetupTriggerPopup::keyBackClicked not implemented");
}

auto SetupTriggerPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::show), this);
	using FunctionType = decltype(show())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x61860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::pageChanged() -> decltype(pageChanged()) {
	throw std::runtime_error("SetupTriggerPopup::pageChanged not implemented");
}

auto SetupTriggerPopup::toggleGroup(int p0, bool p1) -> decltype(toggleGroup(p0, p1)) {
	throw std::runtime_error("SetupTriggerPopup::toggleGroup not implemented");
}

auto SetupTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupTriggerPopup::determineStartValues not implemented");
}

auto SetupTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupTriggerPopup::onClose), this);
	using FunctionType = decltype(onClose(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x205870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupTriggerPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetupTriggerPopup::textInputClosed not implemented");
}

auto SetupTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupTriggerPopup::textChanged not implemented");
}

auto SetupTriggerPopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("SetupTriggerPopup::textInputShouldOffset not implemented");
}

auto SetupTriggerPopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("SetupTriggerPopup::textInputReturn not implemented");
}

auto SetupTriggerPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	throw std::runtime_error("SetupTriggerPopup::updateInputValue not implemented");
}

auto SetupTriggerPopup::sliderBegan(Slider* p0) -> decltype(sliderBegan(p0)) {
	throw std::runtime_error("SetupTriggerPopup::sliderBegan not implemented");
}

auto SetupTriggerPopup::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	throw std::runtime_error("SetupTriggerPopup::sliderEnded not implemented");
}

auto SetupTriggerPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	throw std::runtime_error("SetupTriggerPopup::onPlusButton not implemented");
}

auto SetupTriggerPopup::onCustomButton(cocos2d::CCObject* sender) -> decltype(onCustomButton(sender)) {
	throw std::runtime_error("SetupTriggerPopup::onCustomButton not implemented");
}

auto SetupTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	throw std::runtime_error("SetupTriggerPopup::updateDefaultTriggerValues not implemented");
}

auto SetupTriggerPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	throw std::runtime_error("SetupTriggerPopup::updateInputNode not implemented");
}

auto SetupTriggerPopup::updateToggleItem(int p0, bool p1) -> decltype(updateToggleItem(p0, p1)) {
	throw std::runtime_error("SetupTriggerPopup::updateToggleItem not implemented");
}

auto SetupTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupTriggerPopup::valueDidChange not implemented");
}

auto SetupTriggerPopup::getValue(int p0) -> decltype(getValue(p0)) {
	throw std::runtime_error("SetupTriggerPopup::getValue not implemented");
}

auto SetupTriggerPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	throw std::runtime_error("SetupTriggerPopup::triggerValueFromSliderValue not implemented");
}

auto SetupTriggerPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	throw std::runtime_error("SetupTriggerPopup::triggerSliderValueFromValue not implemented");
}

auto SetupTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupTriggerPopup::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("SetupTriggerPopup::valuePopupClosed not implemented");
}

auto GJSpecialColorSelectDelegate::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	throw std::runtime_error("GJSpecialColorSelectDelegate::colorSelectClosed not implemented");
}

auto ColorSelectPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1, ColorAction* p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*);
	static auto func = wrapFunction(base::get() + 0x63a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto ColorSelectPopup::closeColorSelect(cocos2d::CCObject* p0) -> decltype(closeColorSelect(p0)) {
	using FunctionType = decltype(closeColorSelect(p0))(*)(ColorSelectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x66b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorSelectPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1, ColorAction* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(ColorSelectPopup*, EffectGameObject*, cocos2d::CCArray*, ColorAction*);
	static auto func = wrapFunction(base::get() + 0x63ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ColorSelectPopup::show() -> decltype(show()) {
	throw std::runtime_error("ColorSelectPopup::show not implemented");
}

auto ColorSelectPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("ColorSelectPopup::determineStartValues not implemented");
}

auto ColorSelectPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("ColorSelectPopup::textChanged not implemented");
}

auto ColorSelectPopup::colorValueChanged(cocos2d::ccColor3B p0) -> decltype(colorValueChanged(p0)) {
	throw std::runtime_error("ColorSelectPopup::colorValueChanged not implemented");
}

auto ColorSelectPopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	throw std::runtime_error("ColorSelectPopup::colorSelectClosed not implemented");
}

auto ColorSetupDelegate::colorSetupClosed(int p0) -> decltype(colorSetupClosed(p0)) {
	throw std::runtime_error("ColorSetupDelegate::colorSetupClosed not implemented");
}

void LikeItemDelegate::likedItem(LikeItemType p0, int p1, bool p2) {}

auto CommentCell::loadFromComment(GJComment* p0) -> decltype(loadFromComment(p0)) {
	using FunctionType = decltype(loadFromComment(p0))(*)(CommentCell*, GJComment*);
	static auto func = wrapFunction(base::get() + 0x84490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CommentCell::onConfirmDelete(cocos2d::CCObject* sender) -> decltype(onConfirmDelete(sender)) {
	using FunctionType = decltype(onConfirmDelete(sender))(*)(CommentCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x862c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CommentCell::onDelete() -> decltype(onDelete()) {
	using FunctionType = decltype(onDelete())(*)(CommentCell*);
	static auto func = wrapFunction(base::get() + 0x86360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CommentCell::onLike(cocos2d::CCObject* sender) -> decltype(onLike(sender)) {
	using FunctionType = decltype(onLike(sender))(*)(CommentCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x86110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CommentCell::updateBGColor(int p0) -> decltype(updateBGColor(p0)) {
	using FunctionType = decltype(updateBGColor(p0))(*)(CommentCell*, int);
	static auto func = wrapFunction(base::get() + 0x86090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CommentCell::updateLabelValues() -> decltype(updateLabelValues()) {
	using FunctionType = decltype(updateLabelValues())(*)(CommentCell*);
	static auto func = wrapFunction(base::get() + 0x86240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CommentCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommentCell::init), this);
	using FunctionType = decltype(init())(*)(CommentCell*);
	static auto func = wrapFunction(base::get() + 0x84460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommentCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommentCell::draw), this);
	using FunctionType = decltype(draw())(*)(CommentCell*);
	static auto func = wrapFunction(base::get() + 0x7d5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommentCell::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<LikeItemType, int, bool>::func(&CommentCell::likedItem), this);
	using FunctionType = decltype(likedItem(p0, p1, p2))(*)(CommentCell*, LikeItemType, int, bool);
	static auto func = wrapFunction(base::get() + 0x861f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CommentCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CommentCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CommentCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x863d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CommentUploadDelegate::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	throw std::runtime_error("CommentUploadDelegate::commentUploadFinished not implemented");
}

auto CommentUploadDelegate::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	throw std::runtime_error("CommentUploadDelegate::commentUploadFailed not implemented");
}

auto CommentUploadDelegate::commentDeleteFailed(int p0, int p1) -> decltype(commentDeleteFailed(p0, p1)) {
	throw std::runtime_error("CommentUploadDelegate::commentDeleteFailed not implemented");
}

auto CommunityCreditNode::create(int p0, int p1, int p2, gd::string p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(int, int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x68850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto CommunityCreditNode::init(int p0, int p1, int p2, gd::string p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(CommunityCreditNode*, int, int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x68920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto CommunityCreditsPage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x68a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto CommunityCreditsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommunityCreditsPage::init), this);
	using FunctionType = decltype(init())(*)(CommunityCreditsPage*);
	static auto func = wrapFunction(base::get() + 0x68b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommunityCreditsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("CommunityCreditsPage::registerWithTouchDispatcher not implemented");
}

auto CommunityCreditsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("CommunityCreditsPage::keyBackClicked not implemented");
}

auto CommunityCreditsPage::show() -> decltype(show()) {
	throw std::runtime_error("CommunityCreditsPage::show not implemented");
}

auto ConfigureHSVWidget::getHSV(GameObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(getHSV(p0, p1, p2)) {
	using FunctionType = decltype(getHSV(p0, p1, p2))(*)(ConfigureHSVWidget*, GameObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x6c320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ConfigureHSVWidget::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("ConfigureHSVWidget::textInputOpened not implemented");
}

auto ConfigureHSVWidget::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("ConfigureHSVWidget::textInputClosed not implemented");
}

auto ConfigureHSVWidget::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("ConfigureHSVWidget::textChanged not implemented");
}

auto ConfigureValuePopup::create(ConfigureValuePopupDelegate* p0, float p1, float p2, float p3, gd::string p4, gd::string p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(ConfigureValuePopupDelegate*, float, float, float, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x6c600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

auto ConfigureValuePopup::init(ConfigureValuePopupDelegate* p0, float p1, float p2, float p3, gd::string p4, gd::string p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(ConfigureValuePopup*, ConfigureValuePopupDelegate*, float, float, float, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x6c740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto ConfigureValuePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ConfigureValuePopup::keyBackClicked not implemented");
}

auto ConfigureValuePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("ConfigureValuePopup::textInputClosed not implemented");
}

auto ConfigureValuePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("ConfigureValuePopup::textChanged not implemented");
}

auto CountTriggerGameObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3b0640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto CountTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("CountTriggerGameObject::triggerObject not implemented");
}

auto CountTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("CountTriggerGameObject::customObjectSetup not implemented");
}

auto CountTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("CountTriggerGameObject::getSaveString not implemented");
}

auto CreateGuidelinesLayer::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("CreateGuidelinesLayer::update not implemented");
}

auto CreateGuidelinesLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("CreateGuidelinesLayer::ccTouchBegan not implemented");
}

auto CreateGuidelinesLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("CreateGuidelinesLayer::ccTouchMoved not implemented");
}

auto CreateGuidelinesLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("CreateGuidelinesLayer::ccTouchEnded not implemented");
}

auto CreateGuidelinesLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("CreateGuidelinesLayer::ccTouchCancelled not implemented");
}

auto CreateGuidelinesLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("CreateGuidelinesLayer::registerWithTouchDispatcher not implemented");
}

auto CreateGuidelinesLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("CreateGuidelinesLayer::keyBackClicked not implemented");
}

auto CreateGuidelinesLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	throw std::runtime_error("CreateGuidelinesLayer::keyDown not implemented");
}

auto CreateGuidelinesLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("CreateGuidelinesLayer::FLAlert_Clicked not implemented");
}

auto CreateGuidelinesLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("CreateGuidelinesLayer::onClose not implemented");
}

auto CreateGuidelinesLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	throw std::runtime_error("CreateGuidelinesLayer::keyUp not implemented");
}

auto CreateGuidelinesLayer::playMusic() -> decltype(playMusic()) {
	throw std::runtime_error("CreateGuidelinesLayer::playMusic not implemented");
}

auto CreateGuidelinesLayer::registerTouch() -> decltype(registerTouch()) {
	throw std::runtime_error("CreateGuidelinesLayer::registerTouch not implemented");
}

auto CreateGuidelinesLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	throw std::runtime_error("CreateGuidelinesLayer::onInfo not implemented");
}

auto CreateGuidelinesLayer::onRecord(cocos2d::CCObject* sender) -> decltype(onRecord(sender)) {
	throw std::runtime_error("CreateGuidelinesLayer::onRecord not implemented");
}

auto CreateGuidelinesLayer::recordingDidStop() -> decltype(recordingDidStop()) {
	throw std::runtime_error("CreateGuidelinesLayer::recordingDidStop not implemented");
}

auto CreateMenuItem::create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0xddb80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto CreateMenuItem::init(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(CreateMenuItem*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x258f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto CreateParticlePopup::create(ParticleGameObject* p0, cocos2d::CCArray* p1, gd::string p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(ParticleGameObject*, cocos2d::CCArray*, gd::string);
	static auto func = wrapFunction(base::get() + 0x3380b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto CreateParticlePopup::init(ParticleGameObject* p0, cocos2d::CCArray* p1, gd::string p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(CreateParticlePopup*, ParticleGameObject*, cocos2d::CCArray*, gd::string);
	static auto func = wrapFunction(base::get() + 0x338190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CreateParticlePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(CreateParticlePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x33f5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreateParticlePopup::willClose() -> decltype(willClose()) {
	using FunctionType = decltype(willClose())(*)(CreateParticlePopup*);
	static auto func = wrapFunction(base::get() + 0x33f540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CreateParticlePopup::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("CreateParticlePopup::update not implemented");
}

auto CreateParticlePopup::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("CreateParticlePopup::ccTouchBegan not implemented");
}

auto CreateParticlePopup::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("CreateParticlePopup::ccTouchMoved not implemented");
}

auto CreateParticlePopup::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("CreateParticlePopup::ccTouchEnded not implemented");
}

auto CreateParticlePopup::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("CreateParticlePopup::ccTouchCancelled not implemented");
}

auto CreateParticlePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateParticlePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CreateParticlePopup*);
	static auto func = wrapFunction(base::get() + 0x33f6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateParticlePopup::sliderBegan(Slider* p0) -> decltype(sliderBegan(p0)) {
	throw std::runtime_error("CreateParticlePopup::sliderBegan not implemented");
}

auto CreateParticlePopup::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	throw std::runtime_error("CreateParticlePopup::sliderEnded not implemented");
}

auto CreateParticlePopup::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	throw std::runtime_error("CreateParticlePopup::colorSelectClosed not implemented");
}

auto CreateParticlePopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("CreateParticlePopup::textInputShouldOffset not implemented");
}

auto CreateParticlePopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("CreateParticlePopup::textInputReturn not implemented");
}

auto CreateParticlePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("CreateParticlePopup::textInputClosed not implemented");
}

auto CreateParticlePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("CreateParticlePopup::textChanged not implemented");
}

auto DialogDelegate::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("DialogDelegate::dialogClosed not implemented");
}

auto CreatorLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x6f4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto CreatorLayer::scene() -> decltype(scene()) {
	using FunctionType = decltype(scene())(*)();
	static auto func = wrapFunction(base::get() + 0x6f460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto CreatorLayer::checkQuestsStatus() -> decltype(checkQuestsStatus()) {
	using FunctionType = decltype(checkQuestsStatus())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x71550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CreatorLayer::onAdventureMap(cocos2d::CCObject* sender) -> decltype(onAdventureMap(sender)) {
	using FunctionType = decltype(onAdventureMap(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x71720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onChallenge(cocos2d::CCObject* sender) -> decltype(onChallenge(sender)) {
	using FunctionType = decltype(onChallenge(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onDailyLevel(cocos2d::CCObject* sender) -> decltype(onDailyLevel(sender)) {
	using FunctionType = decltype(onDailyLevel(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onEventLevel(cocos2d::CCObject* sender) -> decltype(onEventLevel(sender)) {
	using FunctionType = decltype(onEventLevel(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onFeaturedLevels(cocos2d::CCObject* sender) -> decltype(onFeaturedLevels(sender)) {
	using FunctionType = decltype(onFeaturedLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onGauntlets(cocos2d::CCObject* sender) -> decltype(onGauntlets(sender)) {
	using FunctionType = decltype(onGauntlets(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onLeaderboards(cocos2d::CCObject* sender) -> decltype(onLeaderboards(sender)) {
	using FunctionType = decltype(onLeaderboards(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onMapPacks(cocos2d::CCObject* sender) -> decltype(onMapPacks(sender)) {
	using FunctionType = decltype(onMapPacks(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onMultiplayer(cocos2d::CCObject* sender) -> decltype(onMultiplayer(sender)) {
	using FunctionType = decltype(onMultiplayer(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x707f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onMyLevels(cocos2d::CCObject* sender) -> decltype(onMyLevels(sender)) {
	using FunctionType = decltype(onMyLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onOnlineLevels(cocos2d::CCObject* sender) -> decltype(onOnlineLevels(sender)) {
	using FunctionType = decltype(onOnlineLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x706a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onPaths(cocos2d::CCObject* sender) -> decltype(onPaths(sender)) {
	using FunctionType = decltype(onPaths(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onSavedLevels(cocos2d::CCObject* sender) -> decltype(onSavedLevels(sender)) {
	using FunctionType = decltype(onSavedLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onSecretVault(cocos2d::CCObject* sender) -> decltype(onSecretVault(sender)) {
	using FunctionType = decltype(onSecretVault(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onTopLists(cocos2d::CCObject* sender) -> decltype(onTopLists(sender)) {
	using FunctionType = decltype(onTopLists(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onTreasureRoom(cocos2d::CCObject* sender) -> decltype(onTreasureRoom(sender)) {
	using FunctionType = decltype(onTreasureRoom(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x71110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onWeeklyLevel(cocos2d::CCObject* sender) -> decltype(onWeeklyLevel(sender)) {
	using FunctionType = decltype(onWeeklyLevel(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x70be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreatorLayer::init), this);
	using FunctionType = decltype(init())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x6f550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreatorLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("CreatorLayer::keyBackClicked not implemented");
}

auto CreatorLayer::sceneWillResume() -> decltype(sceneWillResume()) {
	throw std::runtime_error("CreatorLayer::sceneWillResume not implemented");
}

auto CreatorLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&CreatorLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(CreatorLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x71690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CurrencyRewardLayer::create(int p0, int p1, int p2, int p3, CurrencySpriteType p4, int p5, CurrencySpriteType p6, int p7, cocos2d::CCPoint p8, CurrencyRewardType p9, float p10, float p11) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11))(*)(int, int, int, int, CurrencySpriteType, int, CurrencySpriteType, int, cocos2d::CCPoint, CurrencyRewardType, float, float);
	static auto func = wrapFunction(base::get() + 0x71c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
}

auto CurrencyRewardLayer::init(int p0, int p1, int p2, int p3, CurrencySpriteType p4, int p5, CurrencySpriteType p6, int p7, cocos2d::CCPoint p8, CurrencyRewardType p9, float p10, float p11) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11))(*)(CurrencyRewardLayer*, int, int, int, int, CurrencySpriteType, int, CurrencySpriteType, int, cocos2d::CCPoint, CurrencyRewardType, float, float);
	static auto func = wrapFunction(base::get() + 0x71d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
}

auto CurrencyRewardLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CurrencyRewardLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(CurrencyRewardLayer*, float);
	static auto func = wrapFunction(base::get() + 0x744c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void HSVWidgetDelegate::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) {}

void HSVWidgetDelegate::hsvChanged(ConfigureHSVWidget* p0) {}

auto CustomizeObjectLayer::create(GameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x763f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto CustomizeObjectLayer::determineStartValues() -> decltype(determineStartValues()) {
	using FunctionType = decltype(determineStartValues())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x78e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::getActiveMode(bool p0) -> decltype(getActiveMode(p0)) {
	using FunctionType = decltype(getActiveMode(p0))(*)(CustomizeObjectLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x79a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectLayer::highlightSelected(ButtonSprite* p0) -> decltype(highlightSelected(p0)) {
	using FunctionType = decltype(highlightSelected(p0))(*)(CustomizeObjectLayer*, ButtonSprite*);
	static auto func = wrapFunction(base::get() + 0x7a1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectLayer::init(GameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(CustomizeObjectLayer*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x764a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CustomizeObjectLayer::onBreakApart(cocos2d::CCObject* sender) -> decltype(onBreakApart(sender)) {
	using FunctionType = decltype(onBreakApart(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x79e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onBrowse(cocos2d::CCObject* sender) -> decltype(onBrowse(sender)) {
	using FunctionType = decltype(onBrowse(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x78b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onClear(cocos2d::CCObject* sender) -> decltype(onClear(sender)) {
	using FunctionType = decltype(onClear(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x79e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7a2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onCopy(cocos2d::CCObject* sender) -> decltype(onCopy(sender)) {
	using FunctionType = decltype(onCopy(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x78a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onEditColor(cocos2d::CCObject* sender) -> decltype(onEditColor(sender)) {
	using FunctionType = decltype(onEditColor(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x78ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onHSV(cocos2d::CCObject* sender) -> decltype(onHSV(sender)) {
	using FunctionType = decltype(onHSV(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x79210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onLiveEdit(cocos2d::CCObject* sender) -> decltype(onLiveEdit(sender)) {
	using FunctionType = decltype(onLiveEdit(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x789f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onNextColorChannel(cocos2d::CCObject* sender) -> decltype(onNextColorChannel(sender)) {
	using FunctionType = decltype(onNextColorChannel(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x79490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onPaste(cocos2d::CCObject* sender) -> decltype(onPaste(sender)) {
	using FunctionType = decltype(onPaste(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x78a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onSelectColor(cocos2d::CCObject* sender) -> decltype(onSelectColor(sender)) {
	using FunctionType = decltype(onSelectColor(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x79fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onSelectMode(cocos2d::CCObject* sender) -> decltype(onSelectMode(sender)) {
	using FunctionType = decltype(onSelectMode(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x79550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x78b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onUpdateCustomColor(cocos2d::CCObject* sender) -> decltype(onUpdateCustomColor(sender)) {
	using FunctionType = decltype(onUpdateCustomColor(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x79af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::sliderChanged(cocos2d::CCObject* p0) -> decltype(sliderChanged(p0)) {
	using FunctionType = decltype(sliderChanged(p0))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x78930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectLayer::toggleVisible() -> decltype(toggleVisible()) {
	using FunctionType = decltype(toggleVisible())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x79780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::updateChannelLabel(int p0) -> decltype(updateChannelLabel(p0)) {
	using FunctionType = decltype(updateChannelLabel(p0))(*)(CustomizeObjectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x79720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectLayer::updateColorSprite() -> decltype(updateColorSprite()) {
	using FunctionType = decltype(updateColorSprite())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x78d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::updateCustomColorLabels() -> decltype(updateCustomColorLabels()) {
	using FunctionType = decltype(updateCustomColorLabels())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x79ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::updateHSVButtons() -> decltype(updateHSVButtons()) {
	using FunctionType = decltype(updateHSVButtons())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x79050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::updateKerningLabel() -> decltype(updateKerningLabel()) {
	using FunctionType = decltype(updateKerningLabel())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x787e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::updateSelected(int p0) -> decltype(updateSelected(p0)) {
	using FunctionType = decltype(updateSelected(p0))(*)(CustomizeObjectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x7a040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("CustomizeObjectLayer::keyBackClicked not implemented");
}

auto CustomizeObjectLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("CustomizeObjectLayer::textInputOpened not implemented");
}

auto CustomizeObjectLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("CustomizeObjectLayer::textInputClosed not implemented");
}

auto CustomizeObjectLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomizeObjectLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CustomizeObjectLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x79cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	throw std::runtime_error("CustomizeObjectLayer::hsvPopupClosed not implemented");
}

auto CustomizeObjectLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&CustomizeObjectLayer::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(CustomizeObjectLayer*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x78e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::colorSetupClosed(int p0) -> decltype(colorSetupClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomizeObjectLayer::colorSetupClosed), this);
	using FunctionType = decltype(colorSetupClosed(p0))(*)(CustomizeObjectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x78c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectSettingsPopup::create(GameObject* p0, cocos2d::CCArray* p1, CustomizeObjectLayer* p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(GameObject*, cocos2d::CCArray*, CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x7a340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto CustomizeObjectSettingsPopup::init(GameObject* p0, cocos2d::CCArray* p1, CustomizeObjectLayer* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(CustomizeObjectSettingsPopup*, GameObject*, cocos2d::CCArray*, CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x7a3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CustomizeObjectSettingsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("CustomizeObjectSettingsPopup::onClose not implemented");
}

auto CustomizeObjectSettingsPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("CustomizeObjectSettingsPopup::onCustomToggleTriggerValue not implemented");
}

CustomListView::~CustomListView() {}

auto CustomListView::create(cocos2d::CCArray* p0, TableViewCellDelegate* p1, float p2, float p3, int p4, BoomListType p5, float p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCArray*, TableViewCellDelegate*, float, float, int, BoomListType, float);
	static auto func = wrapFunction(base::get() + 0x7ad30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

CustomListView* CustomListView::create(cocos2d::CCArray* entries, BoomListType type, float width, float height) {
		return CustomListView::create(entries, nullptr, width, height, 0, type, 0.0f);
	}

auto CustomListView::reloadAll() -> decltype(reloadAll()) {
	using FunctionType = decltype(reloadAll())(*)(CustomListView*);
	static auto func = wrapFunction(base::get() + 0x7c300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomListView::setupList(float p0) -> decltype(setupList(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CustomListView::setupList), this);
	using FunctionType = decltype(setupList(p0))(*)(CustomListView*, float);
	static auto func = wrapFunction(base::get() + 0x7bbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomListView::getListCell(char const* p0) -> decltype(getListCell(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&CustomListView::getListCell), this);
	using FunctionType = decltype(getListCell(p0))(*)(CustomListView*, char const*);
	static auto func = wrapFunction(base::get() + 0x7ae00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomListView::loadCell(TableViewCell* p0, int p1) -> decltype(loadCell(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int>::func(&CustomListView::loadCell), this);
	using FunctionType = decltype(loadCell(p0, p1))(*)(CustomListView*, TableViewCell*, int);
	static auto func = wrapFunction(base::get() + 0x7b780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongDelegate::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	throw std::runtime_error("CustomSongDelegate::songIDChanged not implemented");
}

auto CustomSongDelegate::getActiveSongID() -> decltype(getActiveSongID()) {
	throw std::runtime_error("CustomSongDelegate::getActiveSongID not implemented");
}

auto CustomSongDelegate::getSongFileName() -> decltype(getSongFileName()) {
	throw std::runtime_error("CustomSongDelegate::getSongFileName not implemented");
}

auto CustomSongDelegate::getLevelSettings() -> decltype(getLevelSettings()) {
	throw std::runtime_error("CustomSongDelegate::getLevelSettings not implemented");
}

auto CustomSongCell::loadFromObject(SongInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(CustomSongCell*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x831a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongCell::onDelete(cocos2d::CCObject* sender) -> decltype(onDelete(sender)) {
	using FunctionType = decltype(onDelete(sender))(*)(CustomSongCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x83410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongCell::updateBGColor(int p0) -> decltype(updateBGColor(p0)) {
	using FunctionType = decltype(updateBGColor(p0))(*)(CustomSongCell*, int);
	static auto func = wrapFunction(base::get() + 0x833a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongCell::init() -> decltype(init()) {
	throw std::runtime_error("CustomSongCell::init not implemented");
}

auto CustomSongCell::draw() -> decltype(draw()) {
	throw std::runtime_error("CustomSongCell::draw not implemented");
}

auto CustomSongCell::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	throw std::runtime_error("CustomSongCell::songIDChanged not implemented");
}

auto CustomSongCell::getActiveSongID() -> decltype(getActiveSongID()) {
	throw std::runtime_error("CustomSongCell::getActiveSongID not implemented");
}

auto CustomSongCell::getSongFileName() -> decltype(getSongFileName()) {
	throw std::runtime_error("CustomSongCell::getSongFileName not implemented");
}

auto CustomSongCell::getLevelSettings() -> decltype(getLevelSettings()) {
	throw std::runtime_error("CustomSongCell::getLevelSettings not implemented");
}

auto CustomMusicCell::loadFromObject(SongInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(CustomMusicCell*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x838a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSFXDelegate::sfxObjectSelected(SFXInfoObject* p0) -> decltype(sfxObjectSelected(p0)) {
	throw std::runtime_error("CustomSFXDelegate::sfxObjectSelected not implemented");
}

auto CustomSFXDelegate::getActiveSFXID() -> decltype(getActiveSFXID()) {
	throw std::runtime_error("CustomSFXDelegate::getActiveSFXID not implemented");
}

auto CustomSFXDelegate::overridePlaySFX(SFXInfoObject* p0) -> decltype(overridePlaySFX(p0)) {
	throw std::runtime_error("CustomSFXDelegate::overridePlaySFX not implemented");
}

auto CustomSFXCell::loadFromObject(SFXInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(CustomSFXCell*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0x83670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSFXCell::updateBGColor(int p0) -> decltype(updateBGColor(p0)) {
	using FunctionType = decltype(updateBGColor(p0))(*)(CustomSFXCell*, int);
	static auto func = wrapFunction(base::get() + 0x83760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSFXCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXCell::init), this);
	using FunctionType = decltype(init())(*)(CustomSFXCell*);
	static auto func = wrapFunction(base::get() + 0x83650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXCell::draw() -> decltype(draw()) {
	throw std::runtime_error("CustomSFXCell::draw not implemented");
}

auto CustomSFXCell::sfxObjectSelected(SFXInfoObject* p0) -> decltype(sfxObjectSelected(p0)) {
	throw std::runtime_error("CustomSFXCell::sfxObjectSelected not implemented");
}

auto CustomSFXCell::getActiveSFXID() -> decltype(getActiveSFXID()) {
	throw std::runtime_error("CustomSFXCell::getActiveSFXID not implemented");
}

void MusicDownloadDelegate::loadSongInfoFinished(SongInfoObject* p0) {}

void MusicDownloadDelegate::loadSongInfoFailed(int p0, GJSongError p1) {}

void MusicDownloadDelegate::downloadSongFinished(int p0) {}

void MusicDownloadDelegate::downloadSongFailed(int p0, GJSongError p1) {}

void MusicDownloadDelegate::songStateChanged() {}

void MusicDownloadDelegate::downloadSFXFinished(int p0) {}

void MusicDownloadDelegate::downloadSFXFailed(int p0, GJSongError p1) {}

void MusicDownloadDelegate::musicActionFinished(GJMusicAction p0) {}

void MusicDownloadDelegate::musicActionFailed(GJMusicAction p0) {}

auto CustomSFXWidget::deleteSFX() -> decltype(deleteSFX()) {
	using FunctionType = decltype(deleteSFX())(*)(CustomSFXWidget*);
	static auto func = wrapFunction(base::get() + 0x8dcf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSFXWidget::downloadFailed() -> decltype(downloadFailed()) {
	using FunctionType = decltype(downloadFailed())(*)(CustomSFXWidget*);
	static auto func = wrapFunction(base::get() + 0x8eaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSFXWidget::hideLoadingArt() -> decltype(hideLoadingArt()) {
	using FunctionType = decltype(hideLoadingArt())(*)(CustomSFXWidget*);
	static auto func = wrapFunction(base::get() + 0x8e010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSFXWidget::init(SFXInfoObject* p0, CustomSFXDelegate* p1, bool p2, bool p3, bool p4, bool p5, bool p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(CustomSFXWidget*, SFXInfoObject*, CustomSFXDelegate*, bool, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x8cf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto CustomSFXWidget::onDownload(cocos2d::CCObject* sender) -> decltype(onDownload(sender)) {
	using FunctionType = decltype(onDownload(sender))(*)(CustomSFXWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x8e0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSFXWidget::onPlayback(cocos2d::CCObject* sender) -> decltype(onPlayback(sender)) {
	using FunctionType = decltype(onPlayback(sender))(*)(CustomSFXWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x8e270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSFXWidget::showLoadingArt() -> decltype(showLoadingArt()) {
	using FunctionType = decltype(showLoadingArt())(*)(CustomSFXWidget*);
	static auto func = wrapFunction(base::get() + 0x8dec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSFXWidget::startMonitorDownload() -> decltype(startMonitorDownload()) {
	using FunctionType = decltype(startMonitorDownload())(*)(CustomSFXWidget*);
	static auto func = wrapFunction(base::get() + 0x8e1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSFXWidget::updateSFXInfo() -> decltype(updateSFXInfo()) {
	using FunctionType = decltype(updateSFXInfo())(*)(CustomSFXWidget*);
	static auto func = wrapFunction(base::get() + 0x8e490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSFXWidget::updateSFXObject(SFXInfoObject* p0) -> decltype(updateSFXObject(p0)) {
	using FunctionType = decltype(updateSFXObject(p0))(*)(CustomSFXWidget*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0x8de40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSFXWidget::downloadSFXFinished(int p0) -> decltype(downloadSFXFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSFXWidget::downloadSFXFinished), this);
	using FunctionType = decltype(downloadSFXFinished(p0))(*)(CustomSFXWidget*, int);
	static auto func = wrapFunction(base::get() + 0x8eab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSFXWidget::downloadSFXFailed(int p0, GJSongError p1) -> decltype(downloadSFXFailed(p0, p1)) {
	throw std::runtime_error("CustomSFXWidget::downloadSFXFailed not implemented");
}

auto CustomSFXWidget::songStateChanged() -> decltype(songStateChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXWidget::songStateChanged), this);
	using FunctionType = decltype(songStateChanged())(*)(CustomSFXWidget*);
	static auto func = wrapFunction(base::get() + 0x8e480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXWidget::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CustomSFXWidget::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CustomSFXWidget*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x8ebf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJDropDownLayerDelegate::dropDownLayerWillClose(GJDropDownLayer* p0) -> decltype(dropDownLayerWillClose(p0)) {
	throw std::runtime_error("GJDropDownLayerDelegate::dropDownLayerWillClose not implemented");
}

void MusicBrowserDelegate::musicBrowserClosed(MusicBrowser* p0) {}

auto CustomSongLayer::create(CustomSongDelegate* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(CustomSongDelegate*);
	static auto func = wrapFunction(base::get() + 0x8ef70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto CustomSongLayer::init(CustomSongDelegate* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(CustomSongLayer*, CustomSongDelegate*);
	static auto func = wrapFunction(base::get() + 0x8f010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("CustomSongLayer::keyBackClicked not implemented");
}

auto CustomSongLayer::show() -> decltype(show()) {
	throw std::runtime_error("CustomSongLayer::show not implemented");
}

auto CustomSongLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("CustomSongLayer::textChanged not implemented");
}

auto CustomSongLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("CustomSongLayer::textInputOpened not implemented");
}

auto CustomSongLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("CustomSongLayer::textInputClosed not implemented");
}

auto CustomSongLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("CustomSongLayer::textInputShouldOffset not implemented");
}

auto CustomSongLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("CustomSongLayer::textInputReturn not implemented");
}

auto CustomSongLayer::dropDownLayerWillClose(GJDropDownLayer* p0) -> decltype(dropDownLayerWillClose(p0)) {
	throw std::runtime_error("CustomSongLayer::dropDownLayerWillClose not implemented");
}

auto CustomSongLayer::musicBrowserClosed(MusicBrowser* p0) -> decltype(musicBrowserClosed(p0)) {
	throw std::runtime_error("CustomSongLayer::musicBrowserClosed not implemented");
}

auto CustomSongLayerDelegate::customSongLayerClosed() -> decltype(customSongLayerClosed()) {
	throw std::runtime_error("CustomSongLayerDelegate::customSongLayerClosed not implemented");
}

auto CustomSongWidget::create(SongInfoObject* songInfo, CustomSongDelegate* songDelegate, bool showSongSelect, bool showPlayMusic, bool showDownload, bool isRobtopSong, bool unkBool, bool isMusicLibrary) -> decltype(create(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary)) {
	using FunctionType = decltype(create(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary))(*)(SongInfoObject*, CustomSongDelegate*, bool, bool, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x92b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary);
}

auto CustomSongWidget::deleteSong() -> decltype(deleteSong()) {
	using FunctionType = decltype(deleteSong())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x93c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::init(SongInfoObject* songInfo, CustomSongDelegate* songDelegate, bool showSongSelect, bool showPlayMusic, bool showDownload, bool isRobtopSong, bool unkBool, bool isMusicLibrary) -> decltype(init(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary)) {
	using FunctionType = decltype(init(songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary))(*)(CustomSongWidget*, SongInfoObject*, CustomSongDelegate*, bool, bool, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x92c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, songInfo, songDelegate, showSongSelect, showPlayMusic, showDownload, isRobtopSong, unkBool, isMusicLibrary);
}

auto CustomSongWidget::onDownload(cocos2d::CCObject* sender) -> decltype(onDownload(sender)) {
	using FunctionType = decltype(onDownload(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x94510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onGetSongInfo(cocos2d::CCObject* sender) -> decltype(onGetSongInfo(sender)) {
	using FunctionType = decltype(onGetSongInfo(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x94450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onMore(cocos2d::CCObject* sender) -> decltype(onMore(sender)) {
	using FunctionType = decltype(onMore(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x93e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onPlayback(cocos2d::CCObject* sender) -> decltype(onPlayback(sender)) {
	using FunctionType = decltype(onPlayback(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x94790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x94740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::processNextMultiAsset() -> decltype(processNextMultiAsset()) {
	using FunctionType = decltype(processNextMultiAsset())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x965f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::showError(bool p0) -> decltype(showError(p0)) {
	using FunctionType = decltype(showError(p0))(*)(CustomSongWidget*, bool);
	static auto func = wrapFunction(base::get() + 0x96a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongWidget::startDownload() -> decltype(startDownload()) {
	using FunctionType = decltype(startDownload())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x94660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::startMonitorDownload() -> decltype(startMonitorDownload()) {
	using FunctionType = decltype(startMonitorDownload())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x94690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::startMultiAssetDownload() -> decltype(startMultiAssetDownload()) {
	using FunctionType = decltype(startMultiAssetDownload())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x96490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::toggleUpdateButton(bool p0) -> decltype(toggleUpdateButton(p0)) {
	using FunctionType = decltype(toggleUpdateButton(p0))(*)(CustomSongWidget*, bool);
	static auto func = wrapFunction(base::get() + 0x944c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongWidget::updateMultiAssetInfo(bool p0) -> decltype(updateMultiAssetInfo(p0)) {
	using FunctionType = decltype(updateMultiAssetInfo(p0))(*)(CustomSongWidget*, bool);
	static auto func = wrapFunction(base::get() + 0x95a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongWidget::updatePlaybackBtn() -> decltype(updatePlaybackBtn()) {
	using FunctionType = decltype(updatePlaybackBtn())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x94970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::updateSongInfo() -> decltype(updateSongInfo()) {
	using FunctionType = decltype(updateSongInfo())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x94b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::updateSongObject(SongInfoObject* p0) -> decltype(updateSongObject(p0)) {
	using FunctionType = decltype(updateSongObject(p0))(*)(CustomSongWidget*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x94280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongWidget::updateWithMultiAssets(gd::string p0, gd::string p1, int p2) -> decltype(updateWithMultiAssets(p0, p1, p2)) {
	using FunctionType = decltype(updateWithMultiAssets(p0, p1, p2))(*)(CustomSongWidget*, gd::string, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x956f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CustomSongWidget::loadSongInfoFinished(SongInfoObject* p0) -> decltype(loadSongInfoFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SongInfoObject*>::func(&CustomSongWidget::loadSongInfoFinished), this);
	using FunctionType = decltype(loadSongInfoFinished(p0))(*)(CustomSongWidget*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x96210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::loadSongInfoFailed(int p0, GJSongError p1) -> decltype(loadSongInfoFailed(p0, p1)) {
	throw std::runtime_error("CustomSongWidget::loadSongInfoFailed not implemented");
}

auto CustomSongWidget::downloadSongFinished(int p0) -> decltype(downloadSongFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSongWidget::downloadSongFinished), this);
	using FunctionType = decltype(downloadSongFinished(p0))(*)(CustomSongWidget*, int);
	static auto func = wrapFunction(base::get() + 0x96340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::downloadSongFailed(int p0, GJSongError p1) -> decltype(downloadSongFailed(p0, p1)) {
	throw std::runtime_error("CustomSongWidget::downloadSongFailed not implemented");
}

auto CustomSongWidget::downloadSFXFinished(int p0) -> decltype(downloadSFXFinished(p0)) {
	throw std::runtime_error("CustomSongWidget::downloadSFXFinished not implemented");
}

auto CustomSongWidget::downloadSFXFailed(int p0, GJSongError p1) -> decltype(downloadSFXFailed(p0, p1)) {
	throw std::runtime_error("CustomSongWidget::downloadSFXFailed not implemented");
}

auto CustomSongWidget::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	throw std::runtime_error("CustomSongWidget::musicActionFinished not implemented");
}

auto CustomSongWidget::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	throw std::runtime_error("CustomSongWidget::musicActionFailed not implemented");
}

auto CustomSongWidget::songStateChanged() -> decltype(songStateChanged()) {
	throw std::runtime_error("CustomSongWidget::songStateChanged not implemented");
}

auto CustomSongWidget::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("CustomSongWidget::FLAlert_Clicked not implemented");
}

auto DailyLevelNode::create(GJGameLevel* p0, DailyLevelPage* p1, bool p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(GJGameLevel*, DailyLevelPage*, bool);
	static auto func = wrapFunction(base::get() + 0x99610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto DailyLevelNode::init(GJGameLevel* p0, DailyLevelPage* p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(DailyLevelNode*, GJGameLevel*, DailyLevelPage*, bool);
	static auto func = wrapFunction(base::get() + 0x996c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto DailyLevelNode::onClaimReward(cocos2d::CCObject* sender) -> decltype(onClaimReward(sender)) {
	using FunctionType = decltype(onClaimReward(sender))(*)(DailyLevelNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9a040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DailyLevelNode::showSkipButton() -> decltype(showSkipButton()) {
	using FunctionType = decltype(showSkipButton())(*)(DailyLevelNode*);
	static auto func = wrapFunction(base::get() + 0x99ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DailyLevelNode::updateTimeLabel(gd::string p0) -> decltype(updateTimeLabel(p0)) {
	using FunctionType = decltype(updateTimeLabel(p0))(*)(DailyLevelNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x9a290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DailyLevelNode::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("DailyLevelNode::FLAlert_Clicked not implemented");
}

auto GJDailyLevelDelegate::dailyStatusFinished(GJTimedLevelType p0) -> decltype(dailyStatusFinished(p0)) {
	throw std::runtime_error("GJDailyLevelDelegate::dailyStatusFinished not implemented");
}

auto GJDailyLevelDelegate::dailyStatusFailed(GJTimedLevelType p0, GJErrorCode p1) -> decltype(dailyStatusFailed(p0, p1)) {
	throw std::runtime_error("GJDailyLevelDelegate::dailyStatusFailed not implemented");
}

void LevelDownloadDelegate::levelDownloadFinished(GJGameLevel* p0) {}

void LevelDownloadDelegate::levelDownloadFailed(int p0) {}

auto DailyLevelPage::create(GJTimedLevelType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x97630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto DailyLevelPage::claimLevelReward(DailyLevelNode* p0, GJGameLevel* p1, cocos2d::CCPoint p2) -> decltype(claimLevelReward(p0, p1, p2)) {
	using FunctionType = decltype(claimLevelReward(p0, p1, p2))(*)(DailyLevelPage*, DailyLevelNode*, GJGameLevel*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x992a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto DailyLevelPage::createDailyNode(GJGameLevel* p0, bool p1, float p2, bool p3) -> decltype(createDailyNode(p0, p1, p2, p3)) {
	using FunctionType = decltype(createDailyNode(p0, p1, p2, p3))(*)(DailyLevelPage*, GJGameLevel*, bool, float, bool);
	static auto func = wrapFunction(base::get() + 0x98a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto DailyLevelPage::createNodeIfLoaded() -> decltype(createNodeIfLoaded()) {
	using FunctionType = decltype(createNodeIfLoaded())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x989c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DailyLevelPage::downloadAndCreateNode() -> decltype(downloadAndCreateNode()) {
	using FunctionType = decltype(downloadAndCreateNode())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x98960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DailyLevelPage::exitDailyNode(DailyLevelNode* p0, float p1) -> decltype(exitDailyNode(p0, p1)) {
	using FunctionType = decltype(exitDailyNode(p0, p1))(*)(DailyLevelPage*, DailyLevelNode*, float);
	static auto func = wrapFunction(base::get() + 0x98c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto DailyLevelPage::getDailyTime() -> decltype(getDailyTime()) {
	using FunctionType = decltype(getDailyTime())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x98cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DailyLevelPage::getDailyTimeString(int p0) -> decltype(getDailyTimeString(p0)) {
	using FunctionType = decltype(getDailyTimeString(p0))(*)(DailyLevelPage*, int);
	static auto func = wrapFunction(base::get() + 0x98da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DailyLevelPage::init(GJTimedLevelType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(DailyLevelPage*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x976d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DailyLevelPage::tryGetDailyStatus() -> decltype(tryGetDailyStatus()) {
	using FunctionType = decltype(tryGetDailyStatus())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x98910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DailyLevelPage::updateTimers(float p0) -> decltype(updateTimers(p0)) {
	using FunctionType = decltype(updateTimers(p0))(*)(DailyLevelPage*, float);
	static auto func = wrapFunction(base::get() + 0x99120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DailyLevelPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("DailyLevelPage::registerWithTouchDispatcher not implemented");
}

auto DailyLevelPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("DailyLevelPage::keyBackClicked not implemented");
}

auto DailyLevelPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DailyLevelPage::show), this);
	using FunctionType = decltype(show())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x5d6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DailyLevelPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("DailyLevelPage::FLAlert_Clicked not implemented");
}

auto DailyLevelPage::dailyStatusFinished(GJTimedLevelType p0) -> decltype(dailyStatusFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJTimedLevelType>::func(&DailyLevelPage::dailyStatusFinished), this);
	using FunctionType = decltype(dailyStatusFinished(p0))(*)(DailyLevelPage*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x98550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DailyLevelPage::dailyStatusFailed(GJTimedLevelType p0, GJErrorCode p1) -> decltype(dailyStatusFailed(p0, p1)) {
	throw std::runtime_error("DailyLevelPage::dailyStatusFailed not implemented");
}

auto DailyLevelPage::levelDownloadFinished(GJGameLevel* p0) -> decltype(levelDownloadFinished(p0)) {
	throw std::runtime_error("DailyLevelPage::levelDownloadFinished not implemented");
}

auto DailyLevelPage::levelDownloadFailed(int p0) -> decltype(levelDownloadFailed(p0)) {
	throw std::runtime_error("DailyLevelPage::levelDownloadFailed not implemented");
}

auto RingObject::setScale(float p0) -> decltype(setScale(p0)) {
	throw std::runtime_error("RingObject::setScale not implemented");
}

auto RingObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	throw std::runtime_error("RingObject::setRotation not implemented");
}

auto RingObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("RingObject::resetObject not implemented");
}

auto RingObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("RingObject::customObjectSetup not implemented");
}

auto RingObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("RingObject::getSaveString not implemented");
}

auto RingObject::setRScale(float p0) -> decltype(setRScale(p0)) {
	throw std::runtime_error("RingObject::setRScale not implemented");
}

auto RingObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	throw std::runtime_error("RingObject::triggerActivated not implemented");
}

auto RingObject::shouldDrawEditorHitbox() -> decltype(shouldDrawEditorHitbox()) {
	throw std::runtime_error("RingObject::shouldDrawEditorHitbox not implemented");
}

auto RingObject::powerOnObject(int p0) -> decltype(powerOnObject(p0)) {
	throw std::runtime_error("RingObject::powerOnObject not implemented");
}

auto DashRingObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x39a540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto DashRingObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("DashRingObject::customObjectSetup not implemented");
}

auto DashRingObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("DashRingObject::getSaveString not implemented");
}

auto DemonFilterDelegate::demonFilterSelectClosed(int p0) -> decltype(demonFilterSelectClosed(p0)) {
	throw std::runtime_error("DemonFilterDelegate::demonFilterSelectClosed not implemented");
}

auto DemonFilterSelectLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x267340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto DemonFilterSelectLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DemonFilterSelectLayer::init), this);
	using FunctionType = decltype(init())(*)(DemonFilterSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x2673e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DemonFilterSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("DemonFilterSelectLayer::keyBackClicked not implemented");
}

auto TextAreaDelegate::fadeInTextFinished(TextArea* p0) -> decltype(fadeInTextFinished(p0)) {
	throw std::runtime_error("TextAreaDelegate::fadeInTextFinished not implemented");
}

auto DialogLayer::animateIn(DialogAnimationType p0) -> decltype(animateIn(p0)) {
	using FunctionType = decltype(animateIn(p0))(*)(DialogLayer*, DialogAnimationType);
	static auto func = wrapFunction(base::get() + 0x9b4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DialogLayer::animateInRandomSide() -> decltype(animateInRandomSide()) {
	using FunctionType = decltype(animateInRandomSide())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x9b460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DialogLayer::createDialogLayer(DialogObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(createDialogLayer(p0, p1, p2)) {
	using FunctionType = decltype(createDialogLayer(p0, p1, p2))(*)(DialogObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x9a850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto DialogLayer::init(DialogObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(DialogLayer*, DialogObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x9a900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto DialogLayer::onEnter() -> decltype(onEnter()) {
	throw std::runtime_error("DialogLayer::onEnter not implemented");
}

auto DialogLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("DialogLayer::ccTouchBegan not implemented");
}

auto DialogLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("DialogLayer::ccTouchMoved not implemented");
}

auto DialogLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("DialogLayer::ccTouchEnded not implemented");
}

auto DialogLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("DialogLayer::ccTouchCancelled not implemented");
}

auto DialogLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("DialogLayer::registerWithTouchDispatcher not implemented");
}

auto DialogLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("DialogLayer::keyBackClicked not implemented");
}

auto DialogLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	throw std::runtime_error("DialogLayer::keyDown not implemented");
}

auto DialogLayer::fadeInTextFinished(TextArea* p0) -> decltype(fadeInTextFinished(p0)) {
	throw std::runtime_error("DialogLayer::fadeInTextFinished not implemented");
}

auto DialogObject::create(gd::string p0, gd::string p1, int p2, float p3, bool p4, cocos2d::ccColor3B p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(gd::string, gd::string, int, float, bool, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x9a580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

auto DialogObject::init(gd::string p0, gd::string p1, int p2, float p3, bool p4, cocos2d::ccColor3B p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(DialogObject*, gd::string, gd::string, int, float, bool, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x9a6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto DownloadMessageDelegate::downloadMessageFinished(GJUserMessage* p0) -> decltype(downloadMessageFinished(p0)) {
	throw std::runtime_error("DownloadMessageDelegate::downloadMessageFinished not implemented");
}

auto DownloadMessageDelegate::downloadMessageFailed(int p0) -> decltype(downloadMessageFailed(p0)) {
	throw std::runtime_error("DownloadMessageDelegate::downloadMessageFailed not implemented");
}

auto DrawGridLayer::addAudioLineObject(AudioLineGuideGameObject* p0) -> decltype(addAudioLineObject(p0)) {
	using FunctionType = decltype(addAudioLineObject(p0))(*)(DrawGridLayer*, AudioLineGuideGameObject*);
	static auto func = wrapFunction(base::get() + 0x24ae00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DrawGridLayer::addToSpeedObjects(EffectGameObject* p0) -> decltype(addToSpeedObjects(p0)) {
	using FunctionType = decltype(addToSpeedObjects(p0))(*)(DrawGridLayer*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x24adc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DrawGridLayer::loadTimeMarkers(gd::string p0) -> decltype(loadTimeMarkers(p0)) {
	using FunctionType = decltype(loadTimeMarkers(p0))(*)(DrawGridLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x24afa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DrawGridLayer::removeAudioLineObject(AudioLineGuideGameObject* p0) -> decltype(removeAudioLineObject(p0)) {
	using FunctionType = decltype(removeAudioLineObject(p0))(*)(DrawGridLayer*, AudioLineGuideGameObject*);
	static auto func = wrapFunction(base::get() + 0x24ae60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DrawGridLayer::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("DrawGridLayer::update not implemented");
}

auto DrawGridLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("DrawGridLayer::draw not implemented");
}

auto DungeonBarsSprite::init() -> decltype(init()) {
	throw std::runtime_error("DungeonBarsSprite::init not implemented");
}

auto DungeonBarsSprite::visit() -> decltype(visit()) {
	throw std::runtime_error("DungeonBarsSprite::visit not implemented");
}

auto DynamicBitset::resize(unsigned int p0) -> decltype(resize(p0)) {
	using FunctionType = decltype(resize(p0))(*)(DynamicBitset*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x2ebf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void DynamicScrollDelegate::updatePageWithObject(cocos2d::CCObject* p0, cocos2d::CCObject* p1) {}

auto EditButtonBar::create(cocos2d::CCArray* objects, cocos2d::CCPoint size, int unk, bool unkBool, int columns, int rows) -> decltype(create(objects, size, unk, unkBool, columns, rows)) {
	using FunctionType = decltype(create(objects, size, unk, unkBool, columns, rows))(*)(cocos2d::CCArray*, cocos2d::CCPoint, int, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x9b7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(objects, size, unk, unkBool, columns, rows);
}

auto EditButtonBar::init(cocos2d::CCArray* objects, cocos2d::CCPoint size, int unk, bool unkBool, int columns, int rows) -> decltype(init(objects, size, unk, unkBool, columns, rows)) {
	using FunctionType = decltype(init(objects, size, unk, unkBool, columns, rows))(*)(EditButtonBar*, cocos2d::CCArray*, cocos2d::CCPoint, int, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x9b8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, objects, size, unk, unkBool, columns, rows);
}

auto EditButtonBar::loadFromItems(cocos2d::CCArray* p0, int p1, int p2, bool p3) -> decltype(loadFromItems(p0, p1, p2, p3)) {
	using FunctionType = decltype(loadFromItems(p0, p1, p2, p3))(*)(EditButtonBar*, cocos2d::CCArray*, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x9b970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

void EditButtonBar::reloadItems(int rowCount, int columnCount) {
		if (m_buttonArray)
			this->loadFromItems(m_buttonArray, rowCount, columnCount, m_unknown);
	}

auto EditGameObjectPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1, bool p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(EffectGameObject*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x20f5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto EditGameObjectPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(EditGameObjectPopup*, EffectGameObject*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x20f650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto UploadActionDelegate::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("UploadActionDelegate::uploadActionFinished not implemented");
}

auto UploadActionDelegate::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("UploadActionDelegate::uploadActionFailed not implemented");
}

auto UploadPopupDelegate::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("UploadPopupDelegate::onClosePopup not implemented");
}

void SetIDPopupDelegate::setIDPopupClosed(SetIDPopup* p0, int p1) {}

auto EditLevelLayer::create(GJGameLevel* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x9c840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto EditLevelLayer::closeTextInputs() -> decltype(closeTextInputs()) {
	using FunctionType = decltype(closeTextInputs())(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x9e520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditLevelLayer::confirmClone(cocos2d::CCObject* p0) -> decltype(confirmClone(p0)) {
	using FunctionType = decltype(confirmClone(p0))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9f560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::confirmDelete(cocos2d::CCObject* p0) -> decltype(confirmDelete(p0)) {
	using FunctionType = decltype(confirmDelete(p0))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9f0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::confirmMoveToTop(cocos2d::CCObject* p0) -> decltype(confirmMoveToTop(p0)) {
	using FunctionType = decltype(confirmMoveToTop(p0))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9f5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EditLevelLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x9c8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9f7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onClone() -> decltype(onClone()) {
	using FunctionType = decltype(onClone())(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x9f440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditLevelLayer::onEdit(cocos2d::CCObject* sender) -> decltype(onEdit(sender)) {
	using FunctionType = decltype(onEdit(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9ed00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onGuidelines(cocos2d::CCObject* sender) -> decltype(onGuidelines(sender)) {
	using FunctionType = decltype(onGuidelines(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9da70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onHelp(cocos2d::CCObject* sender) -> decltype(onHelp(sender)) {
	using FunctionType = decltype(onHelp(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9f3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onLevelInfo(cocos2d::CCObject* sender) -> decltype(onLevelInfo(sender)) {
	using FunctionType = decltype(onLevelInfo(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9db40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onMoveToTop() -> decltype(onMoveToTop()) {
	using FunctionType = decltype(onMoveToTop())(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x9f740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditLevelLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9ea10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onSetFolder(cocos2d::CCObject* sender) -> decltype(onSetFolder(sender)) {
	using FunctionType = decltype(onSetFolder(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9f660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9ee00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onUpdateDescription(cocos2d::CCObject* sender) -> decltype(onUpdateDescription(sender)) {
	using FunctionType = decltype(onUpdateDescription(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x9ec80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::verifyLevelName() -> decltype(verifyLevelName()) {
	using FunctionType = decltype(verifyLevelName())(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x9f8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("EditLevelLayer::keyBackClicked not implemented");
}

auto EditLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	throw std::runtime_error("EditLevelLayer::keyDown not implemented");
}

auto EditLevelLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	throw std::runtime_error("EditLevelLayer::setIDPopupClosed not implemented");
}

auto EditLevelLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditLevelLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditLevelLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x9f160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("EditLevelLayer::textInputOpened not implemented");
}

auto EditLevelLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("EditLevelLayer::textInputClosed not implemented");
}

auto EditLevelLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("EditLevelLayer::textChanged not implemented");
}

auto EditLevelLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("EditLevelLayer::uploadActionFinished not implemented");
}

auto EditLevelLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("EditLevelLayer::uploadActionFailed not implemented");
}

auto EditLevelLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("EditLevelLayer::onClosePopup not implemented");
}

auto GJOptionsLayer::addToggleInternal(char const* p0, int p1, bool p2, char const* p3) -> decltype(addToggleInternal(p0, p1, p2, p3)) {
	using FunctionType = decltype(addToggleInternal(p0, p1, p2, p3))(*)(GJOptionsLayer*, char const*, int, bool, char const*);
	static auto func = wrapFunction(base::get() + 0x206350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJOptionsLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x205f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	throw std::runtime_error("GJOptionsLayer::setupOptions not implemented");
}

auto GJOptionsLayer::didToggleGV(gd::string p0) -> decltype(didToggleGV(p0)) {
	throw std::runtime_error("GJOptionsLayer::didToggleGV not implemented");
}

auto GJOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	throw std::runtime_error("GJOptionsLayer::didToggle not implemented");
}

auto EditorOptionsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x207350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto EditorOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(EditorOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2073f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("EditorOptionsLayer::onClose not implemented");
}

auto EditorOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	throw std::runtime_error("EditorOptionsLayer::setupOptions not implemented");
}

auto EditorPauseLayer::create(LevelEditorLayer* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x9ff80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto EditorPauseLayer::doResetUnused() -> decltype(doResetUnused()) {
	using FunctionType = decltype(doResetUnused())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0x242150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorPauseLayer::init(LevelEditorLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EditorPauseLayer*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xa0020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::onExitEditor(cocos2d::CCObject* sender) -> decltype(onExitEditor(sender)) {
	using FunctionType = decltype(onExitEditor(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa2ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onExitNoSave(cocos2d::CCObject* sender) -> decltype(onExitNoSave(sender)) {
	using FunctionType = decltype(onExitNoSave(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa2f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onResetUnusedColors(cocos2d::CCObject* sender) -> decltype(onResetUnusedColors(sender)) {
	using FunctionType = decltype(onResetUnusedColors(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa1f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onResume(cocos2d::CCObject* sender) -> decltype(onResume(sender)) {
	using FunctionType = decltype(onResume(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa2640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSave(cocos2d::CCObject* sender) -> decltype(onSave(sender)) {
	using FunctionType = decltype(onSave(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa2e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSaveAndExit(cocos2d::CCObject* sender) -> decltype(onSaveAndExit(sender)) {
	using FunctionType = decltype(onSaveAndExit(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa2eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSaveAndPlay(cocos2d::CCObject* sender) -> decltype(onSaveAndPlay(sender)) {
	using FunctionType = decltype(onSaveAndPlay(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa2c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSelectAll(cocos2d::CCObject* sender) -> decltype(onSelectAll(sender)) {
	using FunctionType = decltype(onSelectAll(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa20e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSelectAllLeft(cocos2d::CCObject* sender) -> decltype(onSelectAllLeft(sender)) {
	using FunctionType = decltype(onSelectAllLeft(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa2100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSong(cocos2d::CCObject* sender) -> decltype(onSong(sender)) {
	using FunctionType = decltype(onSong(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa25a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::playStep2() -> decltype(playStep2()) {
	using FunctionType = decltype(playStep2())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0xa2cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorPauseLayer::playStep3() -> decltype(playStep3()) {
	using FunctionType = decltype(playStep3())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0xa2dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorPauseLayer::saveLevel() -> decltype(saveLevel()) {
	using FunctionType = decltype(saveLevel())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0xa26c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorPauseLayer::uncheckAllPortals(cocos2d::CCObject* p0) -> decltype(uncheckAllPortals(p0)) {
	using FunctionType = decltype(uncheckAllPortals(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa1e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::updateSongButton() -> decltype(updateSongButton()) {
	using FunctionType = decltype(updateSongButton())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0xa25d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorPauseLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("EditorPauseLayer::keyBackClicked not implemented");
}

auto EditorPauseLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorPauseLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EditorPauseLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0xa3080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorPauseLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorPauseLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0xa0730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorPauseLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditorPauseLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditorPauseLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xa2fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControlDelegate::angleChanged(float p0) -> decltype(angleChanged(p0)) {
	throw std::runtime_error("GJRotationControlDelegate::angleChanged not implemented");
}

auto GJRotationControlDelegate::angleChangeBegin() -> decltype(angleChangeBegin()) {
	throw std::runtime_error("GJRotationControlDelegate::angleChangeBegin not implemented");
}

auto GJRotationControlDelegate::angleChangeEnded() -> decltype(angleChangeEnded()) {
	throw std::runtime_error("GJRotationControlDelegate::angleChangeEnded not implemented");
}

auto GJScaleControlDelegate::scaleXChanged(float p0) -> decltype(scaleXChanged(p0)) {
	throw std::runtime_error("GJScaleControlDelegate::scaleXChanged not implemented");
}

auto GJScaleControlDelegate::scaleYChanged(float p0) -> decltype(scaleYChanged(p0)) {
	throw std::runtime_error("GJScaleControlDelegate::scaleYChanged not implemented");
}

auto GJScaleControlDelegate::scaleXYChanged(float p0, float p1) -> decltype(scaleXYChanged(p0, p1)) {
	throw std::runtime_error("GJScaleControlDelegate::scaleXYChanged not implemented");
}

auto GJScaleControlDelegate::scaleChangeBegin() -> decltype(scaleChangeBegin()) {
	throw std::runtime_error("GJScaleControlDelegate::scaleChangeBegin not implemented");
}

auto GJScaleControlDelegate::scaleChangeEnded() -> decltype(scaleChangeEnded()) {
	throw std::runtime_error("GJScaleControlDelegate::scaleChangeEnded not implemented");
}

auto GJScaleControlDelegate::updateScaleControl() -> decltype(updateScaleControl()) {
	throw std::runtime_error("GJScaleControlDelegate::updateScaleControl not implemented");
}

auto GJScaleControlDelegate::anchorPointMoved(cocos2d::CCPoint p0) -> decltype(anchorPointMoved(p0)) {
	throw std::runtime_error("GJScaleControlDelegate::anchorPointMoved not implemented");
}

auto GJTransformControlDelegate::transformScaleXChanged(float p0) -> decltype(transformScaleXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleXChanged not implemented");
}

auto GJTransformControlDelegate::transformScaleYChanged(float p0) -> decltype(transformScaleYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleYChanged not implemented");
}

auto GJTransformControlDelegate::transformScaleXYChanged(float p0, float p1) -> decltype(transformScaleXYChanged(p0, p1)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleXYChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationXChanged(float p0) -> decltype(transformRotationXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationXChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationYChanged(float p0) -> decltype(transformRotationYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationYChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationChanged(float p0) -> decltype(transformRotationChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationChanged not implemented");
}

auto GJTransformControlDelegate::transformResetRotation() -> decltype(transformResetRotation()) {
	throw std::runtime_error("GJTransformControlDelegate::transformResetRotation not implemented");
}

auto GJTransformControlDelegate::transformRestoreRotation() -> decltype(transformRestoreRotation()) {
	throw std::runtime_error("GJTransformControlDelegate::transformRestoreRotation not implemented");
}

auto GJTransformControlDelegate::transformSkewXChanged(float p0) -> decltype(transformSkewXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformSkewXChanged not implemented");
}

auto GJTransformControlDelegate::transformSkewYChanged(float p0) -> decltype(transformSkewYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformSkewYChanged not implemented");
}

auto GJTransformControlDelegate::transformChangeBegin() -> decltype(transformChangeBegin()) {
	throw std::runtime_error("GJTransformControlDelegate::transformChangeBegin not implemented");
}

auto GJTransformControlDelegate::transformChangeEnded() -> decltype(transformChangeEnded()) {
	throw std::runtime_error("GJTransformControlDelegate::transformChangeEnded not implemented");
}

auto GJTransformControlDelegate::updateTransformControl() -> decltype(updateTransformControl()) {
	throw std::runtime_error("GJTransformControlDelegate::updateTransformControl not implemented");
}

auto GJTransformControlDelegate::anchorPointMoved(cocos2d::CCPoint p0) -> decltype(anchorPointMoved(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::anchorPointMoved not implemented");
}

auto GJTransformControlDelegate::getTransformNode() -> decltype(getTransformNode()) {
	throw std::runtime_error("GJTransformControlDelegate::getTransformNode not implemented");
}

auto GJTransformControlDelegate::getUI() -> decltype(getUI()) {
	throw std::runtime_error("GJTransformControlDelegate::getUI not implemented");
}

auto EditorUI::activateRotationControl(cocos2d::CCObject* p0) -> decltype(activateRotationControl(p0)) {
	using FunctionType = decltype(activateRotationControl(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd83d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::activateScaleControl(cocos2d::CCObject* p0) -> decltype(activateScaleControl(p0)) {
	using FunctionType = decltype(activateScaleControl(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xcc130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::applyOffset(GameObject* p0) -> decltype(applyOffset(p0)) {
	using FunctionType = decltype(applyOffset(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xd7d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::canSelectObject(GameObject* p0) -> decltype(canSelectObject(p0)) {
	using FunctionType = decltype(canSelectObject(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xc89c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::centerCameraOnObject(GameObject* p0) -> decltype(centerCameraOnObject(p0)) {
	using FunctionType = decltype(centerCameraOnObject(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xaa950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::checkLiveColorSelect() -> decltype(checkLiveColorSelect()) {
	using FunctionType = decltype(checkLiveColorSelect())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xc8b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::clickOnPosition(cocos2d::CCPoint p0) -> decltype(clickOnPosition(p0)) {
	using FunctionType = decltype(clickOnPosition(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xa6870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::closeLiveColorSelect() -> decltype(closeLiveColorSelect()) {
	using FunctionType = decltype(closeLiveColorSelect())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd4550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::closeLiveHSVSelect() -> decltype(closeLiveHSVSelect()) {
	using FunctionType = decltype(closeLiveHSVSelect())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd46d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::constrainGameLayerPosition() -> decltype(constrainGameLayerPosition()) {
	using FunctionType = decltype(constrainGameLayerPosition())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd7df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::constrainGameLayerPosition(float p0, float p1) -> decltype(constrainGameLayerPosition(p0, p1)) {
	using FunctionType = decltype(constrainGameLayerPosition(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0xd7df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::copyObjects(cocos2d::CCArray* p0, bool p1, bool p2) -> decltype(copyObjects(p0, p1, p2)) {
	using FunctionType = decltype(copyObjects(p0, p1, p2))(*)(EditorUI*, cocos2d::CCArray*, bool, bool);
	static auto func = wrapFunction(base::get() + 0xca970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EditorUI::createCustomItems() -> decltype(createCustomItems()) {
	using FunctionType = decltype(createCustomItems())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xa8570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::createMoveMenu() -> decltype(createMoveMenu()) {
	using FunctionType = decltype(createMoveMenu())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd1be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::createNewKeyframeAnim() -> decltype(createNewKeyframeAnim()) {
	using FunctionType = decltype(createNewKeyframeAnim())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd0230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::createObject(int p0, cocos2d::CCPoint p1) -> decltype(createObject(p0, p1)) {
	using FunctionType = decltype(createObject(p0, p1))(*)(EditorUI*, int, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xc86a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::createUndoObject(UndoCommand p0, bool p1) -> decltype(createUndoObject(p0, p1)) {
	using FunctionType = decltype(createUndoObject(p0, p1))(*)(EditorUI*, UndoCommand, bool);
	static auto func = wrapFunction(base::get() + 0xc9320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::createUndoSelectObject(bool p0) -> decltype(createUndoSelectObject(p0)) {
	using FunctionType = decltype(createUndoSelectObject(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0xc9470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::deactivateScaleControl() -> decltype(deactivateScaleControl()) {
	using FunctionType = decltype(deactivateScaleControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xcc2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::deactivateTransformControl() -> decltype(deactivateTransformControl()) {
	using FunctionType = decltype(deactivateTransformControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xcc800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::deleteObject(GameObject* p0, bool p1) -> decltype(deleteObject(p0, p1)) {
	using FunctionType = decltype(deleteObject(p0, p1))(*)(EditorUI*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0xaa120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::deselectAll() -> decltype(deselectAll()) {
	using FunctionType = decltype(deselectAll())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xc9600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::deselectObject() -> decltype(deselectObject()) {
	using FunctionType = decltype(deselectObject())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xc94f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::deselectObject(GameObject* p0) -> decltype(deselectObject(p0)) {
	using FunctionType = decltype(deselectObject(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xc9540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::deselectTargetPortals() -> decltype(deselectTargetPortals()) {
	using FunctionType = decltype(deselectTargetPortals())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xaa480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::doCopyObjects(bool p0) -> decltype(doCopyObjects(p0)) {
	using FunctionType = decltype(doCopyObjects(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0xcaf10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::doPasteObjects(bool p0) -> decltype(doPasteObjects(p0)) {
	using FunctionType = decltype(doPasteObjects(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0xcb090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::editButton2Usable() -> decltype(editButton2Usable()) {
	using FunctionType = decltype(editButton2Usable())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd13a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::editButtonUsable() -> decltype(editButtonUsable()) {
	using FunctionType = decltype(editButtonUsable())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd0cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::editColor() -> decltype(editColor()) {
	using FunctionType = decltype(editColor())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd4110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::editColorButtonUsable() -> decltype(editColorButtonUsable()) {
	using FunctionType = decltype(editColorButtonUsable())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd3d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::editGroup(cocos2d::CCObject* p0) -> decltype(editGroup(p0)) {
	using FunctionType = decltype(editGroup(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd4720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::editHSV() -> decltype(editHSV()) {
	using FunctionType = decltype(editHSV())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd45a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::editObject(cocos2d::CCObject* p0) -> decltype(editObject(p0)) {
	using FunctionType = decltype(editObject(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd2840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::editObject2(cocos2d::CCObject* p0) -> decltype(editObject2(p0)) {
	using FunctionType = decltype(editObject2(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd36b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::editObjectSpecial(int p0) -> decltype(editObjectSpecial(p0)) {
	using FunctionType = decltype(editObjectSpecial(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0xd36c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::editorLayerForArray(cocos2d::CCArray* p0, bool p1) -> decltype(editorLayerForArray(p0, p1)) {
	using FunctionType = decltype(editorLayerForArray(p0, p1))(*)(EditorUI*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0xcbda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::findAndSelectObject(int p0, bool p1) -> decltype(findAndSelectObject(p0, p1)) {
	using FunctionType = decltype(findAndSelectObject(p0, p1))(*)(EditorUI*, int, bool);
	static auto func = wrapFunction(base::get() + 0xaa870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::flipObjectsX(cocos2d::CCArray* p0) -> decltype(flipObjectsX(p0)) {
	using FunctionType = decltype(flipObjectsX(p0))(*)(EditorUI*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0xd5c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::flipObjectsY(cocos2d::CCArray* p0) -> decltype(flipObjectsY(p0)) {
	using FunctionType = decltype(flipObjectsY(p0))(*)(EditorUI*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0xd5e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::getCreateBtn(int id, int bg) -> decltype(getCreateBtn(id, bg)) {
	using FunctionType = decltype(getCreateBtn(id, bg))(*)(EditorUI*, int, int);
	static auto func = wrapFunction(base::get() + 0xc78a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, id, bg);
}

auto EditorUI::getGridSnappedPos(cocos2d::CCPoint p0) -> decltype(getGridSnappedPos(p0)) {
	using FunctionType = decltype(getGridSnappedPos(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xd8aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::getGroupCenter(cocos2d::CCArray* p0, bool p1) -> decltype(getGroupCenter(p0, p1)) {
	using FunctionType = decltype(getGroupCenter(p0, p1))(*)(EditorUI*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0xd8140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::getLimitedPosition(cocos2d::CCPoint p0) -> decltype(getLimitedPosition(p0)) {
	using FunctionType = decltype(getLimitedPosition(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xd4ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::getSelectedObjects() -> decltype(getSelectedObjects()) {
	using FunctionType = decltype(getSelectedObjects())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xc92a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::getSnapAngle(GameObject* p0, cocos2d::CCArray* p1) -> decltype(getSnapAngle(p0, p1)) {
	using FunctionType = decltype(getSnapAngle(p0, p1))(*)(EditorUI*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x23c490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::getSpriteButton(char const* p0, cocos2d::SEL_MenuHandler p1, cocos2d::CCMenu* p2, float p3) -> decltype(getSpriteButton(p0, p1, p2, p3)) {
	using FunctionType = decltype(getSpriteButton(p0, p1, p2, p3))(*)(EditorUI*, char const*, cocos2d::SEL_MenuHandler, cocos2d::CCMenu*, float);
	static auto func = wrapFunction(base::get() + 0xa6c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto EditorUI::getXMin(int p0) -> decltype(getXMin(p0)) {
	using FunctionType = decltype(getXMin(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0xd8010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::init(LevelEditorLayer* editorLayer) -> decltype(init(editorLayer)) {
	using FunctionType = decltype(init(editorLayer))(*)(EditorUI*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xa4260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, editorLayer);
}

auto EditorUI::isSpecialSnapObject(int p0) -> decltype(isSpecialSnapObject(p0)) {
	using FunctionType = decltype(isSpecialSnapObject(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0xdd6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::moveForCommand(EditCommand command) -> decltype(moveForCommand(command)) {
	using FunctionType = decltype(moveForCommand(command))(*)(EditorUI*, EditCommand);
	static auto func = wrapFunction(base::get() + 0xd4a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, command);
}

auto EditorUI::moveGamelayer(cocos2d::CCPoint p0) -> decltype(moveGamelayer(p0)) {
	using FunctionType = decltype(moveGamelayer(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xa7070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::moveObject(GameObject* p0, cocos2d::CCPoint p1) -> decltype(moveObject(p0, p1)) {
	using FunctionType = decltype(moveObject(p0, p1))(*)(EditorUI*, GameObject*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xd4f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::moveObjectCall(EditCommand p0) -> decltype(moveObjectCall(p0)) {
	using FunctionType = decltype(moveObjectCall(p0))(*)(EditorUI*, EditCommand);
	static auto func = wrapFunction(base::get() + 0xd4d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::offsetForKey(int p0) -> decltype(offsetForKey(p0)) {
	using FunctionType = decltype(offsetForKey(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0xdb460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::onCopy(cocos2d::CCObject* sender) -> decltype(onCopy(sender)) {
	using FunctionType = decltype(onCopy(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xcaf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onCopyState(cocos2d::CCObject* sender) -> decltype(onCopyState(sender)) {
	using FunctionType = decltype(onCopyState(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xcbcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onCreate() -> decltype(onCreate()) {
	using FunctionType = decltype(onCreate())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xc7ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::onCreateButton(cocos2d::CCObject* sender) -> decltype(onCreateButton(sender)) {
	using FunctionType = decltype(onCreateButton(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc7d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onCreateObject(int p0) -> decltype(onCreateObject(p0)) {
	using FunctionType = decltype(onCreateObject(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0xc7fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::onDelete(cocos2d::CCObject* sender) -> decltype(onDelete(sender)) {
	using FunctionType = decltype(onDelete(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa9b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDeleteSelected(cocos2d::CCObject* sender) -> decltype(onDeleteSelected(sender)) {
	using FunctionType = decltype(onDeleteSelected(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xaa1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDeleteSelectedType(cocos2d::CCObject* sender) -> decltype(onDeleteSelectedType(sender)) {
	using FunctionType = decltype(onDeleteSelectedType(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xaa5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDeselectAll(cocos2d::CCObject* sender) -> decltype(onDeselectAll(sender)) {
	using FunctionType = decltype(onDeselectAll(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc95c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDuplicate(cocos2d::CCObject* sender) -> decltype(onDuplicate(sender)) {
	using FunctionType = decltype(onDuplicate(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xca7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onEditColor(cocos2d::CCObject* sender) -> decltype(onEditColor(sender)) {
	using FunctionType = decltype(onEditColor(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd3eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGoToBaseLayer(cocos2d::CCObject* sender) -> decltype(onGoToBaseLayer(sender)) {
	using FunctionType = decltype(onGoToBaseLayer(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xcbec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGoToLayer(cocos2d::CCObject* sender) -> decltype(onGoToLayer(sender)) {
	using FunctionType = decltype(onGoToLayer(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xcbe10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGroupDown(cocos2d::CCObject* sender) -> decltype(onGroupDown(sender)) {
	using FunctionType = decltype(onGroupDown(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd47a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGroupSticky(cocos2d::CCObject* sender) -> decltype(onGroupSticky(sender)) {
	using FunctionType = decltype(onGroupSticky(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xca5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGroupUp(cocos2d::CCObject* sender) -> decltype(onGroupUp(sender)) {
	using FunctionType = decltype(onGroupUp(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd4780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onLockLayer(cocos2d::CCObject* sender) -> decltype(onLockLayer(sender)) {
	using FunctionType = decltype(onLockLayer(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd48f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onNewCustomItem(cocos2d::CCObject* sender) -> decltype(onNewCustomItem(sender)) {
	using FunctionType = decltype(onNewCustomItem(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa81c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPaste(cocos2d::CCObject* sender) -> decltype(onPaste(sender)) {
	using FunctionType = decltype(onPaste(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xcb080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPasteColor(cocos2d::CCObject* sender) -> decltype(onPasteColor(sender)) {
	using FunctionType = decltype(onPasteColor(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xcbd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPasteState(cocos2d::CCObject* sender) -> decltype(onPasteState(sender)) {
	using FunctionType = decltype(onPasteState(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xcbd00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPause(cocos2d::CCObject* sender) -> decltype(onPause(sender)) {
	using FunctionType = decltype(onPause(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa6130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPlayback(cocos2d::CCObject* sender) -> decltype(onPlayback(sender)) {
	using FunctionType = decltype(onPlayback(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc9d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPlaytest(cocos2d::CCObject* sender) -> decltype(onPlaytest(sender)) {
	using FunctionType = decltype(onPlaytest(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xca090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onSelectBuildTab(cocos2d::CCObject* sender) -> decltype(onSelectBuildTab(sender)) {
	using FunctionType = decltype(onSelectBuildTab(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xcbee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa60e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onStopPlaytest(cocos2d::CCObject* sender) -> decltype(onStopPlaytest(sender)) {
	using FunctionType = decltype(onStopPlaytest(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xca200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onUngroupSticky(cocos2d::CCObject* sender) -> decltype(onUngroupSticky(sender)) {
	using FunctionType = decltype(onUngroupSticky(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xca600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onUpdateDeleteFilter(cocos2d::CCObject* sender) -> decltype(onUpdateDeleteFilter(sender)) {
	using FunctionType = decltype(onUpdateDeleteFilter(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xaabe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::pasteObjects(gd::string p0, bool p1) -> decltype(pasteObjects(p0, p1)) {
	using FunctionType = decltype(pasteObjects(p0, p1))(*)(EditorUI*, gd::string, bool);
	static auto func = wrapFunction(base::get() + 0xcb240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::playtestStopped() -> decltype(playtestStopped()) {
	using FunctionType = decltype(playtestStopped())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xca240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::positionIsInSnapped(cocos2d::CCPoint p0) -> decltype(positionIsInSnapped(p0)) {
	using FunctionType = decltype(positionIsInSnapped(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xc8720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::recreateButtonTabs() -> decltype(recreateButtonTabs()) {
	using FunctionType = decltype(recreateButtonTabs())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xa8a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::redoLastAction(cocos2d::CCObject* p0) -> decltype(redoLastAction(p0)) {
	using FunctionType = decltype(redoLastAction(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc9ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::reloadCustomItems() -> decltype(reloadCustomItems()) {
	using FunctionType = decltype(reloadCustomItems())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xa8a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::removeOffset(GameObject* p0) -> decltype(removeOffset(p0)) {
	using FunctionType = decltype(removeOffset(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xd7cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::repositionObjectsToCenter(cocos2d::CCArray* p0, cocos2d::CCPoint p1, bool p2) -> decltype(repositionObjectsToCenter(p0, p1, p2)) {
	using FunctionType = decltype(repositionObjectsToCenter(p0, p1, p2))(*)(EditorUI*, cocos2d::CCArray*, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0xcbc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EditorUI::resetObjectEditorValues(cocos2d::CCArray* p0) -> decltype(resetObjectEditorValues(p0)) {
	using FunctionType = decltype(resetObjectEditorValues(p0))(*)(EditorUI*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0xcca80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::resetSelectedObjectsColor() -> decltype(resetSelectedObjectsColor()) {
	using FunctionType = decltype(resetSelectedObjectsColor())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd4990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::resetUI() -> decltype(resetUI()) {
	using FunctionType = decltype(resetUI())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xa8b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::rotateObjects(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2) -> decltype(rotateObjects(p0, p1, p2)) {
	using FunctionType = decltype(rotateObjects(p0, p1, p2))(*)(EditorUI*, cocos2d::CCArray*, float, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xd6080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EditorUI::scaleObjects(cocos2d::CCArray* p0, float p1, float p2, cocos2d::CCPoint p3, ObjectScaleType p4) -> decltype(scaleObjects(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(scaleObjects(p0, p1, p2, p3, p4))(*)(EditorUI*, cocos2d::CCArray*, float, float, cocos2d::CCPoint, ObjectScaleType);
	static auto func = wrapFunction(base::get() + 0xd64b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto EditorUI::selectAll() -> decltype(selectAll()) {
	using FunctionType = decltype(selectAll())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xc9750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::selectAllWithDirection(bool p0) -> decltype(selectAllWithDirection(p0)) {
	using FunctionType = decltype(selectAllWithDirection(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0xc9890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::selectBuildTab(int p0) -> decltype(selectBuildTab(p0)) {
	using FunctionType = decltype(selectBuildTab(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0xcbf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::selectObject(GameObject* p0, bool p1) -> decltype(selectObject(p0, p1)) {
	using FunctionType = decltype(selectObject(p0, p1))(*)(EditorUI*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0xc8aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::selectObjects(cocos2d::CCArray* p0, bool p1) -> decltype(selectObjects(p0, p1)) {
	using FunctionType = decltype(selectObjects(p0, p1))(*)(EditorUI*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0xc8d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::setupCreateMenu() -> decltype(setupCreateMenu()) {
	using FunctionType = decltype(setupCreateMenu())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xab240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::setupDeleteMenu() -> decltype(setupDeleteMenu()) {
	using FunctionType = decltype(setupDeleteMenu())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xa8cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::showLiveColorSelectForMode(int p0) -> decltype(showLiveColorSelectForMode(p0)) {
	using FunctionType = decltype(showLiveColorSelectForMode(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0xd4460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::showMaxBasicError() -> decltype(showMaxBasicError()) {
	using FunctionType = decltype(showMaxBasicError())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xca6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::showMaxCoinError() -> decltype(showMaxCoinError()) {
	using FunctionType = decltype(showMaxCoinError())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xca750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::showMaxError() -> decltype(showMaxError()) {
	using FunctionType = decltype(showMaxError())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xca640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::showUI(bool p0) -> decltype(showUI(p0)) {
	using FunctionType = decltype(showUI(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0xc9c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::sliderChanged(cocos2d::CCObject* p0) -> decltype(sliderChanged(p0)) {
	using FunctionType = decltype(sliderChanged(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa6cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleEditObjectButton() -> decltype(toggleEditObjectButton()) {
	using FunctionType = decltype(toggleEditObjectButton())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd1680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::toggleEnableRotate(cocos2d::CCObject* p0) -> decltype(toggleEnableRotate(p0)) {
	using FunctionType = decltype(toggleEnableRotate(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc8900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleFreeMove(cocos2d::CCObject* p0) -> decltype(toggleFreeMove(p0)) {
	using FunctionType = decltype(toggleFreeMove(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc8810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleMode(cocos2d::CCObject* p0) -> decltype(toggleMode(p0)) {
	using FunctionType = decltype(toggleMode(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa8c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleSnap(cocos2d::CCObject* p0) -> decltype(toggleSnap(p0)) {
	using FunctionType = decltype(toggleSnap(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc8880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleStickyControls(bool p0) -> decltype(toggleStickyControls(p0)) {
	using FunctionType = decltype(toggleStickyControls(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0xa6080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleSwipe(cocos2d::CCObject* p0) -> decltype(toggleSwipe(p0)) {
	using FunctionType = decltype(toggleSwipe(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc87a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::transformObject(GameObject* p0, EditCommand p1, bool p2) -> decltype(transformObject(p0, p1, p2)) {
	using FunctionType = decltype(transformObject(p0, p1, p2))(*)(EditorUI*, GameObject*, EditCommand, bool);
	static auto func = wrapFunction(base::get() + 0xd5780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EditorUI::transformObjectCall(cocos2d::CCObject* p0) -> decltype(transformObjectCall(p0)) {
	using FunctionType = decltype(transformObjectCall(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xd5360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::transformObjectCall(EditCommand p0) -> decltype(transformObjectCall(p0)) {
	using FunctionType = decltype(transformObjectCall(p0))(*)(EditorUI*, EditCommand);
	static auto func = wrapFunction(base::get() + 0xd5380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::transformObjects(cocos2d::CCArray* p0, cocos2d::CCPoint p1, float p2, float p3, float p4, float p5, float p6, float p7) -> decltype(transformObjects(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(transformObjects(p0, p1, p2, p3, p4, p5, p6, p7))(*)(EditorUI*, cocos2d::CCArray*, cocos2d::CCPoint, float, float, float, float, float, float);
	static auto func = wrapFunction(base::get() + 0xd6e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto EditorUI::transformObjectsActive() -> decltype(transformObjectsActive()) {
	using FunctionType = decltype(transformObjectsActive())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd6d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::transformObjectsReset() -> decltype(transformObjectsReset()) {
	using FunctionType = decltype(transformObjectsReset())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd6da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::undoLastAction(cocos2d::CCObject* p0) -> decltype(undoLastAction(p0)) {
	using FunctionType = decltype(undoLastAction(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xc9b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::updateButtons() -> decltype(updateButtons()) {
	using FunctionType = decltype(updateButtons())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xa6310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateCreateMenu(bool p0) -> decltype(updateCreateMenu(p0)) {
	using FunctionType = decltype(updateCreateMenu(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0xc7d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::updateEditButtonColor(int p0, cocos2d::ccColor3B p1) -> decltype(updateEditButtonColor(p0, p1)) {
	using FunctionType = decltype(updateEditButtonColor(p0, p1))(*)(EditorUI*, int, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0xcc030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::updateEditMenu() -> decltype(updateEditMenu()) {
	using FunctionType = decltype(updateEditMenu())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd0c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateGridNodeSize() -> decltype(updateGridNodeSize()) {
	using FunctionType = decltype(updateGridNodeSize())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xa6f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateGroupIDLabel() -> decltype(updateGroupIDLabel()) {
	using FunctionType = decltype(updateGroupIDLabel())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd47d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateObjectInfoLabel() -> decltype(updateObjectInfoLabel()) {
	using FunctionType = decltype(updateObjectInfoLabel())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xa70d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updatePlaybackBtn() -> decltype(updatePlaybackBtn()) {
	using FunctionType = decltype(updatePlaybackBtn())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xc9f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateSlider() -> decltype(updateSlider()) {
	using FunctionType = decltype(updateSlider())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xa6ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateZoom(float p0) -> decltype(updateZoom(p0)) {
	using FunctionType = decltype(updateZoom(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xca3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::valueFromXPos(float p0) -> decltype(valueFromXPos(p0)) {
	using FunctionType = decltype(valueFromXPos(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xa6e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::zoomIn(cocos2d::CCObject* p0) -> decltype(zoomIn(p0)) {
	using FunctionType = decltype(zoomIn(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xca2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::zoomOut(cocos2d::CCObject* p0) -> decltype(zoomOut(p0)) {
	using FunctionType = decltype(zoomOut(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xca360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::draw), this);
	using FunctionType = decltype(draw())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd80f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0xd8be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0xd9160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0xd9730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4c830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("EditorUI::registerWithTouchDispatcher not implemented");
}

auto EditorUI::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xcc020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorUI::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EditorUI*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0xda300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::getUI() -> decltype(getUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::getUI), this);
	using FunctionType = decltype(getUI())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xa3aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&EditorUI::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(EditorUI*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0xaa700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditorUI::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditorUI*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xaa650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::updateTransformControl() -> decltype(updateTransformControl()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::updateTransformControl), this);
	using FunctionType = decltype(updateTransformControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xcc870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformChangeBegin() -> decltype(transformChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformChangeBegin), this);
	using FunctionType = decltype(transformChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xccc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformChangeEnded() -> decltype(transformChangeEnded()) {
	throw std::runtime_error("EditorUI::transformChangeEnded not implemented");
}

auto EditorUI::getTransformNode() -> decltype(getTransformNode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::getTransformNode), this);
	using FunctionType = decltype(getTransformNode())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xa3ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformScaleXChanged(float p0) -> decltype(transformScaleXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformScaleXChanged), this);
	using FunctionType = decltype(transformScaleXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xd6ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformScaleYChanged(float p0) -> decltype(transformScaleYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformScaleYChanged), this);
	using FunctionType = decltype(transformScaleYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xd6bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformScaleXYChanged(float p0, float p1) -> decltype(transformScaleXYChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&EditorUI::transformScaleXYChanged), this);
	using FunctionType = decltype(transformScaleXYChanged(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0xd6be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::transformSkewXChanged(float p0) -> decltype(transformSkewXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformSkewXChanged), this);
	using FunctionType = decltype(transformSkewXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xd6c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformSkewYChanged(float p0) -> decltype(transformSkewYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformSkewYChanged), this);
	using FunctionType = decltype(transformSkewYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xd6c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationXChanged(float p0) -> decltype(transformRotationXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationXChanged), this);
	using FunctionType = decltype(transformRotationXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xd6c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationYChanged(float p0) -> decltype(transformRotationYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationYChanged), this);
	using FunctionType = decltype(transformRotationYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xd6c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationChanged(float p0) -> decltype(transformRotationChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationChanged), this);
	using FunctionType = decltype(transformRotationChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xd6c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformResetRotation() -> decltype(transformResetRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformResetRotation), this);
	using FunctionType = decltype(transformResetRotation())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd6cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformRestoreRotation() -> decltype(transformRestoreRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformRestoreRotation), this);
	using FunctionType = decltype(transformRestoreRotation())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd6cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::songStateChanged() -> decltype(songStateChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::songStateChanged), this);
	using FunctionType = decltype(songStateChanged())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xca080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&EditorUI::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(EditorUI*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0xd4930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorUI::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(EditorUI*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0xdb210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&EditorUI::scrollWheel), this);
	using FunctionType = decltype(scrollWheel(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0xdb260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::angleChangeBegin() -> decltype(angleChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::angleChangeBegin), this);
	using FunctionType = decltype(angleChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xd84d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::angleChangeEnded() -> decltype(angleChangeEnded()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::angleChangeEnded), this);
	using FunctionType = decltype(angleChangeEnded())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x95c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::angleChanged(float p0) -> decltype(angleChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::angleChanged), this);
	using FunctionType = decltype(angleChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xd84e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::updateScaleControl() -> decltype(updateScaleControl()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::updateScaleControl), this);
	using FunctionType = decltype(updateScaleControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xcc380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::anchorPointMoved(cocos2d::CCPoint p0) -> decltype(anchorPointMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&EditorUI::anchorPointMoved), this);
	using FunctionType = decltype(anchorPointMoved(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xccc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scaleChangeBegin() -> decltype(scaleChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::scaleChangeBegin), this);
	using FunctionType = decltype(scaleChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0xcc4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::scaleChangeEnded() -> decltype(scaleChangeEnded()) {
	throw std::runtime_error("EditorUI::scaleChangeEnded not implemented");
}

auto EditorUI::scaleXChanged(float p0) -> decltype(scaleXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::scaleXChanged), this);
	using FunctionType = decltype(scaleXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xcc4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scaleYChanged(float p0) -> decltype(scaleYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::scaleYChanged), this);
	using FunctionType = decltype(scaleYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0xcc540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scaleXYChanged(float p0, float p1) -> decltype(scaleXYChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&EditorUI::scaleXYChanged), this);
	using FunctionType = decltype(scaleXYChanged(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0xcc5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditTriggersPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x205550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto EditTriggersPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(EditTriggersPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x205600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditTriggersPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("EditTriggersPopup::determineStartValues not implemented");
}

auto EditTriggersPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("EditTriggersPopup::onClose not implemented");
}

auto EndLevelLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0xe7380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto EndLevelLayer::coinEnterFinished(cocos2d::CCPoint p0) -> decltype(coinEnterFinished(p0)) {
	using FunctionType = decltype(coinEnterFinished(p0))(*)(EndLevelLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xe9720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::coinEnterFinishedO(cocos2d::CCObject* p0) -> decltype(coinEnterFinishedO(p0)) {
	using FunctionType = decltype(coinEnterFinishedO(p0))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe96f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::currencyEnterFinished() -> decltype(currencyEnterFinished()) {
	using FunctionType = decltype(currencyEnterFinished())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xe9cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::diamondEnterFinished() -> decltype(diamondEnterFinished()) {
	using FunctionType = decltype(diamondEnterFinished())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xea0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::getCoinString() -> decltype(getCoinString()) {
	using FunctionType = decltype(getCoinString())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xe8a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::getEndText() -> decltype(getEndText()) {
	using FunctionType = decltype(getEndText())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xea370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::goEdit() -> decltype(goEdit()) {
	using FunctionType = decltype(goEdit())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xe9060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::onEdit(cocos2d::CCObject* sender) -> decltype(onEdit(sender)) {
	using FunctionType = decltype(onEdit(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe8fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::onLevelLeaderboard(cocos2d::CCObject* sender) -> decltype(onLevelLeaderboard(sender)) {
	using FunctionType = decltype(onLevelLeaderboard(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe89f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::onMenu(cocos2d::CCObject* sender) -> decltype(onMenu(sender)) {
	using FunctionType = decltype(onMenu(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe8ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::onReplay(cocos2d::CCObject* sender) -> decltype(onReplay(sender)) {
	using FunctionType = decltype(onReplay(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xe8dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::playCoinEffect(float p0) -> decltype(playCoinEffect(p0)) {
	using FunctionType = decltype(playCoinEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0xe9570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::playCurrencyEffect(float p0) -> decltype(playCurrencyEffect(p0)) {
	using FunctionType = decltype(playCurrencyEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0xe99c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::playDiamondEffect(float p0) -> decltype(playDiamondEffect(p0)) {
	using FunctionType = decltype(playDiamondEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0xe9db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::playEndEffect() -> decltype(playEndEffect()) {
	using FunctionType = decltype(playEndEffect())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xea1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::playStarEffect(float p0) -> decltype(playStarEffect(p0)) {
	using FunctionType = decltype(playStarEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0xe9120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::starEnterFinished() -> decltype(starEnterFinished()) {
	using FunctionType = decltype(starEnterFinished())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xe9440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("EndLevelLayer::keyBackClicked not implemented");
}

auto EndLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EndLevelLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EndLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0xea310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EndLevelLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndLevelLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0xe74f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndLevelLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EndLevelLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(EndLevelLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xe8c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EndLevelLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	throw std::runtime_error("EndLevelLayer::enterAnimFinished not implemented");
}

auto EndLevelLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	throw std::runtime_error("EndLevelLayer::keyUp not implemented");
}

auto EndPortalObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0xeb140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto EndPortalObject::getSpawnPos() -> decltype(getSpawnPos()) {
	using FunctionType = decltype(getSpawnPos())(*)(EndPortalObject*);
	static auto func = wrapFunction(base::get() + 0xeb740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndPortalObject::triggerObject(GJBaseGameLayer* p0) -> decltype(triggerObject(p0)) {
	using FunctionType = decltype(triggerObject(p0))(*)(EndPortalObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xeb6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndPortalObject::updateColors(cocos2d::ccColor3B p0) -> decltype(updateColors(p0)) {
	using FunctionType = decltype(updateColors(p0))(*)(EndPortalObject*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0xeb5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndPortalObject::updateEndPos(bool p0) -> decltype(updateEndPos(p0)) {
	using FunctionType = decltype(updateEndPos(p0))(*)(EndPortalObject*, bool);
	static auto func = wrapFunction(base::get() + 0xeb920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndPortalObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndPortalObject::init), this);
	using FunctionType = decltype(init())(*)(EndPortalObject*);
	static auto func = wrapFunction(base::get() + 0xeb210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndPortalObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	throw std::runtime_error("EndPortalObject::setPosition not implemented");
}

auto EndPortalObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	throw std::runtime_error("EndPortalObject::setVisible not implemented");
}

auto EndTriggerGameObject::init() -> decltype(init()) {
	throw std::runtime_error("EndTriggerGameObject::init not implemented");
}

auto EndTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("EndTriggerGameObject::triggerObject not implemented");
}

auto EndTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("EndTriggerGameObject::customObjectSetup not implemented");
}

auto EndTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("EndTriggerGameObject::getSaveString not implemented");
}

auto EnhancedTriggerObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3a7370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto EnhancedTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("EnhancedTriggerObject::customObjectSetup not implemented");
}

auto EnhancedTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("EnhancedTriggerObject::getSaveString not implemented");
}

auto EnterEffectObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x38e9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto EnterEffectObject::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("EnterEffectObject::customSetup not implemented");
}

auto EnterEffectObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("EnterEffectObject::customObjectSetup not implemented");
}

auto EnterEffectObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("EnterEffectObject::getSaveString not implemented");
}

auto EventLinkTrigger::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3adfa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto EventLinkTrigger::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EventLinkTrigger::init), this);
	using FunctionType = decltype(init())(*)(EventLinkTrigger*);
	static auto func = wrapFunction(base::get() + 0x3ae040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EventLinkTrigger::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("EventLinkTrigger::triggerObject not implemented");
}

auto EventLinkTrigger::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("EventLinkTrigger::customObjectSetup not implemented");
}

auto EventLinkTrigger::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("EventLinkTrigger::getSaveString not implemented");
}

auto ExplodeItemNode::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("ExplodeItemNode::update not implemented");
}

auto ExplodeItemSprite::init() -> decltype(init()) {
	throw std::runtime_error("ExplodeItemSprite::init not implemented");
}

auto ExtendedLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x1f930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ExtendedLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ExtendedLayer::init), this);
	using FunctionType = decltype(init())(*)(ExtendedLayer*);
	static auto func = wrapFunction(base::get() + 0x1f9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ExtendedLayer::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	throw std::runtime_error("ExtendedLayer::setPosition not implemented");
}

auto GManager::saveGMTo(gd::string p0) -> decltype(saveGMTo(p0)) {
	using FunctionType = decltype(saveGMTo(p0))(*)(GManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x47580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GManager::init() -> decltype(init()) {
	throw std::runtime_error("GManager::init not implemented");
}

auto GManager::setup() -> decltype(setup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GManager::setup), this);
	using FunctionType = decltype(setup())(*)(GManager*);
	static auto func = wrapFunction(base::get() + 0x472c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	throw std::runtime_error("GManager::encodeDataTo not implemented");
}

auto GManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	throw std::runtime_error("GManager::dataLoaded not implemented");
}

auto GManager::firstLoad() -> decltype(firstLoad()) {
	throw std::runtime_error("GManager::firstLoad not implemented");
}

auto FileSaveManager::init() -> decltype(init()) {
	throw std::runtime_error("FileSaveManager::init not implemented");
}

auto FileSaveManager::firstLoad() -> decltype(firstLoad()) {
	throw std::runtime_error("FileSaveManager::firstLoad not implemented");
}

auto FindBPMLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x6eee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto FindBPMLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FindBPMLayer*, int);
	static auto func = wrapFunction(base::get() + 0x6ef80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FindBPMLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("FindBPMLayer::onClose not implemented");
}

auto FindBPMLayer::playMusic() -> decltype(playMusic()) {
	throw std::runtime_error("FindBPMLayer::playMusic not implemented");
}

auto FindBPMLayer::registerTouch() -> decltype(registerTouch()) {
	throw std::runtime_error("FindBPMLayer::registerTouch not implemented");
}

auto FindBPMLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	throw std::runtime_error("FindBPMLayer::onInfo not implemented");
}

auto FindBPMLayer::onRecord(cocos2d::CCObject* sender) -> decltype(onRecord(sender)) {
	throw std::runtime_error("FindBPMLayer::onRecord not implemented");
}

auto FindBPMLayer::recordingDidStop() -> decltype(recordingDidStop()) {
	throw std::runtime_error("FindBPMLayer::recordingDidStop not implemented");
}

auto SetIDPopup::create(int p0, int p1, int p2, gd::string p3, gd::string p4, bool p5, int p6, float p7, bool p8, bool p9) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(int, int, int, gd::string, gd::string, bool, int, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x20f840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto SetIDPopup::init(int p0, int p1, int p2, gd::string p3, gd::string p4, bool p5, int p6, float p7, bool p8, bool p9) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(SetIDPopup*, int, int, int, gd::string, gd::string, bool, int, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x20f980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto SetIDPopup::onCancel(cocos2d::CCObject* sender) -> decltype(onCancel(sender)) {
	using FunctionType = decltype(onCancel(sender))(*)(SetIDPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x210410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetIDPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetIDPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x210430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetIDPopup::onItemIDArrow(cocos2d::CCObject* sender) -> decltype(onItemIDArrow(sender)) {
	using FunctionType = decltype(onItemIDArrow(sender))(*)(SetIDPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2101e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetIDPopup::onResetValue(cocos2d::CCObject* sender) -> decltype(onResetValue(sender)) {
	using FunctionType = decltype(onResetValue(sender))(*)(SetIDPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x210240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetIDPopup::updateTextInputLabel() -> decltype(updateTextInputLabel()) {
	using FunctionType = decltype(updateTextInputLabel())(*)(SetIDPopup*);
	static auto func = wrapFunction(base::get() + 0x2102f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetIDPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetIDPopup::keyBackClicked not implemented");
}

auto SetIDPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetIDPopup::show), this);
	using FunctionType = decltype(show())(*)(SetIDPopup*);
	static auto func = wrapFunction(base::get() + 0x2103a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetIDPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetIDPopup::textInputClosed not implemented");
}

auto SetIDPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetIDPopup::textChanged not implemented");
}

auto SetIDPopup::valueChanged() -> decltype(valueChanged()) {
	throw std::runtime_error("SetIDPopup::valueChanged not implemented");
}

auto FindObjectPopup::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x210890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto FindObjectPopup::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindObjectPopup::init), this);
	using FunctionType = decltype(init())(*)(FindObjectPopup*);
	static auto func = wrapFunction(base::get() + 0x210930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FMODAudioEngine::sharedEngine() -> decltype(sharedEngine()) {
	using FunctionType = decltype(sharedEngine())(*)();
	static auto func = wrapFunction(base::get() + 0x32bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto FMODAudioEngine::clearAllAudio() -> decltype(clearAllAudio()) {
	using FunctionType = decltype(clearAllAudio())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x338a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::createStream(gd::string p0) -> decltype(createStream(p0)) {
	using FunctionType = decltype(createStream(p0))(*)(FMODAudioEngine*, gd::string);
	static auto func = wrapFunction(base::get() + 0x3aea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::fadeInMusic(float p0, int p1) -> decltype(fadeInMusic(p0, p1)) {
	using FunctionType = decltype(fadeInMusic(p0, p1))(*)(FMODAudioEngine*, float, int);
	static auto func = wrapFunction(base::get() + 0x3a740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FMODAudioEngine::getActiveMusic(int p0) -> decltype(getActiveMusic(p0)) {
	using FunctionType = decltype(getActiveMusic(p0))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x3a940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::getChannelGroup(int p0, bool p1) -> decltype(getChannelGroup(p0, p1)) {
	using FunctionType = decltype(getChannelGroup(p0, p1))(*)(FMODAudioEngine*, int, bool);
	static auto func = wrapFunction(base::get() + 0x35240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FMODAudioEngine::getFMODStatus(int p0) -> decltype(getFMODStatus(p0)) {
	using FunctionType = decltype(getFMODStatus(p0))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x3b0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::getMusicLengthMS(int p0) -> decltype(getMusicLengthMS(p0)) {
	using FunctionType = decltype(getMusicLengthMS(p0))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x3a570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::isMusicPlaying(gd::string p0, int p1) -> decltype(isMusicPlaying(p0, p1)) {
	using FunctionType = decltype(isMusicPlaying(p0, p1))(*)(FMODAudioEngine*, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x383e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FMODAudioEngine::loadAudioState(FMODAudioState& p0) -> decltype(loadAudioState(p0)) {
	using FunctionType = decltype(loadAudioState(p0))(*)(FMODAudioEngine*, FMODAudioState&);
	static auto func = wrapFunction(base::get() + 0x34000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::loadMusic(gd::string p0, float p1, float p2, float p3, bool p4, int p5, int p6) -> decltype(loadMusic(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(loadMusic(p0, p1, p2, p3, p4, p5, p6))(*)(FMODAudioEngine*, gd::string, float, float, float, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x38740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto FMODAudioEngine::loadMusic(gd::string p0) -> decltype(loadMusic(p0)) {
	using FunctionType = decltype(loadMusic(p0))(*)(FMODAudioEngine*, gd::string);
	static auto func = wrapFunction(base::get() + 0x386a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::pauseAllMusic() -> decltype(pauseAllMusic()) {
	using FunctionType = decltype(pauseAllMusic())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x38350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::pitchForIdx(int p0) -> decltype(pitchForIdx(p0)) {
	using FunctionType = decltype(pitchForIdx(p0))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x350e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::playEffect(gd::string p0, float p1, float p2, float p3) -> decltype(playEffect(p0, p1, p2, p3)) {
	using FunctionType = decltype(playEffect(p0, p1, p2, p3))(*)(FMODAudioEngine*, gd::string, float, float, float);
	static auto func = wrapFunction(base::get() + 0x356e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto FMODAudioEngine::playEffect(gd::string p0) -> decltype(playEffect(p0)) {
	using FunctionType = decltype(playEffect(p0))(*)(FMODAudioEngine*, gd::string);
	static auto func = wrapFunction(base::get() + 0x35590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::playEffectAdvanced(gd::string p0, float p1, float p2, float p3, float p4, bool p5, bool p6, int p7, int p8, int p9, int p10, bool p11, int p12, bool p13, bool p14, int p15, int p16, float p17, int p18) -> decltype(playEffectAdvanced(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18)) {
	using FunctionType = decltype(playEffectAdvanced(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18))(*)(FMODAudioEngine*, gd::string, float, float, float, float, bool, bool, int, int, int, int, bool, int, bool, bool, int, int, float, int);
	static auto func = wrapFunction(base::get() + 0x357b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18);
}

auto FMODAudioEngine::playEffectAsync(gd::string p0) -> decltype(playEffectAsync(p0)) {
	using FunctionType = decltype(playEffectAsync(p0))(*)(FMODAudioEngine*, gd::string);
	static auto func = wrapFunction(base::get() + 0x35620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::playMusic(gd::string p0, bool p1, float p2, int p3) -> decltype(playMusic(p0, p1, p2, p3)) {
	using FunctionType = decltype(playMusic(p0, p1, p2, p3))(*)(FMODAudioEngine*, gd::string, bool, float, int);
	static auto func = wrapFunction(base::get() + 0x385b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto FMODAudioEngine::preloadEffect(gd::string p0) -> decltype(preloadEffect(p0)) {
	using FunctionType = decltype(preloadEffect(p0))(*)(FMODAudioEngine*, gd::string);
	static auto func = wrapFunction(base::get() + 0x37a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::queuedEffectFinishedLoading(gd::string p0) -> decltype(queuedEffectFinishedLoading(p0)) {
	using FunctionType = decltype(queuedEffectFinishedLoading(p0))(*)(FMODAudioEngine*, gd::string);
	static auto func = wrapFunction(base::get() + 0x391f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::queuePlayEffect(gd::string p0, float p1, float p2, float p3, float p4, bool p5, bool p6, int p7, int p8, int p9, int p10, bool p11, int p12, bool p13, int p14, float p15, int p16) -> decltype(queuePlayEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16)) {
	using FunctionType = decltype(queuePlayEffect(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16))(*)(FMODAudioEngine*, gd::string, float, float, float, float, bool, bool, int, int, int, int, bool, int, bool, int, float, int);
	static auto func = wrapFunction(base::get() + 0x4361f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16);
}

auto FMODAudioEngine::registerChannel(FMOD::Channel* p0, int p1, int p2) -> decltype(registerChannel(p0, p1, p2)) {
	using FunctionType = decltype(registerChannel(p0, p1, p2))(*)(FMODAudioEngine*, FMOD::Channel*, int, int);
	static auto func = wrapFunction(base::get() + 0x36410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODAudioEngine::resumeAllMusic() -> decltype(resumeAllMusic()) {
	using FunctionType = decltype(resumeAllMusic())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x383a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::saveAudioState(FMODAudioState& p0) -> decltype(saveAudioState(p0)) {
	using FunctionType = decltype(saveAudioState(p0))(*)(FMODAudioEngine*, FMODAudioState&);
	static auto func = wrapFunction(base::get() + 0x33b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::setChannelPitch(int p0, AudioTargetType p1, float p2) -> decltype(setChannelPitch(p0, p1, p2)) {
	using FunctionType = decltype(setChannelPitch(p0, p1, p2))(*)(FMODAudioEngine*, int, AudioTargetType, float);
	static auto func = wrapFunction(base::get() + 0x378b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODAudioEngine::setChannelVolume(int p0, AudioTargetType p1, float p2) -> decltype(setChannelVolume(p0, p1, p2)) {
	using FunctionType = decltype(setChannelVolume(p0, p1, p2))(*)(FMODAudioEngine*, int, AudioTargetType, float);
	static auto func = wrapFunction(base::get() + 0x373b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODAudioEngine::setChannelVolumeMod(int p0, AudioTargetType p1, float p2) -> decltype(setChannelVolumeMod(p0, p1, p2)) {
	using FunctionType = decltype(setChannelVolumeMod(p0, p1, p2))(*)(FMODAudioEngine*, int, AudioTargetType, float);
	static auto func = wrapFunction(base::get() + 0x37630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODAudioEngine::setMusicTimeMS(unsigned int p0, bool p1, int p2) -> decltype(setMusicTimeMS(p0, p1, p2)) {
	using FunctionType = decltype(setMusicTimeMS(p0, p1, p2))(*)(FMODAudioEngine*, unsigned int, bool, int);
	static auto func = wrapFunction(base::get() + 0x3a3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODAudioEngine::setup() -> decltype(setup()) {
	using FunctionType = decltype(setup())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x32c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::setupAudioEngine() -> decltype(setupAudioEngine()) {
	using FunctionType = decltype(setupAudioEngine())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x32f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::start() -> decltype(start()) {
	using FunctionType = decltype(start())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x33830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::startMusic(int p0, int p1, int p2, int p3, bool p4, int p5) -> decltype(startMusic(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(startMusic(p0, p1, p2, p3, p4, p5))(*)(FMODAudioEngine*, int, int, int, int, bool, int);
	static auto func = wrapFunction(base::get() + 0x38b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto FMODAudioEngine::stopAllEffects() -> decltype(stopAllEffects()) {
	using FunctionType = decltype(stopAllEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x37f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::stopAllMusic() -> decltype(stopAllMusic()) {
	using FunctionType = decltype(stopAllMusic())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x38310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::storeEffect(FMOD::Sound* p0, gd::string p1) -> decltype(storeEffect(p0, p1)) {
	using FunctionType = decltype(storeEffect(p0, p1))(*)(FMODAudioEngine*, FMOD::Sound*, gd::string);
	static auto func = wrapFunction(base::get() + 0x37c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FMODAudioEngine::triggerQueuedMusic(FMODQueuedMusic p0) -> decltype(triggerQueuedMusic(p0)) {
	using FunctionType = decltype(triggerQueuedMusic(p0))(*)(FMODAudioEngine*, FMODQueuedMusic);
	static auto func = wrapFunction(base::get() + 0x39800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::unloadAllEffects() -> decltype(unloadAllEffects()) {
	using FunctionType = decltype(unloadAllEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x38130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::updateChannel(int p0, AudioTargetType p1, AudioModType p2, float p3, float p4) -> decltype(updateChannel(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(updateChannel(p0, p1, p2, p3, p4))(*)(FMODAudioEngine*, int, AudioTargetType, AudioModType, float, float);
	static auto func = wrapFunction(base::get() + 0x37200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto FMODAudioEngine::updateChannelTweens(float p0) -> decltype(updateChannelTweens(p0)) {
	using FunctionType = decltype(updateChannelTweens(p0))(*)(FMODAudioEngine*, float);
	static auto func = wrapFunction(base::get() + 0x34dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::updateQueuedEffects() -> decltype(updateQueuedEffects()) {
	using FunctionType = decltype(updateQueuedEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x39120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::updateReverb(FMODReverbPreset p0, bool p1) -> decltype(updateReverb(p0, p1)) {
	using FunctionType = decltype(updateReverb(p0, p1))(*)(FMODAudioEngine*, FMODReverbPreset, bool);
	static auto func = wrapFunction(base::get() + 0x33220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FMODAudioEngine::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&FMODAudioEngine::update), this);
	using FunctionType = decltype(update(p0))(*)(FMODAudioEngine*, float);
	static auto func = wrapFunction(base::get() + 0x33980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FMODLevelVisualizer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2129f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto FMODLevelVisualizer::updateVisualizer(float p0, float p1, float p2) -> decltype(updateVisualizer(p0, p1, p2)) {
	using FunctionType = decltype(updateVisualizer(p0, p1, p2))(*)(FMODLevelVisualizer*, float, float, float);
	static auto func = wrapFunction(base::get() + 0x212e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODLevelVisualizer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FMODLevelVisualizer::init), this);
	using FunctionType = decltype(init())(*)(FMODLevelVisualizer*);
	static auto func = wrapFunction(base::get() + 0x212aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameRateDelegate::updateRate() -> decltype(updateRate()) {
	throw std::runtime_error("GameRateDelegate::updateRate not implemented");
}

auto RewardedVideoDelegate::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	throw std::runtime_error("RewardedVideoDelegate::rewardedVideoFinished not implemented");
}

auto RewardedVideoDelegate::shouldOffsetRewardCurrency() -> decltype(shouldOffsetRewardCurrency()) {
	throw std::runtime_error("RewardedVideoDelegate::shouldOffsetRewardCurrency not implemented");
}

auto FollowRewardPage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0xed030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto FollowRewardPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::init), this);
	using FunctionType = decltype(init())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0xed0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("FollowRewardPage::registerWithTouchDispatcher not implemented");
}

auto FollowRewardPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("FollowRewardPage::keyBackClicked not implemented");
}

auto FollowRewardPage::show() -> decltype(show()) {
	throw std::runtime_error("FollowRewardPage::show not implemented");
}

auto FollowRewardPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("FollowRewardPage::FLAlert_Clicked not implemented");
}

auto FollowRewardPage::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	throw std::runtime_error("FollowRewardPage::rewardedVideoFinished not implemented");
}

auto FollowRewardPage::updateRate() -> decltype(updateRate()) {
	throw std::runtime_error("FollowRewardPage::updateRate not implemented");
}

auto ForceBlockGameObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3b6c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto ForceBlockGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("ForceBlockGameObject::customObjectSetup not implemented");
}

auto ForceBlockGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("ForceBlockGameObject::getSaveString not implemented");
}

auto FriendRequestDelegate::loadFRequestsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadFRequestsFinished(p0, p1)) {
	throw std::runtime_error("FriendRequestDelegate::loadFRequestsFinished not implemented");
}

auto FriendRequestDelegate::loadFRequestsFailed(char const* p0, GJErrorCode p1) -> decltype(loadFRequestsFailed(p0, p1)) {
	throw std::runtime_error("FriendRequestDelegate::loadFRequestsFailed not implemented");
}

auto FriendRequestDelegate::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	throw std::runtime_error("FriendRequestDelegate::setupPageInfo not implemented");
}

auto FriendRequestDelegate::forceReloadRequests(bool p0) -> decltype(forceReloadRequests(p0)) {
	throw std::runtime_error("FriendRequestDelegate::forceReloadRequests not implemented");
}

auto FRequestProfilePage::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0xeeee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto FRequestProfilePage::deleteSelected() -> decltype(deleteSelected()) {
	using FunctionType = decltype(deleteSelected())(*)(FRequestProfilePage*);
	static auto func = wrapFunction(base::get() + 0xefb90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FRequestProfilePage::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FRequestProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0xeef90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FRequestProfilePage::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(FRequestProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0xf00d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FRequestProfilePage::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(FRequestProfilePage*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0xf0320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FRequestProfilePage::untoggleAll() -> decltype(untoggleAll()) {
	using FunctionType = decltype(untoggleAll())(*)(FRequestProfilePage*);
	static auto func = wrapFunction(base::get() + 0xefe50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FRequestProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("FRequestProfilePage::registerWithTouchDispatcher not implemented");
}

auto FRequestProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("FRequestProfilePage::keyBackClicked not implemented");
}

auto FRequestProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("FRequestProfilePage::FLAlert_Clicked not implemented");
}

auto FRequestProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("FRequestProfilePage::onClosePopup not implemented");
}

auto FRequestProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("FRequestProfilePage::uploadActionFinished not implemented");
}

auto FRequestProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("FRequestProfilePage::uploadActionFailed not implemented");
}

auto FRequestProfilePage::loadFRequestsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadFRequestsFinished(p0, p1)) {
	throw std::runtime_error("FRequestProfilePage::loadFRequestsFinished not implemented");
}

auto FRequestProfilePage::loadFRequestsFailed(char const* p0, GJErrorCode p1) -> decltype(loadFRequestsFailed(p0, p1)) {
	throw std::runtime_error("FRequestProfilePage::loadFRequestsFailed not implemented");
}

auto FRequestProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	throw std::runtime_error("FRequestProfilePage::setupPageInfo not implemented");
}

auto FRequestProfilePage::forceReloadRequests(bool p0) -> decltype(forceReloadRequests(p0)) {
	throw std::runtime_error("FRequestProfilePage::forceReloadRequests not implemented");
}

auto FriendRequestPopup::create(GJFriendRequest* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJFriendRequest*);
	static auto func = wrapFunction(base::get() + 0x20b440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto FriendRequestPopup::init(GJFriendRequest* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FriendRequestPopup*, GJFriendRequest*);
	static auto func = wrapFunction(base::get() + 0x20b4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FriendRequestPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("FriendRequestPopup::keyBackClicked not implemented");
}

auto FriendRequestPopup::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("FriendRequestPopup::uploadActionFinished not implemented");
}

auto FriendRequestPopup::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("FriendRequestPopup::uploadActionFailed not implemented");
}

auto FriendRequestPopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("FriendRequestPopup::onClosePopup not implemented");
}

auto FriendRequestPopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("FriendRequestPopup::FLAlert_Clicked not implemented");
}

auto UserListDelegate::getUserListFinished(cocos2d::CCArray* p0, UserListType p1) -> decltype(getUserListFinished(p0, p1)) {
	throw std::runtime_error("UserListDelegate::getUserListFinished not implemented");
}

auto UserListDelegate::getUserListFailed(UserListType p0, GJErrorCode p1) -> decltype(getUserListFailed(p0, p1)) {
	throw std::runtime_error("UserListDelegate::getUserListFailed not implemented");
}

auto UserListDelegate::userListChanged(cocos2d::CCArray* p0, UserListType p1) -> decltype(userListChanged(p0, p1)) {
	throw std::runtime_error("UserListDelegate::userListChanged not implemented");
}

auto UserListDelegate::forceReloadList(UserListType p0) -> decltype(forceReloadList(p0)) {
	throw std::runtime_error("UserListDelegate::forceReloadList not implemented");
}

auto FriendsProfilePage::create(UserListType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(UserListType);
	static auto func = wrapFunction(base::get() + 0xf0960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto FriendsProfilePage::init(UserListType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FriendsProfilePage*, UserListType);
	static auto func = wrapFunction(base::get() + 0xf0a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FriendsProfilePage::onBlocked(cocos2d::CCObject* sender) -> decltype(onBlocked(sender)) {
	using FunctionType = decltype(onBlocked(sender))(*)(FriendsProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xf1630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FriendsProfilePage::setupUsersBrowser(cocos2d::CCArray* p0, UserListType p1) -> decltype(setupUsersBrowser(p0, p1)) {
	using FunctionType = decltype(setupUsersBrowser(p0, p1))(*)(FriendsProfilePage*, cocos2d::CCArray*, UserListType);
	static auto func = wrapFunction(base::get() + 0xf1090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FriendsProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("FriendsProfilePage::registerWithTouchDispatcher not implemented");
}

auto FriendsProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("FriendsProfilePage::keyBackClicked not implemented");
}

auto FriendsProfilePage::getUserListFinished(cocos2d::CCArray* p0, UserListType p1) -> decltype(getUserListFinished(p0, p1)) {
	throw std::runtime_error("FriendsProfilePage::getUserListFinished not implemented");
}

auto FriendsProfilePage::getUserListFailed(UserListType p0, GJErrorCode p1) -> decltype(getUserListFailed(p0, p1)) {
	throw std::runtime_error("FriendsProfilePage::getUserListFailed not implemented");
}

auto FriendsProfilePage::userListChanged(cocos2d::CCArray* p0, UserListType p1) -> decltype(userListChanged(p0, p1)) {
	throw std::runtime_error("FriendsProfilePage::userListChanged not implemented");
}

auto FriendsProfilePage::forceReloadList(UserListType p0) -> decltype(forceReloadList(p0)) {
	throw std::runtime_error("FriendsProfilePage::forceReloadList not implemented");
}

auto GameCell::init() -> decltype(init()) {
	throw std::runtime_error("GameCell::init not implemented");
}

auto GameCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GameCell::draw not implemented");
}

auto GameLevelManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0xf3a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

GameLevelManager* GameLevelManager::get() {
		return GameLevelManager::sharedState();
	}

auto GameLevelManager::acceptFriendRequest(int p0, int p1) -> decltype(acceptFriendRequest(p0, p1)) {
	using FunctionType = decltype(acceptFriendRequest(p0, p1))(*)(GameLevelManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x10be70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::addDLToActive(char const* p0) -> decltype(addDLToActive(p0)) {
	using FunctionType = decltype(addDLToActive(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0xf8c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::blockUser(int p0) -> decltype(blockUser(p0)) {
	using FunctionType = decltype(blockUser(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x10ca10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::cleanupDailyLevels() -> decltype(cleanupDailyLevels()) {
	using FunctionType = decltype(cleanupDailyLevels())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xf96a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::createAndGetMapPacks(gd::string p0) -> decltype(createAndGetMapPacks(p0)) {
	using FunctionType = decltype(createAndGetMapPacks(p0))(*)(GameLevelManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0xf6e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::createNewLevel() -> decltype(createNewLevel()) {
	using FunctionType = decltype(createNewLevel())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xf5130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::createNewLevelList() -> decltype(createNewLevelList()) {
	using FunctionType = decltype(createNewLevelList())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xf5ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::createPageInfo(int p0, int p1, int p2) -> decltype(createPageInfo(p0, p1, p2)) {
	using FunctionType = decltype(createPageInfo(p0, p1, p2))(*)(GameLevelManager*, int, int, int);
	static auto func = wrapFunction(base::get() + 0xf8ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::deleteComment(int p0, CommentType p1, int p2) -> decltype(deleteComment(p0, p1, p2)) {
	using FunctionType = decltype(deleteComment(p0, p1, p2))(*)(GameLevelManager*, int, CommentType, int);
	static auto func = wrapFunction(base::get() + 0x10a920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::deleteFriendRequests(int p0, cocos2d::CCArray* p1, bool p2) -> decltype(deleteFriendRequests(p0, p1, p2)) {
	using FunctionType = decltype(deleteFriendRequests(p0, p1, p2))(*)(GameLevelManager*, int, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x10b8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::deleteLevel(GJGameLevel* p0) -> decltype(deleteLevel(p0)) {
	using FunctionType = decltype(deleteLevel(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0xf58b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::deleteServerLevel(int p0) -> decltype(deleteServerLevel(p0)) {
	using FunctionType = decltype(deleteServerLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x102990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::deleteServerLevelList(int p0) -> decltype(deleteServerLevelList(p0)) {
	using FunctionType = decltype(deleteServerLevelList(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0xff440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::deleteUserMessages(GJUserMessage* message, cocos2d::CCArray* messages, bool isSender) -> decltype(deleteUserMessages(message, messages, isSender)) {
	using FunctionType = decltype(deleteUserMessages(message, messages, isSender))(*)(GameLevelManager*, GJUserMessage*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x107880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, message, messages, isSender);
}

auto GameLevelManager::downloadLevel(int p0, bool p1) -> decltype(downloadLevel(p0, p1)) {
	using FunctionType = decltype(downloadLevel(p0, p1))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x100c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::downloadUserMessage(int p0, bool p1) -> decltype(downloadUserMessage(p0, p1)) {
	using FunctionType = decltype(downloadUserMessage(p0, p1))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x107070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	using FunctionType = decltype(encodeDataTo(p0))(*)(GameLevelManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0xfa200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::firstSetup() -> decltype(firstSetup()) {
	using FunctionType = decltype(firstSetup())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x39e930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::followUser(int p0) -> decltype(followUser(p0)) {
	using FunctionType = decltype(followUser(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0xf99f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getAccountComments(int accountID, int page, int total) -> decltype(getAccountComments(accountID, page, total)) {
	using FunctionType = decltype(getAccountComments(accountID, page, total))(*)(GameLevelManager*, int, int, int);
	static auto func = wrapFunction(base::get() + 0x108720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, accountID, page, total);
}

auto GameLevelManager::getBasePostString() -> decltype(getBasePostString()) {
	using FunctionType = decltype(getBasePostString())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xfb5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getBoolForKey(char const* p0) -> decltype(getBoolForKey(p0)) {
	using FunctionType = decltype(getBoolForKey(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x111d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getCommentKey(int ID, int page, int mode, CommentKeyType keytype) -> decltype(getCommentKey(ID, page, mode, keytype)) {
	using FunctionType = decltype(getCommentKey(ID, page, mode, keytype))(*)(GameLevelManager*, int, int, int, CommentKeyType);
	static auto func = wrapFunction(base::get() + 0x1091d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, ID, page, mode, keytype);
}

auto GameLevelManager::getCompletedLevels(bool p0) -> decltype(getCompletedLevels(p0)) {
	using FunctionType = decltype(getCompletedLevels(p0))(*)(GameLevelManager*, bool);
	static auto func = wrapFunction(base::get() + 0xf7790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getFriendRequests(bool p0, int p1, int p2) -> decltype(getFriendRequests(p0, p1, p2)) {
	using FunctionType = decltype(getFriendRequests(p0, p1, p2))(*)(GameLevelManager*, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x10ae30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::getGauntletLevels(int p0) -> decltype(getGauntletLevels(p0)) {
	using FunctionType = decltype(getGauntletLevels(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x100860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getGauntlets() -> decltype(getGauntlets()) {
	using FunctionType = decltype(getGauntlets())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x100100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getGauntletSearchKey(int p0) -> decltype(getGauntletSearchKey(p0)) {
	using FunctionType = decltype(getGauntletSearchKey(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x100080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getGJChallenges() -> decltype(getGJChallenges()) {
	using FunctionType = decltype(getGJChallenges())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x10fd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getGJDailyLevelState(GJTimedLevelType p0) -> decltype(getGJDailyLevelState(p0)) {
	using FunctionType = decltype(getGJDailyLevelState(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x110670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getGJRewards(int p0) -> decltype(getGJRewards(p0)) {
	using FunctionType = decltype(getGJRewards(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x10f140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getGJUserInfo(int p0) -> decltype(getGJUserInfo(p0)) {
	using FunctionType = decltype(getGJUserInfo(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x106790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getHighestLevelOrder() -> decltype(getHighestLevelOrder()) {
	using FunctionType = decltype(getHighestLevelOrder())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xf7550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getLeaderboardScores(char const* p0) -> decltype(getLeaderboardScores(p0)) {
	using FunctionType = decltype(getLeaderboardScores(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x104c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getLevelComments(int ID, int page, int total, int mode, CommentKeyType keytype) -> decltype(getLevelComments(ID, page, total, mode, keytype)) {
	using FunctionType = decltype(getLevelComments(ID, page, total, mode, keytype))(*)(GameLevelManager*, int, int, int, int, CommentKeyType);
	static auto func = wrapFunction(base::get() + 0x108160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, ID, page, total, mode, keytype);
}

const char* GameLevelManager::getLevelDownloadKey(int levelID, bool isGauntlet) {
	    return cocos2d::CCString::createWithFormat("%i_%i", levelID, isGauntlet)->getCString();
	}

auto GameLevelManager::getLevelLeaderboard(GJGameLevel* p0, LevelLeaderboardType p1, LevelLeaderboardMode p2) -> decltype(getLevelLeaderboard(p0, p1, p2)) {
	using FunctionType = decltype(getLevelLeaderboard(p0, p1, p2))(*)(GameLevelManager*, GJGameLevel*, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x1053a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::getLevelLists(GJSearchObject* p0) -> decltype(getLevelLists(p0)) {
	using FunctionType = decltype(getLevelLists(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0xff800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getLevelSaveData() -> decltype(getLevelSaveData()) {
	using FunctionType = decltype(getLevelSaveData())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xfdd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getLowestLevelOrder() -> decltype(getLowestLevelOrder()) {
	using FunctionType = decltype(getLowestLevelOrder())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xf75a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getMainLevel(int p0, bool p1) -> decltype(getMainLevel(p0, p1)) {
	using FunctionType = decltype(getMainLevel(p0, p1))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0xf4d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getMapPacks(GJSearchObject* p0) -> decltype(getMapPacks(p0)) {
	using FunctionType = decltype(getMapPacks(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0xfe120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getNextFreeTemplateID() -> decltype(getNextFreeTemplateID()) {
	using FunctionType = decltype(getNextFreeTemplateID())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xf9e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getOnlineLevels(GJSearchObject* p0) -> decltype(getOnlineLevels(p0)) {
	using FunctionType = decltype(getOnlineLevels(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0xfccb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getPageInfo(char const* p0) -> decltype(getPageInfo(p0)) {
	using FunctionType = decltype(getPageInfo(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0xf89e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedDailyLevel(int p0) -> decltype(getSavedDailyLevel(p0)) {
	using FunctionType = decltype(getSavedDailyLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0xf7f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedGauntlet(int p0) -> decltype(getSavedGauntlet(p0)) {
	using FunctionType = decltype(getSavedGauntlet(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x100a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedGauntletLevel(int p0) -> decltype(getSavedGauntletLevel(p0)) {
	using FunctionType = decltype(getSavedGauntletLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0xf8060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedLevel(GJGameLevel* p0) -> decltype(getSavedLevel(p0)) {
	using FunctionType = decltype(getSavedLevel(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0xf7df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedLevel(int p0) -> decltype(getSavedLevel(p0)) {
	using FunctionType = decltype(getSavedLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0xf7e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedLevels(bool p0, int p1) -> decltype(getSavedLevels(p0, p1)) {
	using FunctionType = decltype(getSavedLevels(p0, p1))(*)(GameLevelManager*, bool, int);
	static auto func = wrapFunction(base::get() + 0xf7340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getSplitIntFromKey(char const* p0, int p1) -> decltype(getSplitIntFromKey(p0, p1)) {
	using FunctionType = decltype(getSplitIntFromKey(p0, p1))(*)(GameLevelManager*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x109250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getStoredLevelComments(char const* p0) -> decltype(getStoredLevelComments(p0)) {
	using FunctionType = decltype(getStoredLevelComments(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1098a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getStoredOnlineLevels(char const* p0) -> decltype(getStoredOnlineLevels(p0)) {
	using FunctionType = decltype(getStoredOnlineLevels(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0xf8930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getStoredUserList(UserListType p0) -> decltype(getStoredUserList(p0)) {
	using FunctionType = decltype(getStoredUserList(p0))(*)(GameLevelManager*, UserListType);
	static auto func = wrapFunction(base::get() + 0x10d820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getTimeLeft(char const* p0, float p1) -> decltype(getTimeLeft(p0, p1)) {
	using FunctionType = decltype(getTimeLeft(p0, p1))(*)(GameLevelManager*, char const*, float);
	static auto func = wrapFunction(base::get() + 0xf8fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getTopArtists(int page, int total) -> decltype(getTopArtists(page, total)) {
	using FunctionType = decltype(getTopArtists(page, total))(*)(GameLevelManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x105d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, page, total);
}

const char* GameLevelManager::getTopArtistsKey(int page) {
	    return cocos2d::CCString::createWithFormat("topArtists_%i", page)->getCString();
	}

auto GameLevelManager::getUserList(UserListType p0) -> decltype(getUserList(p0)) {
	using FunctionType = decltype(getUserList(p0))(*)(GameLevelManager*, UserListType);
	static auto func = wrapFunction(base::get() + 0x10d2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getUserMessages(bool p0, int p1, int p2) -> decltype(getUserMessages(p0, p1, p2)) {
	using FunctionType = decltype(getUserMessages(p0, p1, p2))(*)(GameLevelManager*, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x106ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::getUsers(GJSearchObject* p0) -> decltype(getUsers(p0)) {
	using FunctionType = decltype(getUsers(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x106320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::handleIt(bool p0, gd::string p1, gd::string p2, GJHttpType p3) -> decltype(handleIt(p0, p1, p2, p3)) {
	using FunctionType = decltype(handleIt(p0, p1, p2, p3))(*)(GameLevelManager*, bool, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0xf3e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::hasLikedItem(LikeItemType p0, int p1, bool p2, int p3) -> decltype(hasLikedItem(p0, p1, p2, p3)) {
	using FunctionType = decltype(hasLikedItem(p0, p1, p2, p3))(*)(GameLevelManager*, LikeItemType, int, bool, int);
	static auto func = wrapFunction(base::get() + 0x10ed90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::hasLikedItemFullCheck(LikeItemType p0, int p1, int p2) -> decltype(hasLikedItemFullCheck(p0, p1, p2)) {
	using FunctionType = decltype(hasLikedItemFullCheck(p0, p1, p2))(*)(GameLevelManager*, LikeItemType, int, int);
	static auto func = wrapFunction(base::get() + 0x10ed10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::invalidateMessages(bool p0, bool p1) -> decltype(invalidateMessages(p0, p1)) {
	using FunctionType = decltype(invalidateMessages(p0, p1))(*)(GameLevelManager*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x107ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::invalidateRequests(bool p0, bool p1) -> decltype(invalidateRequests(p0, p1)) {
	using FunctionType = decltype(invalidateRequests(p0, p1))(*)(GameLevelManager*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x10db50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::isDLActive(char const* tag) -> decltype(isDLActive(tag)) {
	using FunctionType = decltype(isDLActive(tag))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0xf8b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, tag);
}

auto GameLevelManager::isFollowingUser(int p0) -> decltype(isFollowingUser(p0)) {
	using FunctionType = decltype(isFollowingUser(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0xf9910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::isTimeValid(char const* p0, float p1) -> decltype(isTimeValid(p0, p1)) {
	using FunctionType = decltype(isTimeValid(p0, p1))(*)(GameLevelManager*, char const*, float);
	static auto func = wrapFunction(base::get() + 0xf8e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::levelIDFromCommentKey(char const* p0) -> decltype(levelIDFromCommentKey(p0)) {
	using FunctionType = decltype(levelIDFromCommentKey(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x109430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::likeItem(LikeItemType p0, int p1, bool p2, int p3) -> decltype(likeItem(p0, p1, p2, p3)) {
	using FunctionType = decltype(likeItem(p0, p1, p2, p3))(*)(GameLevelManager*, LikeItemType, int, bool, int);
	static auto func = wrapFunction(base::get() + 0x10e100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::limitSavedLevels() -> decltype(limitSavedLevels()) {
	using FunctionType = decltype(limitSavedLevels())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xf9210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::makeTimeStamp(char const* p0) -> decltype(makeTimeStamp(p0)) {
	using FunctionType = decltype(makeTimeStamp(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0xf8d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::markItemAsLiked(LikeItemType p0, int p1, bool p2, int p3) -> decltype(markItemAsLiked(p0, p1, p2, p3)) {
	using FunctionType = decltype(markItemAsLiked(p0, p1, p2, p3))(*)(GameLevelManager*, LikeItemType, int, bool, int);
	static auto func = wrapFunction(base::get() + 0x10eba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::markLevelAsRatedStars(int p0) -> decltype(markLevelAsRatedStars(p0)) {
	using FunctionType = decltype(markLevelAsRatedStars(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x102590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::onAcceptFriendRequestCompleted(gd::string response, gd::string tag) -> decltype(onAcceptFriendRequestCompleted(response, tag)) {
	using FunctionType = decltype(onAcceptFriendRequestCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10c080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onBanUserCompleted(gd::string response, gd::string tag) -> decltype(onBanUserCompleted(response, tag)) {
	using FunctionType = decltype(onBanUserCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x102db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onBlockUserCompleted(gd::string response, gd::string tag) -> decltype(onBlockUserCompleted(response, tag)) {
	using FunctionType = decltype(onBlockUserCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10cc20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onDeleteCommentCompleted(gd::string response, gd::string tag) -> decltype(onDeleteCommentCompleted(response, tag)) {
	using FunctionType = decltype(onDeleteCommentCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10ac70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onDeleteFriendRequestCompleted(gd::string response, gd::string tag) -> decltype(onDeleteFriendRequestCompleted(response, tag)) {
	using FunctionType = decltype(onDeleteFriendRequestCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10bc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onDeleteServerLevelCompleted(gd::string response, gd::string tag) -> decltype(onDeleteServerLevelCompleted(response, tag)) {
	using FunctionType = decltype(onDeleteServerLevelCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x102c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onDeleteServerLevelListCompleted(gd::string response, gd::string tag) -> decltype(onDeleteServerLevelListCompleted(response, tag)) {
	using FunctionType = decltype(onDeleteServerLevelListCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0xff690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onDeleteUserMessagesCompleted(gd::string response, gd::string tag) -> decltype(onDeleteUserMessagesCompleted(response, tag)) {
	using FunctionType = decltype(onDeleteUserMessagesCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x107c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onDownloadLevelCompleted(gd::string response, gd::string tag) -> decltype(onDownloadLevelCompleted(response, tag)) {
	using FunctionType = decltype(onDownloadLevelCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x101090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onDownloadUserMessageCompleted(gd::string response, gd::string tag) -> decltype(onDownloadUserMessageCompleted(response, tag)) {
	using FunctionType = decltype(onDownloadUserMessageCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1071e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetAccountCommentsCompleted(gd::string response, gd::string tag) -> decltype(onGetAccountCommentsCompleted(response, tag)) {
	using FunctionType = decltype(onGetAccountCommentsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x108890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetFriendRequestsCompleted(gd::string response, gd::string tag) -> decltype(onGetFriendRequestsCompleted(response, tag)) {
	using FunctionType = decltype(onGetFriendRequestsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10afb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetGauntletsCompleted(gd::string response, gd::string tag) -> decltype(onGetGauntletsCompleted(response, tag)) {
	using FunctionType = decltype(onGetGauntletsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x100260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetGJChallengesCompleted(gd::string response, gd::string tag) -> decltype(onGetGJChallengesCompleted(response, tag)) {
	using FunctionType = decltype(onGetGJChallengesCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10ffc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetGJDailyLevelStateCompleted(gd::string response, gd::string tag) -> decltype(onGetGJDailyLevelStateCompleted(response, tag)) {
	using FunctionType = decltype(onGetGJDailyLevelStateCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x110870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetGJRewardsCompleted(gd::string response, gd::string tag) -> decltype(onGetGJRewardsCompleted(response, tag)) {
	using FunctionType = decltype(onGetGJRewardsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10f6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetGJUserInfoCompleted(gd::string response, gd::string tag) -> decltype(onGetGJUserInfoCompleted(response, tag)) {
	using FunctionType = decltype(onGetGJUserInfoCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1068f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetLeaderboardScoresCompleted(gd::string response, gd::string tag) -> decltype(onGetLeaderboardScoresCompleted(response, tag)) {
	using FunctionType = decltype(onGetLeaderboardScoresCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x105050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetLevelCommentsCompleted(gd::string response, gd::string tag) -> decltype(onGetLevelCommentsCompleted(response, tag)) {
	using FunctionType = decltype(onGetLevelCommentsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x108440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetLevelLeaderboardCompleted(gd::string response, gd::string tag) -> decltype(onGetLevelLeaderboardCompleted(response, tag)) {
	using FunctionType = decltype(onGetLevelLeaderboardCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x105bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetLevelListsCompleted(gd::string response, gd::string tag) -> decltype(onGetLevelListsCompleted(response, tag)) {
	using FunctionType = decltype(onGetLevelListsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0xff9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetLevelSaveDataCompleted(gd::string response, gd::string tag) -> decltype(onGetLevelSaveDataCompleted(response, tag)) {
	using FunctionType = decltype(onGetLevelSaveDataCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0xfde50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetMapPacksCompleted(gd::string response, gd::string tag) -> decltype(onGetMapPacksCompleted(response, tag)) {
	using FunctionType = decltype(onGetMapPacksCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0xfe280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetNewsCompleted(gd::string response, gd::string tag) -> decltype(onGetNewsCompleted(response, tag)) {
	using FunctionType = decltype(onGetNewsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x108120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetOnlineLevelsCompleted(gd::string response, gd::string tag) -> decltype(onGetOnlineLevelsCompleted(response, tag)) {
	using FunctionType = decltype(onGetOnlineLevelsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0xfd470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetTopArtistsCompleted(gd::string response, gd::string tag) -> decltype(onGetTopArtistsCompleted(response, tag)) {
	using FunctionType = decltype(onGetTopArtistsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x105f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetUserListCompleted(gd::string response, gd::string tag) -> decltype(onGetUserListCompleted(response, tag)) {
	using FunctionType = decltype(onGetUserListCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10d3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetUserMessagesCompleted(gd::string response, gd::string tag) -> decltype(onGetUserMessagesCompleted(response, tag)) {
	using FunctionType = decltype(onGetUserMessagesCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x106c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onGetUsersCompleted(gd::string response, gd::string tag) -> decltype(onGetUsersCompleted(response, tag)) {
	using FunctionType = decltype(onGetUsersCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1064b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onLikeItemCompleted(gd::string response, gd::string tag) -> decltype(onLikeItemCompleted(response, tag)) {
	using FunctionType = decltype(onLikeItemCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10e610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* p0, cocos2d::extension::CCHttpResponse* p1) -> decltype(onProcessHttpRequestCompleted(p0, p1)) {
	using FunctionType = decltype(onProcessHttpRequestCompleted(p0, p1))(*)(GameLevelManager*, cocos2d::extension::CCHttpClient*, cocos2d::extension::CCHttpResponse*);
	static auto func = wrapFunction(base::get() + 0xf3d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onRateDemonCompleted(gd::string response, gd::string tag) -> decltype(onRateDemonCompleted(response, tag)) {
	using FunctionType = decltype(onRateDemonCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1035a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onRateStarsCompleted(gd::string response, gd::string tag) -> decltype(onRateStarsCompleted(response, tag)) {
	using FunctionType = decltype(onRateStarsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x102410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onReadFriendRequestCompleted(gd::string response, gd::string tag) -> decltype(onReadFriendRequestCompleted(response, tag)) {
	using FunctionType = decltype(onReadFriendRequestCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10c4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onRemoveFriendCompleted(gd::string response, gd::string tag) -> decltype(onRemoveFriendCompleted(response, tag)) {
	using FunctionType = decltype(onRemoveFriendCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10c7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onReportLevelCompleted(gd::string response, gd::string tag) -> decltype(onReportLevelCompleted(response, tag)) {
	using FunctionType = decltype(onReportLevelCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x111410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onRequestUserAccessCompleted(gd::string response, gd::string tag) -> decltype(onRequestUserAccessCompleted(response, tag)) {
	using FunctionType = decltype(onRequestUserAccessCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10e9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onRestoreItemsCompleted(gd::string response, gd::string tag) -> decltype(onRestoreItemsCompleted(response, tag)) {
	using FunctionType = decltype(onRestoreItemsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x110d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onSetLevelFeaturedCompleted(gd::string response, gd::string tag) -> decltype(onSetLevelFeaturedCompleted(response, tag)) {
	using FunctionType = decltype(onSetLevelFeaturedCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x103a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onSetLevelStarsCompleted(gd::string response, gd::string tag) -> decltype(onSetLevelStarsCompleted(response, tag)) {
	using FunctionType = decltype(onSetLevelStarsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x103860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onSuggestLevelStarsCompleted(gd::string response, gd::string tag) -> decltype(onSuggestLevelStarsCompleted(response, tag)) {
	using FunctionType = decltype(onSuggestLevelStarsCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1030d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onUnblockUserCompleted(gd::string response, gd::string tag) -> decltype(onUnblockUserCompleted(response, tag)) {
	using FunctionType = decltype(onUnblockUserCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10d060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onUpdateDescriptionCompleted(gd::string response, gd::string tag) -> decltype(onUpdateDescriptionCompleted(response, tag)) {
	using FunctionType = decltype(onUpdateDescriptionCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10ded0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onUpdateLevelCompleted(gd::string response, gd::string tag) -> decltype(onUpdateLevelCompleted(response, tag)) {
	using FunctionType = decltype(onUpdateLevelCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x101eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onUpdateUserScoreCompleted(gd::string response, gd::string tag) -> decltype(onUpdateUserScoreCompleted(response, tag)) {
	using FunctionType = decltype(onUpdateUserScoreCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x104a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onUploadCommentCompleted(gd::string response, gd::string tag) -> decltype(onUploadCommentCompleted(response, tag)) {
	using FunctionType = decltype(onUploadCommentCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10a160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onUploadFriendRequestCompleted(gd::string response, gd::string tag) -> decltype(onUploadFriendRequestCompleted(response, tag)) {
	using FunctionType = decltype(onUploadFriendRequestCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x10b6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onUploadLevelCompleted(gd::string response, gd::string tag) -> decltype(onUploadLevelCompleted(response, tag)) {
	using FunctionType = decltype(onUploadLevelCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0xfc3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onUploadLevelListCompleted(gd::string response, gd::string tag) -> decltype(onUploadLevelListCompleted(response, tag)) {
	using FunctionType = decltype(onUploadLevelListCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0xff320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::onUploadUserMessageCompleted(gd::string response, gd::string tag) -> decltype(onUploadUserMessageCompleted(response, tag)) {
	using FunctionType = decltype(onUploadUserMessageCompleted(response, tag))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1076a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, response, tag);
}

auto GameLevelManager::performNetworkTest() -> decltype(performNetworkTest()) {
	using FunctionType = decltype(performNetworkTest())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xf3a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::ProcessHttpRequest(gd::string endpoint, gd::string params, gd::string tag, GJHttpType httpType) -> decltype(ProcessHttpRequest(endpoint, params, tag, httpType)) {
	using FunctionType = decltype(ProcessHttpRequest(endpoint, params, tag, httpType))(*)(GameLevelManager*, gd::string, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0xf3bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, endpoint, params, tag, httpType);
}

auto GameLevelManager::processOnDownloadLevelCompleted(gd::string p0, gd::string p1, bool p2) -> decltype(processOnDownloadLevelCompleted(p0, p1, p2)) {
	using FunctionType = decltype(processOnDownloadLevelCompleted(p0, p1, p2))(*)(GameLevelManager*, gd::string, gd::string, bool);
	static auto func = wrapFunction(base::get() + 0x101160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::rateDemon(int p0, int p1, bool p2) -> decltype(rateDemon(p0, p1, p2)) {
	using FunctionType = decltype(rateDemon(p0, p1, p2))(*)(GameLevelManager*, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x103330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::rateStars(int p0, int p1) -> decltype(rateStars(p0, p1)) {
	using FunctionType = decltype(rateStars(p0, p1))(*)(GameLevelManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x101f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::readFriendRequest(int p0) -> decltype(readFriendRequest(p0)) {
	using FunctionType = decltype(readFriendRequest(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x10c2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::removeDLFromActive(char const* p0) -> decltype(removeDLFromActive(p0)) {
	using FunctionType = decltype(removeDLFromActive(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0xf8cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::removeFriend(int p0) -> decltype(removeFriend(p0)) {
	using FunctionType = decltype(removeFriend(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x10c590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::reportLevel(int p0) -> decltype(reportLevel(p0)) {
	using FunctionType = decltype(reportLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x111310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::requestUserAccess() -> decltype(requestUserAccess()) {
	using FunctionType = decltype(requestUserAccess())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x10e7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::resetAccountComments(int p0) -> decltype(resetAccountComments(p0)) {
	using FunctionType = decltype(resetAccountComments(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x109030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::resetCommentTimersForLevelID(int p0, CommentKeyType p1) -> decltype(resetCommentTimersForLevelID(p0, p1)) {
	using FunctionType = decltype(resetCommentTimersForLevelID(p0, p1))(*)(GameLevelManager*, int, CommentKeyType);
	static auto func = wrapFunction(base::get() + 0x10a6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::resetDailyLevelState(GJTimedLevelType p0) -> decltype(resetDailyLevelState(p0)) {
	using FunctionType = decltype(resetDailyLevelState(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x110d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::resetTimerForKey(char const* p0) -> decltype(resetTimerForKey(p0)) {
	using FunctionType = decltype(resetTimerForKey(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0xf9130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::responseToDict(gd::string p0, bool p1) -> decltype(responseToDict(p0, p1)) {
	using FunctionType = decltype(responseToDict(p0, p1))(*)(GameLevelManager*, gd::string, bool);
	static auto func = wrapFunction(base::get() + 0x111fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::saveFetchedLevels(cocos2d::CCArray* p0) -> decltype(saveFetchedLevels(p0)) {
	using FunctionType = decltype(saveFetchedLevels(p0))(*)(GameLevelManager*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0xf69d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::saveGauntlet(GJMapPack* p0) -> decltype(saveGauntlet(p0)) {
	using FunctionType = decltype(saveGauntlet(p0))(*)(GameLevelManager*, GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x100b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::saveLevel(GJGameLevel* p0) -> decltype(saveLevel(p0)) {
	using FunctionType = decltype(saveLevel(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0xf8130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::storeDailyLevelState(int p0, int p1, GJTimedLevelType p2) -> decltype(storeDailyLevelState(p0, p1, p2)) {
	using FunctionType = decltype(storeDailyLevelState(p0, p1, p2))(*)(GameLevelManager*, int, int, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x110bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::storeSearchResult(cocos2d::CCArray* levels, gd::string pageInfo, char const* searchKey) -> decltype(storeSearchResult(levels, pageInfo, searchKey)) {
	using FunctionType = decltype(storeSearchResult(levels, pageInfo, searchKey))(*)(GameLevelManager*, cocos2d::CCArray*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0xf8810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, levels, pageInfo, searchKey);
}

auto GameLevelManager::storeUserName(int userID, int accountID, gd::string userName) -> decltype(storeUserName(userID, accountID, userName)) {
	using FunctionType = decltype(storeUserName(userID, accountID, userName))(*)(GameLevelManager*, int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0xf6140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, userID, accountID, userName);
}

auto GameLevelManager::submitUserInfo() -> decltype(submitUserInfo()) {
	using FunctionType = decltype(submitUserInfo())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x110f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::suggestLevelStars(int p0, int p1, int p2) -> decltype(suggestLevelStars(p0, p1, p2)) {
	using FunctionType = decltype(suggestLevelStars(p0, p1, p2))(*)(GameLevelManager*, int, int, int);
	static auto func = wrapFunction(base::get() + 0x102ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::tryGetUsername(int p0) -> decltype(tryGetUsername(p0)) {
	using FunctionType = decltype(tryGetUsername(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0xf6370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::unblockUser(int p0) -> decltype(unblockUser(p0)) {
	using FunctionType = decltype(unblockUser(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x10ce50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::unfollowUser(int p0) -> decltype(unfollowUser(p0)) {
	using FunctionType = decltype(unfollowUser(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0xf9b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::updateDescription(int p0, gd::string p1) -> decltype(updateDescription(p0, p1)) {
	using FunctionType = decltype(updateDescription(p0, p1))(*)(GameLevelManager*, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x10dc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::updateLevel(GJGameLevel* p0) -> decltype(updateLevel(p0)) {
	using FunctionType = decltype(updateLevel(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x101d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::updateLevelOrders() -> decltype(updateLevelOrders()) {
	using FunctionType = decltype(updateLevelOrders())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xf75f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::updateLevelRewards(GJGameLevel* p0) -> decltype(updateLevelRewards(p0)) {
	using FunctionType = decltype(updateLevelRewards(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0xf66c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::updateUserScore() -> decltype(updateUserScore()) {
	using FunctionType = decltype(updateUserScore())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x103ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::uploadAccountComment(gd::string p0) -> decltype(uploadAccountComment(p0)) {
	using FunctionType = decltype(uploadAccountComment(p0))(*)(GameLevelManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1099d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::uploadComment(gd::string p0, CommentType p1, int p2, int p3) -> decltype(uploadComment(p0, p1, p2, p3)) {
	using FunctionType = decltype(uploadComment(p0, p1, p2, p3))(*)(GameLevelManager*, gd::string, CommentType, int, int);
	static auto func = wrapFunction(base::get() + 0x109a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::uploadFriendRequest(int p0, gd::string p1) -> decltype(uploadFriendRequest(p0, p1)) {
	using FunctionType = decltype(uploadFriendRequest(p0, p1))(*)(GameLevelManager*, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x10b440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::uploadLevel(GJGameLevel* p0) -> decltype(uploadLevel(p0)) {
	using FunctionType = decltype(uploadLevel(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0xfb760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::uploadLevelComment(int p0, gd::string p1, int p2) -> decltype(uploadLevelComment(p0, p1, p2)) {
	using FunctionType = decltype(uploadLevelComment(p0, p1, p2))(*)(GameLevelManager*, int, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x109940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::uploadLevelList(GJLevelList* p0) -> decltype(uploadLevelList(p0)) {
	using FunctionType = decltype(uploadLevelList(p0))(*)(GameLevelManager*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0xfeac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::uploadUserMessage(int p0, gd::string p1, gd::string p2) -> decltype(uploadUserMessage(p0, p1, p2)) {
	using FunctionType = decltype(uploadUserMessage(p0, p1, p2))(*)(GameLevelManager*, int, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x107370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::userNameForUserID(int p0) -> decltype(userNameForUserID(p0)) {
	using FunctionType = decltype(userNameForUserID(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0xf6290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::verifyLevelState(GJGameLevel* p0) -> decltype(verifyLevelState(p0)) {
	using FunctionType = decltype(verifyLevelState(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0xf6510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameLevelManager::init), this);
	using FunctionType = decltype(init())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0xf4c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameLevelOptionsLayer::create(GJGameLevel* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x213c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameLevelOptionsLayer::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GameLevelOptionsLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x213cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameLevelOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(GameLevelOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x213d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameLevelOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameLevelOptionsLayer::didToggle), this);
	using FunctionType = decltype(didToggle(p0))(*)(GameLevelOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x213d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UIButtonConfig::reset() -> decltype(reset()) {
	using FunctionType = decltype(reset())(*)(UIButtonConfig*);
	static auto func = wrapFunction(base::get() + 0x120660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

GameManager* GameManager::get() {
		return GameManager::sharedState();
	}

auto GameManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x121540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

PlayLayer* GameManager::getPlayLayer() {
		return m_playLayer;
	}

LevelEditorLayer* GameManager::getEditorLayer() {
		return m_levelEditorLayer;
	}

GJBaseGameLayer* GameManager::getGameLayer() {
		return m_gameLayer;
	}

int GameManager::getPlayerFrame() {
        return m_playerFrame;
    }

int GameManager::getPlayerShip() {
        return m_playerShip;
    }

int GameManager::getPlayerBall() {
        return m_playerBall;
    }

int GameManager::getPlayerBird() {
        return m_playerBird;
    }

int GameManager::getPlayerDart() {
        return m_playerDart;
    }

int GameManager::getPlayerRobot() {
        return m_playerRobot;
    }

int GameManager::getPlayerSpider() {
        return m_playerSpider;
    }

int GameManager::getPlayerSwing() {
        return m_playerSwing;
    }

int GameManager::getPlayerGlowColor() {
        return m_playerGlowColor;
    }

int GameManager::getPlayerStreak() {
        return m_playerStreak;
    }

int GameManager::getPlayerShipFire() {
		return m_playerShipFire;
	}

int GameManager::getPlayerDeathEffect() {
        return m_playerDeathEffect;
    }

int GameManager::getPlayerJetpack() {
		return m_playerJetpack;
	}

int GameManager::getPlayerColor() {
        return m_playerColor;
    }

int GameManager::getPlayerColor2() {
        return m_playerColor2;
    }

bool GameManager::getPlayerGlow() {
        return m_playerGlow;
    }

void GameManager::setPlayerFrame(int id) {
        m_playerFrame = id;
    }

void GameManager::setPlayerShip(int id) {
        m_playerShip = id;
    }

void GameManager::setPlayerBall(int id) {
        m_playerBall = id;
    }

void GameManager::setPlayerBird(int id) {
        m_playerBird = id;
    }

void GameManager::setPlayerDart(int id) {
        m_playerDart = id;
    }

void GameManager::setPlayerRobot(int id) {
        m_playerRobot = id;
    }

void GameManager::setPlayerSpider(int id) {
        m_playerSpider = id;
    }

void GameManager::setPlayerSwing(int id) {
		m_playerSwing = id;
	}

void GameManager::setPlayerColor3(int id) {
		m_playerGlowColor = id;
	}

void GameManager::setPlayerStreak(int id) {
        m_playerStreak = id;
    }

void GameManager::setPlayerShipStreak(int id) {
        m_playerShipFire = id;
    }

void GameManager::setPlayerDeathEffect(int id) {
        m_playerDeathEffect = id;
    }

void GameManager::setPlayerJetpack(int id) {
		m_playerJetpack = id;
	}

void GameManager::setPlayerColor(int id) {
        m_playerColor = id;
    }

void GameManager::setPlayerColor2(int id) {
        m_playerColor2 = id;
    }

void GameManager::setPlayerGlow(bool v) {
        m_playerGlow = v;
    }

bool GameManager::getGameVariableDefault(const char* key, bool defaultValue) {
		//helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->boolValue();
    }

int GameManager::getIntGameVariableDefault(const char* key, int defaultValue) {
		//helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->intValue();
    }

auto GameManager::activeIconForType(IconType p0) -> decltype(activeIconForType(p0)) {
	using FunctionType = decltype(activeIconForType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x1270f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::addCustomAnimationFrame(int p0, int p1, gd::string p2, gd::string p3) -> decltype(addCustomAnimationFrame(p0, p1, p2, p3)) {
	using FunctionType = decltype(addCustomAnimationFrame(p0, p1, p2, p3))(*)(GameManager*, int, int, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x14da60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameManager::addGameAnimation(int p0, int p1, float p2, gd::string p3, gd::string p4, int p5) -> decltype(addGameAnimation(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(addGameAnimation(p0, p1, p2, p3, p4, p5))(*)(GameManager*, int, int, float, gd::string, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x14d8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GameManager::addNewCustomObject(gd::string p0) -> decltype(addNewCustomObject(p0)) {
	using FunctionType = decltype(addNewCustomObject(p0))(*)(GameManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x128ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::applicationWillEnterForeground() -> decltype(applicationWillEnterForeground()) {
	using FunctionType = decltype(applicationWillEnterForeground())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x12ded0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::calculateBaseKeyForIcons() -> decltype(calculateBaseKeyForIcons()) {
	using FunctionType = decltype(calculateBaseKeyForIcons())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1278d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::checkSteamAchievementUnlock() -> decltype(checkSteamAchievementUnlock()) {
	using FunctionType = decltype(checkSteamAchievementUnlock())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1234f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::checkUsedIcons() -> decltype(checkUsedIcons()) {
	using FunctionType = decltype(checkUsedIcons())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1297d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::colorForIdx(int p0) -> decltype(colorForIdx(p0)) {
	using FunctionType = decltype(colorForIdx(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x126090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::colorKey(int p0, UnlockType p1) -> decltype(colorKey(p0, p1)) {
	using FunctionType = decltype(colorKey(p0, p1))(*)(GameManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x122350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::completedAchievement(gd::string p0) -> decltype(completedAchievement(p0)) {
	using FunctionType = decltype(completedAchievement(p0))(*)(GameManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x122b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::countForType(IconType p0) -> decltype(countForType(p0)) {
	using FunctionType = decltype(countForType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x127270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::doQuickSave() -> decltype(doQuickSave()) {
	using FunctionType = decltype(doQuickSave())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x12de10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::fadeInMenuMusic() -> decltype(fadeInMenuMusic()) {
	using FunctionType = decltype(fadeInMenuMusic())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1219f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::fadeInMusic(gd::string p0) -> decltype(fadeInMusic(p0)) {
	using FunctionType = decltype(fadeInMusic(p0))(*)(GameManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x121a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::finishedLoadingBGAsync(cocos2d::CCObject* p0) -> decltype(finishedLoadingBGAsync(p0)) {
	using FunctionType = decltype(finishedLoadingBGAsync(p0))(*)(GameManager*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x127ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::followTwitch() -> decltype(followTwitch()) {
	using FunctionType = decltype(followTwitch())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x126f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::followTwitter() -> decltype(followTwitter()) {
	using FunctionType = decltype(followTwitter())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x126e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::getFontTexture(int p0) -> decltype(getFontTexture(p0)) {
	using FunctionType = decltype(getFontTexture(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x127c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::getGameVariable(char const* p0) -> decltype(getGameVariable(p0)) {
	using FunctionType = decltype(getGameVariable(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x128730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

int GameManager::getIconRequestID() {
		return m_iconRequestID++;
	}

auto GameManager::getIntGameVariable(char const* p0) -> decltype(getIntGameVariable(p0)) {
	using FunctionType = decltype(getIntGameVariable(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x128c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::getMenuMusicFile() -> decltype(getMenuMusicFile()) {
	using FunctionType = decltype(getMenuMusicFile())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1216e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::getNextUniqueObjectKey() -> decltype(getNextUniqueObjectKey()) {
	using FunctionType = decltype(getNextUniqueObjectKey())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x128d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::getNextUsedKey(int p0, bool p1) -> decltype(getNextUsedKey(p0, p1)) {
	using FunctionType = decltype(getNextUsedKey(p0, p1))(*)(GameManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x128de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::getPracticeMusicFile() -> decltype(getPracticeMusicFile()) {
	using FunctionType = decltype(getPracticeMusicFile())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1217b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::getUGV(char const* p0) -> decltype(getUGV(p0)) {
	using FunctionType = decltype(getUGV(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x128a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::getUnlockForAchievement(gd::string p0, int& p1, UnlockType& p2) -> decltype(getUnlockForAchievement(p0, p1, p2)) {
	using FunctionType = decltype(getUnlockForAchievement(p0, p1, p2))(*)(GameManager*, gd::string, int&, UnlockType&);
	static auto func = wrapFunction(base::get() + 0x122690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::iconKey(int p0, IconType p1) -> decltype(iconKey(p0, p1)) {
	using FunctionType = decltype(iconKey(p0, p1))(*)(GameManager*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x121d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::iconTypeToUnlockType(IconType p0) -> decltype(iconTypeToUnlockType(p0)) {
	using FunctionType = decltype(iconTypeToUnlockType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x122090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::isColorUnlocked(int p0, UnlockType p1) -> decltype(isColorUnlocked(p0, p1)) {
	using FunctionType = decltype(isColorUnlocked(p0, p1))(*)(GameManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x122490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::isIconUnlocked(int p0, IconType p1) -> decltype(isIconUnlocked(p0, p1)) {
	using FunctionType = decltype(isIconUnlocked(p0, p1))(*)(GameManager*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x121f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::joinDiscord() -> decltype(joinDiscord()) {
	using FunctionType = decltype(joinDiscord())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x126fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::joinReddit() -> decltype(joinReddit()) {
	using FunctionType = decltype(joinReddit())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x127040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

int GameManager::keyForIcon(int iconIdx, int iconEnum) {
		return m_keyStartForIcon->at(iconEnum) + iconIdx - 1;
	}

auto GameManager::likeFacebook() -> decltype(likeFacebook()) {
	using FunctionType = decltype(likeFacebook())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x126d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::loadBackground(int p0) -> decltype(loadBackground(p0)) {
	using FunctionType = decltype(loadBackground(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x127dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::loadBackgroundAsync(int p0) -> decltype(loadBackgroundAsync(p0)) {
	using FunctionType = decltype(loadBackgroundAsync(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x127e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::loadDeathEffect(int p0) -> decltype(loadDeathEffect(p0)) {
	using FunctionType = decltype(loadDeathEffect(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x127c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::loadDPadLayout(int p0, bool p1) -> decltype(loadDPadLayout(p0, p1)) {
	using FunctionType = decltype(loadDPadLayout(p0, p1))(*)(GameManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x12af80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::loadFont(int p0) -> decltype(loadFont(p0)) {
	using FunctionType = decltype(loadFont(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x127ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::loadGround(int p0) -> decltype(loadGround(p0)) {
	using FunctionType = decltype(loadGround(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x1281f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::loadIcon(int p0, int p1, int p2) -> decltype(loadIcon(p0, p1, p2)) {
	using FunctionType = decltype(loadIcon(p0, p1, p2))(*)(GameManager*, int, int, int);
	static auto func = wrapFunction(base::get() + 0x127440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::loadMiddleground(int p0) -> decltype(loadMiddleground(p0)) {
	using FunctionType = decltype(loadMiddleground(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x127f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::lockColor(int p0, UnlockType p1) -> decltype(lockColor(p0, p1)) {
	using FunctionType = decltype(lockColor(p0, p1))(*)(GameManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x122610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::lockIcon(int p0, IconType p1) -> decltype(lockIcon(p0, p1)) {
	using FunctionType = decltype(lockIcon(p0, p1))(*)(GameManager*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x1222d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::openEditorGuide() -> decltype(openEditorGuide()) {
	using FunctionType = decltype(openEditorGuide())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1270d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::playMenuMusic() -> decltype(playMenuMusic()) {
	using FunctionType = decltype(playMenuMusic())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x121890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::playSFXTrigger(SFXTriggerGameObject* p0) -> decltype(playSFXTrigger(p0)) {
	using FunctionType = decltype(playSFXTrigger(p0))(*)(GameManager*, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x121b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::prepareDPadSettings() -> decltype(prepareDPadSettings()) {
	using FunctionType = decltype(prepareDPadSettings())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x12b720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::queueReloadMenu() -> decltype(queueReloadMenu()) {
	using FunctionType = decltype(queueReloadMenu())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x12e3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::recountUserStats(gd::string p0) -> decltype(recountUserStats(p0)) {
	using FunctionType = decltype(recountUserStats(p0))(*)(GameManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x129ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::reloadAll(bool switchingModes, bool toFullscreen, bool borderless, bool unused) -> decltype(reloadAll(switchingModes, toFullscreen, borderless, unused)) {
	using FunctionType = decltype(reloadAll(switchingModes, toFullscreen, borderless, unused))(*)(GameManager*, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x12e4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, switchingModes, toFullscreen, borderless, unused);
}

void GameManager::reloadAll(bool switchingModes, bool toFullscreen, bool unused) {
		return this->reloadAll(switchingModes, toFullscreen, false, unused);
	}

auto GameManager::reloadAllStep2() -> decltype(reloadAllStep2()) {
	using FunctionType = decltype(reloadAllStep2())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x12e540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::reloadAllStep3() -> decltype(reloadAllStep3()) {
	using FunctionType = decltype(reloadAllStep3())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x12e6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::reloadAllStep4() -> decltype(reloadAllStep4()) {
	using FunctionType = decltype(reloadAllStep4())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x12e740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::reloadAllStep5() -> decltype(reloadAllStep5()) {
	using FunctionType = decltype(reloadAllStep5())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x12e7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::removeIconDelegate(int p0) -> decltype(removeIconDelegate(p0)) {
	using FunctionType = decltype(removeIconDelegate(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x127370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::reportAchievementWithID(char const* p0, int p1, bool p2) -> decltype(reportAchievementWithID(p0, p1, p2)) {
	using FunctionType = decltype(reportAchievementWithID(p0, p1, p2))(*)(GameManager*, char const*, int, bool);
	static auto func = wrapFunction(base::get() + 0x1234a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::reportPercentageForLevel(int p0, int p1, bool p2) -> decltype(reportPercentageForLevel(p0, p1, p2)) {
	using FunctionType = decltype(reportPercentageForLevel(p0, p1, p2))(*)(GameManager*, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x122d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::resolutionForKey(int p0) -> decltype(resolutionForKey(p0)) {
	using FunctionType = decltype(resolutionForKey(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x12e800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::returnToLastScene(GJGameLevel* p0) -> decltype(returnToLastScene(p0)) {
	using FunctionType = decltype(returnToLastScene(p0))(*)(GameManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x12e110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::saveDPadLayout(int p0, bool p1) -> decltype(saveDPadLayout(p0, p1)) {
	using FunctionType = decltype(saveDPadLayout(p0, p1))(*)(GameManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x12ac70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::setGameVariable(char const* p0, bool p1) -> decltype(setGameVariable(p0, p1)) {
	using FunctionType = decltype(setGameVariable(p0, p1))(*)(GameManager*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x1284e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::setIntGameVariable(char const* p0, int p1) -> decltype(setIntGameVariable(p0, p1)) {
	using FunctionType = decltype(setIntGameVariable(p0, p1))(*)(GameManager*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x128b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::setPlayerUserID(int p0) -> decltype(setPlayerUserID(p0)) {
	using FunctionType = decltype(setPlayerUserID(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0xf3760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::setUGV(char const* p0, bool p1) -> decltype(setUGV(p0, p1)) {
	using FunctionType = decltype(setUGV(p0, p1))(*)(GameManager*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x1288d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::setupGameAnimations() -> decltype(setupGameAnimations()) {
	using FunctionType = decltype(setupGameAnimations())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x14b280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::sheetNameForIcon(int p0, int p1) -> decltype(sheetNameForIcon(p0, p1)) {
	using FunctionType = decltype(sheetNameForIcon(p0, p1))(*)(GameManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x1279a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::stringForCustomObject(int p0) -> decltype(stringForCustomObject(p0)) {
	using FunctionType = decltype(stringForCustomObject(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x128f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::subYouTube() -> decltype(subYouTube()) {
	using FunctionType = decltype(subYouTube())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x126e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::toggleGameVariable(char const* p0) -> decltype(toggleGameVariable(p0)) {
	using FunctionType = decltype(toggleGameVariable(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x128890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::unloadBackground() -> decltype(unloadBackground()) {
	using FunctionType = decltype(unloadBackground())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x127d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::unloadIcon(int p0, int p1, int p2) -> decltype(unloadIcon(p0, p1, p2)) {
	using FunctionType = decltype(unloadIcon(p0, p1, p2))(*)(GameManager*, int, int, int);
	static auto func = wrapFunction(base::get() + 0x1276b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::unloadIcons(int p0) -> decltype(unloadIcons(p0)) {
	using FunctionType = decltype(unloadIcons(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x127870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::unlockColor(int p0, UnlockType p1) -> decltype(unlockColor(p0, p1)) {
	using FunctionType = decltype(unlockColor(p0, p1))(*)(GameManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x122560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::unlockIcon(int p0, IconType p1) -> decltype(unlockIcon(p0, p1)) {
	using FunctionType = decltype(unlockIcon(p0, p1))(*)(GameManager*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x122220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::unlockTypeToIconType(int p0) -> decltype(unlockTypeToIconType(p0)) {
	using FunctionType = decltype(unlockTypeToIconType(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x122190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::updateCustomFPS() -> decltype(updateCustomFPS()) {
	using FunctionType = decltype(updateCustomFPS())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x12ec60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("GameManager::update not implemented");
}

auto GameManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameManager::init), this);
	using FunctionType = decltype(init())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x1215c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GameManager::encodeDataTo), this);
	using FunctionType = decltype(encodeDataTo(p0))(*)(GameManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x12d480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GameManager::dataLoaded), this);
	using FunctionType = decltype(dataLoaded(p0))(*)(GameManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x12b830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameManager::firstLoad() -> decltype(firstLoad()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameManager::firstLoad), this);
	using FunctionType = decltype(firstLoad())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x12cb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObjectCopy::create(GameObject* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x24a8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameObjectCopy::init(GameObject* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GameObjectCopy*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x24a960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameOptionsLayer::create(GJBaseGameLayer* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x213050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameOptionsLayer::init(GJBaseGameLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GameOptionsLayer*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x2130f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameOptionsLayer::onPracticeMusicSync(cocos2d::CCObject* sender) -> decltype(onPracticeMusicSync(sender)) {
	using FunctionType = decltype(onPracticeMusicSync(sender))(*)(GameOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x213930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GameOptionsLayer::onUIOptions(cocos2d::CCObject* sender) -> decltype(onUIOptions(sender)) {
	using FunctionType = decltype(onUIOptions(sender))(*)(GameOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2139a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GameOptionsLayer::showPracticeMusicSyncUnlockInfo() -> decltype(showPracticeMusicSyncUnlockInfo()) {
	using FunctionType = decltype(showPracticeMusicSyncUnlockInfo())(*)(GameOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x213620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(GameOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x213150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameOptionsLayer::didToggle), this);
	using FunctionType = decltype(didToggle(p0))(*)(GameOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2139c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameOptionsTrigger::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3971d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameOptionsTrigger::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("GameOptionsTrigger::customObjectSetup not implemented");
}

auto GameOptionsTrigger::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("GameOptionsTrigger::getSaveString not implemented");
}

auto GameStatsManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x167d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GameStatsManager::addSimpleSpecialChestReward(gd::string p0, UnlockType p1, int p2, bool p3) -> decltype(addSimpleSpecialChestReward(p0, p1, p2, p3)) {
	using FunctionType = decltype(addSimpleSpecialChestReward(p0, p1, p2, p3))(*)(GameStatsManager*, gd::string, UnlockType, int, bool);
	static auto func = wrapFunction(base::get() + 0x179bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameStatsManager::addSpecialRewardDescription(gd::string p0, gd::string p1) -> decltype(addSpecialRewardDescription(p0, p1)) {
	using FunctionType = decltype(addSpecialRewardDescription(p0, p1))(*)(GameStatsManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x179e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::addStoreItem(int p0, int p1, int p2, int p3, ShopType p4) -> decltype(addStoreItem(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(addStoreItem(p0, p1, p2, p3, p4))(*)(GameStatsManager*, int, int, int, int, ShopType);
	static auto func = wrapFunction(base::get() + 0x169f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto GameStatsManager::awardCurrencyForLevel(GJGameLevel* p0) -> decltype(awardCurrencyForLevel(p0)) {
	using FunctionType = decltype(awardCurrencyForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x172080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::awardDiamondsForLevel(GJGameLevel* p0) -> decltype(awardDiamondsForLevel(p0)) {
	using FunctionType = decltype(awardDiamondsForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1725a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::awardSecretKey() -> decltype(awardSecretKey()) {
	using FunctionType = decltype(awardSecretKey())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x180040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::checkAchievement(char const* p0) -> decltype(checkAchievement(p0)) {
	using FunctionType = decltype(checkAchievement(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x16b0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::checkCoinsForLevel(GJGameLevel* p0) -> decltype(checkCoinsForLevel(p0)) {
	using FunctionType = decltype(checkCoinsForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1713c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::completedDemonLevel(GJGameLevel* p0) -> decltype(completedDemonLevel(p0)) {
	using FunctionType = decltype(completedDemonLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1700b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::completedStarLevel(GJGameLevel* p0) -> decltype(completedStarLevel(p0)) {
	using FunctionType = decltype(completedStarLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1701a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::createSecretChestItems() -> decltype(createSecretChestItems()) {
	using FunctionType = decltype(createSecretChestItems())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x17a620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::createSecretChestRewards() -> decltype(createSecretChestRewards()) {
	using FunctionType = decltype(createSecretChestRewards())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x17aab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::createSpecialChestItems() -> decltype(createSpecialChestItems()) {
	using FunctionType = decltype(createSpecialChestItems())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x176940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::createStoreItems() -> decltype(createStoreItems()) {
	using FunctionType = decltype(createStoreItems())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x168680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	using FunctionType = decltype(encodeDataTo(p0))(*)(GameStatsManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x180630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::generateItemUnlockableData() -> decltype(generateItemUnlockableData()) {
	using FunctionType = decltype(generateItemUnlockableData())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1680a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::getAwardedCurrencyForLevel(GJGameLevel* p0) -> decltype(getAwardedCurrencyForLevel(p0)) {
	using FunctionType = decltype(getAwardedCurrencyForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x171eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getAwardedDiamondsForLevel(GJGameLevel* p0) -> decltype(getAwardedDiamondsForLevel(p0)) {
	using FunctionType = decltype(getAwardedDiamondsForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1723f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getBaseCurrencyForLevel(GJGameLevel* p0) -> decltype(getBaseCurrencyForLevel(p0)) {
	using FunctionType = decltype(getBaseCurrencyForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x171d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getChallenge(int p0) -> decltype(getChallenge(p0)) {
	using FunctionType = decltype(getChallenge(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x173400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getChallengeKey(GJChallengeItem* p0) -> decltype(getChallengeKey(p0)) {
	using FunctionType = decltype(getChallengeKey(p0))(*)(GameStatsManager*, GJChallengeItem*);
	static auto func = wrapFunction(base::get() + 0x1738f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getCollectedCoinsForLevel(GJGameLevel* p0) -> decltype(getCollectedCoinsForLevel(p0)) {
	using FunctionType = decltype(getCollectedCoinsForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x16fa70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getCurrencyKey(GJGameLevel* p0) -> decltype(getCurrencyKey(p0)) {
	using FunctionType = decltype(getCurrencyKey(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x171c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getDailyLevelKey(int p0) -> decltype(getDailyLevelKey(p0)) {
	using FunctionType = decltype(getDailyLevelKey(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x173d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getDemonLevelKey(GJGameLevel* p0) -> decltype(getDemonLevelKey(p0)) {
	using FunctionType = decltype(getDemonLevelKey(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x16fcb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getGauntletRewardKey(int p0) -> decltype(getGauntletRewardKey(p0)) {
	using FunctionType = decltype(getGauntletRewardKey(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x179d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getItemKey(int p0, int p1) -> decltype(getItemKey(p0, p1)) {
	using FunctionType = decltype(getItemKey(p0, p1))(*)(GameStatsManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x1729f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::getItemUnlockState(int p0, UnlockType p1) -> decltype(getItemUnlockState(p0, p1)) {
	using FunctionType = decltype(getItemUnlockState(p0, p1))(*)(GameStatsManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x176730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::getLevelKey(GJGameLevel* p0) -> decltype(getLevelKey(p0)) {
	using FunctionType = decltype(getLevelKey(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x16fb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getLevelKey(int p0, bool p1, bool p2, bool p3) -> decltype(getLevelKey(p0, p1, p2, p3)) {
	using FunctionType = decltype(getLevelKey(p0, p1, p2, p3))(*)(GameStatsManager*, int, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x16fb80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameStatsManager::getListRewardKey(GJLevelList* p0) -> decltype(getListRewardKey(p0)) {
	using FunctionType = decltype(getListRewardKey(p0))(*)(GameStatsManager*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x173b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getPathRewardKey(int p0) -> decltype(getPathRewardKey(p0)) {
	using FunctionType = decltype(getPathRewardKey(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x17a3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getQueuedChallenge(int p0) -> decltype(getQueuedChallenge(p0)) {
	using FunctionType = decltype(getQueuedChallenge(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x1734d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getSecondaryQueuedChallenge(int p0) -> decltype(getSecondaryQueuedChallenge(p0)) {
	using FunctionType = decltype(getSecondaryQueuedChallenge(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x1735a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getSpecialChestKeyForItem(int p0, UnlockType p1) -> decltype(getSpecialChestKeyForItem(p0, p1)) {
	using FunctionType = decltype(getSpecialChestKeyForItem(p0, p1))(*)(GameStatsManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x179c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::getStarLevelKey(GJGameLevel* p0) -> decltype(getStarLevelKey(p0)) {
	using FunctionType = decltype(getStarLevelKey(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x16fd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getStat(char const* p0) -> decltype(getStat(p0)) {
	using FunctionType = decltype(getStat(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x16adc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getTotalCollectedCurrency() -> decltype(getTotalCollectedCurrency()) {
	using FunctionType = decltype(getTotalCollectedCurrency())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1740d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::hasClaimedListReward(GJLevelList* p0) -> decltype(hasClaimedListReward(p0)) {
	using FunctionType = decltype(hasClaimedListReward(p0))(*)(GameStatsManager*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x173bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasCompletedChallenge(GJChallengeItem* p0) -> decltype(hasCompletedChallenge(p0)) {
	using FunctionType = decltype(hasCompletedChallenge(p0))(*)(GameStatsManager*, GJChallengeItem*);
	static auto func = wrapFunction(base::get() + 0x173970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasCompletedDailyLevel(int p0) -> decltype(hasCompletedDailyLevel(p0)) {
	using FunctionType = decltype(hasCompletedDailyLevel(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x173de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasCompletedDemonLevel(GJGameLevel* p0) -> decltype(hasCompletedDemonLevel(p0)) {
	using FunctionType = decltype(hasCompletedDemonLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x16fe00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

bool GameStatsManager::hasCompletedLevel(GJGameLevel* level) {
		return m_completedLevels->objectForKey(this->getLevelKey(level)) != nullptr;
	}

bool GameStatsManager::hasCompletedMainLevel(int levelID) {
		return m_completedLevels->objectForKey(this->getLevelKey(levelID, false, false, false)) != nullptr;
	}

auto GameStatsManager::hasCompletedStarLevel(GJGameLevel* p0) -> decltype(hasCompletedStarLevel(p0)) {
	using FunctionType = decltype(hasCompletedStarLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x16fec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasPendingUserCoin(char const* p0) -> decltype(hasPendingUserCoin(p0)) {
	using FunctionType = decltype(hasPendingUserCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x171670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasSecretCoin(char const* p0) -> decltype(hasSecretCoin(p0)) {
	using FunctionType = decltype(hasSecretCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1717e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasUserCoin(char const* p0) -> decltype(hasUserCoin(p0)) {
	using FunctionType = decltype(hasUserCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x171500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::incrementActivePath(int p0) -> decltype(incrementActivePath(p0)) {
	using FunctionType = decltype(incrementActivePath(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x16a4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::incrementChallenge(GJChallengeType p0, int p1) -> decltype(incrementChallenge(p0, p1)) {
	using FunctionType = decltype(incrementChallenge(p0, p1))(*)(GameStatsManager*, GJChallengeType, int);
	static auto func = wrapFunction(base::get() + 0x173670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::incrementStat(char const* p0, int p1) -> decltype(incrementStat(p0, p1)) {
	using FunctionType = decltype(incrementStat(p0, p1))(*)(GameStatsManager*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x16a250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::isItemEnabled(UnlockType p0, int p1) -> decltype(isItemEnabled(p0, p1)) {
	using FunctionType = decltype(isItemEnabled(p0, p1))(*)(GameStatsManager*, UnlockType, int);
	static auto func = wrapFunction(base::get() + 0x1767f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::isItemUnlocked(UnlockType p0, int p1) -> decltype(isItemUnlocked(p0, p1)) {
	using FunctionType = decltype(isItemUnlocked(p0, p1))(*)(GameStatsManager*, UnlockType, int);
	static auto func = wrapFunction(base::get() + 0x176570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::isPathChestUnlocked(int p0) -> decltype(isPathChestUnlocked(p0)) {
	using FunctionType = decltype(isPathChestUnlocked(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x17a4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::isSecretChestUnlocked(int p0) -> decltype(isSecretChestUnlocked(p0)) {
	using FunctionType = decltype(isSecretChestUnlocked(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x17a7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::isSpecialChestUnlocked(gd::string p0) -> decltype(isSpecialChestUnlocked(p0)) {
	using FunctionType = decltype(isSpecialChestUnlocked(p0))(*)(GameStatsManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x17a050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::isStoreItemUnlocked(int p0) -> decltype(isStoreItemUnlocked(p0)) {
	using FunctionType = decltype(isStoreItemUnlocked(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x16a010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::keyCostForSecretChest(int p0) -> decltype(keyCostForSecretChest(p0)) {
	using FunctionType = decltype(keyCostForSecretChest(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x17a9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::postLoadGameStats() -> decltype(postLoadGameStats()) {
	using FunctionType = decltype(postLoadGameStats())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x181810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::preProcessReward(GJRewardItem* p0) -> decltype(preProcessReward(p0)) {
	using FunctionType = decltype(preProcessReward(p0))(*)(GameStatsManager*, GJRewardItem*);
	static auto func = wrapFunction(base::get() + 0x172c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::preSaveGameStats() -> decltype(preSaveGameStats()) {
	using FunctionType = decltype(preSaveGameStats())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x1819d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::processChallengeQueue(int p0) -> decltype(processChallengeQueue(p0)) {
	using FunctionType = decltype(processChallengeQueue(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x173b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::purchaseItem(int p0) -> decltype(purchaseItem(p0)) {
	using FunctionType = decltype(purchaseItem(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x16a0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::recountSpecialStats() -> decltype(recountSpecialStats()) {
	using FunctionType = decltype(recountSpecialStats())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x174ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::registerRewardsFromItem(GJRewardItem* p0) -> decltype(registerRewardsFromItem(p0)) {
	using FunctionType = decltype(registerRewardsFromItem(p0))(*)(GameStatsManager*, GJRewardItem*);
	static auto func = wrapFunction(base::get() + 0x17fee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::removeChallenge(int p0) -> decltype(removeChallenge(p0)) {
	using FunctionType = decltype(removeChallenge(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x172ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::removeQueuedChallenge(int p0) -> decltype(removeQueuedChallenge(p0)) {
	using FunctionType = decltype(removeQueuedChallenge(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x173190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::removeQueuedSecondaryChallenge(int p0) -> decltype(removeQueuedSecondaryChallenge(p0)) {
	using FunctionType = decltype(removeQueuedSecondaryChallenge(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x173330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::setStat(char const* p0, int p1) -> decltype(setStat(p0, p1)) {
	using FunctionType = decltype(setStat(p0, p1))(*)(GameStatsManager*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x16af10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::setupIconCredits() -> decltype(setupIconCredits()) {
	using FunctionType = decltype(setupIconCredits())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x15e8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::storeChallenge(int p0, GJChallengeItem* p1) -> decltype(storeChallenge(p0, p1)) {
	using FunctionType = decltype(storeChallenge(p0, p1))(*)(GameStatsManager*, int, GJChallengeItem*);
	static auto func = wrapFunction(base::get() + 0x172f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::storeChallengeTime(int p0) -> decltype(storeChallengeTime(p0)) {
	using FunctionType = decltype(storeChallengeTime(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x172ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::storeQueuedChallenge(int p0, GJChallengeItem* p1) -> decltype(storeQueuedChallenge(p0, p1)) {
	using FunctionType = decltype(storeQueuedChallenge(p0, p1))(*)(GameStatsManager*, int, GJChallengeItem*);
	static auto func = wrapFunction(base::get() + 0x1730c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::storeRewardState(GJRewardType p0, int p1, int p2, gd::string p3) -> decltype(storeRewardState(p0, p1, p2, p3)) {
	using FunctionType = decltype(storeRewardState(p0, p1, p2, p3))(*)(GameStatsManager*, GJRewardType, int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x1728f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameStatsManager::storeSecondaryQueuedChallenge(int p0, GJChallengeItem* p1) -> decltype(storeSecondaryQueuedChallenge(p0, p1)) {
	using FunctionType = decltype(storeSecondaryQueuedChallenge(p0, p1))(*)(GameStatsManager*, int, GJChallengeItem*);
	static auto func = wrapFunction(base::get() + 0x173260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::storeUserCoin(char const* p0) -> decltype(storeUserCoin(p0)) {
	using FunctionType = decltype(storeUserCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x1715c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::toggleEnableItem(UnlockType p0, int p1, bool p2) -> decltype(toggleEnableItem(p0, p1, p2)) {
	using FunctionType = decltype(toggleEnableItem(p0, p1, p2))(*)(GameStatsManager*, UnlockType, int, bool);
	static auto func = wrapFunction(base::get() + 0x176890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameStatsManager::trySelectActivePath() -> decltype(trySelectActivePath()) {
	using FunctionType = decltype(trySelectActivePath())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x16a350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::unlockSecretChest(int p0) -> decltype(unlockSecretChest(p0)) {
	using FunctionType = decltype(unlockSecretChest(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x17a8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::unlockSpecialChest(gd::string p0) -> decltype(unlockSpecialChest(p0)) {
	using FunctionType = decltype(unlockSpecialChest(p0))(*)(GameStatsManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x17a130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::usernameForAccountID(int p0) -> decltype(usernameForAccountID(p0)) {
	using FunctionType = decltype(usernameForAccountID(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x15e830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameStatsManager::init), this);
	using FunctionType = decltype(init())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x168000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameToolbox::addBackButton(cocos2d::CCLayer* p0, cocos2d::CCMenuItem* p1) -> decltype(addBackButton(p0, p1)) {
	using FunctionType = decltype(addBackButton(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x41910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::addRThumbScrollButton(cocos2d::CCLayer* p0) -> decltype(addRThumbScrollButton(p0)) {
	using FunctionType = decltype(addRThumbScrollButton(p0))(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x419c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::alignItemsHorisontally(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2, bool p3) -> decltype(alignItemsHorisontally(p0, p1, p2, p3)) {
	using FunctionType = decltype(alignItemsHorisontally(p0, p1, p2, p3))(*)(cocos2d::CCArray*, float, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0x40a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto GameToolbox::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCNode* p6, cocos2d::CCArray* p7) -> decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7))(*)(gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x40f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7);
}

auto GameToolbox::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCNode* p6, float p7, float p8, float p9, cocos2d::CCPoint p10, char const* p11, bool p12, int p13, cocos2d::CCArray* p14) -> decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14))(*)(gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x41080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
}

auto GameToolbox::getRelativeOffset(GameObject* p0, cocos2d::CCPoint p1) -> decltype(getRelativeOffset(p0, p1)) {
	using FunctionType = decltype(getRelativeOffset(p0, p1))(*)(GameObject*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x41300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::getResponse(cocos2d::extension::CCHttpResponse* p0) -> decltype(getResponse(p0)) {
	using FunctionType = decltype(getResponse(p0))(*)(cocos2d::extension::CCHttpResponse*);
	static auto func = wrapFunction(base::get() + 0x40dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::getTimeString(int p0) -> decltype(getTimeString(p0)) {
	using FunctionType = decltype(getTimeString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x426b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::intToString(int p0) -> decltype(intToString(p0)) {
	using FunctionType = decltype(intToString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x453a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::mergeDictsSaveLargestInt(cocos2d::CCDictionary* p0, cocos2d::CCDictionary* p1) -> decltype(mergeDictsSaveLargestInt(p0, p1)) {
	using FunctionType = decltype(mergeDictsSaveLargestInt(p0, p1))(*)(cocos2d::CCDictionary*, cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x41510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::multipliedColorValue(cocos2d::ccColor3B p0, cocos2d::ccColor3B p1, float p2) -> decltype(multipliedColorValue(p0, p1, p2)) {
	using FunctionType = decltype(multipliedColorValue(p0, p1, p2))(*)(cocos2d::ccColor3B, cocos2d::ccColor3B, float);
	static auto func = wrapFunction(base::get() + 0x41d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto GameToolbox::particleStringToStruct(gd::string const& p0, cocos2d::ParticleStruct& p1) -> decltype(particleStringToStruct(p0, p1)) {
	using FunctionType = decltype(particleStringToStruct(p0, p1))(*)(gd::string const&, cocos2d::ParticleStruct&);
	static auto func = wrapFunction(base::get() + 0x43ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::preVisitWithClippingRect(cocos2d::CCNode* p0, cocos2d::CCRect p1) -> decltype(preVisitWithClippingRect(p0, p1)) {
	using FunctionType = decltype(preVisitWithClippingRect(p0, p1))(*)(cocos2d::CCNode*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x40f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::saveParticleToString(cocos2d::CCParticleSystemQuad* p0) -> decltype(saveParticleToString(p0)) {
	using FunctionType = decltype(saveParticleToString(p0))(*)(cocos2d::CCParticleSystemQuad*);
	static auto func = wrapFunction(base::get() + 0x428f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::stringSetupToDict(gd::string const& p0, char const* p1) -> decltype(stringSetupToDict(p0, p1)) {
	using FunctionType = decltype(stringSetupToDict(p0, p1))(*)(gd::string const&, char const*);
	static auto func = wrapFunction(base::get() + 0x42430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::stringSetupToMap(gd::string const& p0, char const* p1, gd::map<gd::string, gd::string>& p2) -> decltype(stringSetupToMap(p0, p1, p2)) {
	using FunctionType = decltype(stringSetupToMap(p0, p1, p2))(*)(gd::string const&, char const*, gd::map<gd::string, gd::string>&);
	static auto func = wrapFunction(base::get() + 0x42230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto GameToolbox::strongColor(cocos2d::ccColor3B p0) -> decltype(strongColor(p0)) {
	using FunctionType = decltype(strongColor(p0))(*)(cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x425e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::timestampToHumanReadable(time_t p0, time_t p1) -> decltype(timestampToHumanReadable(p0, p1)) {
	using FunctionType = decltype(timestampToHumanReadable(p0, p1))(*)(time_t, time_t);
	static auto func = wrapFunction(base::get() + 0x45640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::transformColor(cocos2d::ccColor3B const& p0, cocos2d::ccHSVValue p1) -> decltype(transformColor(p0, p1)) {
	using FunctionType = decltype(transformColor(p0, p1))(*)(cocos2d::ccColor3B const&, cocos2d::ccHSVValue);
	static auto func = wrapFunction(base::get() + 0x41b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

void LevelManagerDelegate::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1) {}

void LevelManagerDelegate::loadLevelsFailed(char const* p0) {}

void LevelManagerDelegate::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) {}

void LevelManagerDelegate::loadLevelsFailed(char const* p0, int p1) {}

void LevelManagerDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto GauntletLayer::create(GauntletType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GauntletType);
	static auto func = wrapFunction(base::get() + 0x1845f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GauntletLayer::init(GauntletType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletLayer*, GauntletType);
	static auto func = wrapFunction(base::get() + 0x184970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletLayer::setupGauntlet(cocos2d::CCArray* p0) -> decltype(setupGauntlet(p0)) {
	using FunctionType = decltype(setupGauntlet(p0))(*)(GauntletLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1851d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GauntletLayer::keyBackClicked not implemented");
}

auto GauntletLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	throw std::runtime_error("GauntletLayer::loadLevelsFinished not implemented");
}

auto GauntletLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	throw std::runtime_error("GauntletLayer::loadLevelsFailed not implemented");
}

auto GauntletNode::frameForType(GauntletType p0) -> decltype(frameForType(p0)) {
	using FunctionType = decltype(frameForType(p0))(*)(GauntletNode*, GauntletType);
	static auto func = wrapFunction(base::get() + 0x189b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletNode::init(GJMapPack* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletNode*, GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x188740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletNode::nameForType(GauntletType p0) -> decltype(nameForType(p0)) {
	using FunctionType = decltype(nameForType(p0))(*)(GauntletType);
	static auto func = wrapFunction(base::get() + 0x189f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GauntletNode::onClaimReward() -> decltype(onClaimReward()) {
	using FunctionType = decltype(onClaimReward())(*)(GauntletNode*);
	static auto func = wrapFunction(base::get() + 0x189b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GauntletSelectLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x186c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GauntletSelectLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x186cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletSelectLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(GauntletSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x188270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletSelectLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(GauntletSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1882e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletSelectLayer::onRefresh(cocos2d::CCObject* sender) -> decltype(onRefresh(sender)) {
	using FunctionType = decltype(onRefresh(sender))(*)(GauntletSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x187770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletSelectLayer::setupGauntlets() -> decltype(setupGauntlets()) {
	using FunctionType = decltype(setupGauntlets())(*)(GauntletSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x187b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GauntletSelectLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("GauntletSelectLayer::onExit not implemented");
}

auto GauntletSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GauntletSelectLayer::keyBackClicked not implemented");
}

auto GauntletSelectLayer::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	throw std::runtime_error("GauntletSelectLayer::scrollLayerWillScrollToPage not implemented");
}

auto GauntletSelectLayer::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	throw std::runtime_error("GauntletSelectLayer::scrollLayerScrolledToPage not implemented");
}

auto GauntletSelectLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	throw std::runtime_error("GauntletSelectLayer::loadLevelsFinished not implemented");
}

auto GauntletSelectLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	throw std::runtime_error("GauntletSelectLayer::loadLevelsFailed not implemented");
}

auto GhostTrailEffect::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x46b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GhostTrailEffect::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GhostTrailEffect::init), this);
	using FunctionType = decltype(init())(*)(GhostTrailEffect*);
	static auto func = wrapFunction(base::get() + 0x46bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GhostTrailEffect::draw() -> decltype(draw()) {
	throw std::runtime_error("GhostTrailEffect::draw not implemented");
}

GJAccountManager* GJAccountManager::get() {
		return GJAccountManager::sharedState();
	}

auto GJAccountManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x18a510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJAccountManager::addDLToActive(char const* tag, cocos2d::CCObject* p1) -> decltype(addDLToActive(tag, p1)) {
	using FunctionType = decltype(addDLToActive(tag, p1))(*)(GJAccountManager*, char const*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x18aba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, tag, p1);
}

auto GJAccountManager::getAccountBackupURL() -> decltype(getAccountBackupURL()) {
	using FunctionType = decltype(getAccountBackupURL())(*)(GJAccountManager*);
	static auto func = wrapFunction(base::get() + 0x18b530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJAccountManager::getAccountSyncURL() -> decltype(getAccountSyncURL()) {
	using FunctionType = decltype(getAccountSyncURL())(*)(GJAccountManager*);
	static auto func = wrapFunction(base::get() + 0x18bdc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJAccountManager::handleIt(bool p0, gd::string p1, gd::string p2, GJHttpType p3) -> decltype(handleIt(p0, p1, p2, p3)) {
	using FunctionType = decltype(handleIt(p0, p1, p2, p3))(*)(GJAccountManager*, bool, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0x18a830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJAccountManager::loginAccount(gd::string p0, gd::string p1) -> decltype(loginAccount(p0, p1)) {
	using FunctionType = decltype(loginAccount(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x18afe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onBackupAccountCompleted(gd::string p0, gd::string p1) -> decltype(onBackupAccountCompleted(p0, p1)) {
	using FunctionType = decltype(onBackupAccountCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x18bb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onGetAccountBackupURLCompleted(gd::string p0, gd::string p1) -> decltype(onGetAccountBackupURLCompleted(p0, p1)) {
	using FunctionType = decltype(onGetAccountBackupURLCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x18b660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onGetAccountSyncURLCompleted(gd::string p0, gd::string p1) -> decltype(onGetAccountSyncURLCompleted(p0, p1)) {
	using FunctionType = decltype(onGetAccountSyncURLCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x18bef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onLoginAccountCompleted(gd::string p0, gd::string p1) -> decltype(onLoginAccountCompleted(p0, p1)) {
	using FunctionType = decltype(onLoginAccountCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x18b260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onRegisterAccountCompleted(gd::string p0, gd::string p1) -> decltype(onRegisterAccountCompleted(p0, p1)) {
	using FunctionType = decltype(onRegisterAccountCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x18ae80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onSyncAccountCompleted(gd::string p0, gd::string p1) -> decltype(onSyncAccountCompleted(p0, p1)) {
	using FunctionType = decltype(onSyncAccountCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x18c230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::onUpdateAccountSettingsCompleted(gd::string p0, gd::string p1) -> decltype(onUpdateAccountSettingsCompleted(p0, p1)) {
	using FunctionType = decltype(onUpdateAccountSettingsCompleted(p0, p1))(*)(GJAccountManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x18ce40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJAccountManager::registerAccount(gd::string p0, gd::string p1, gd::string p2) -> decltype(registerAccount(p0, p1, p2)) {
	using FunctionType = decltype(registerAccount(p0, p1, p2))(*)(GJAccountManager*, gd::string, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x18ad00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJAccountManager::removeDLFromActive(char const* p0) -> decltype(removeDLFromActive(p0)) {
	using FunctionType = decltype(removeDLFromActive(p0))(*)(GJAccountManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x18ac50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJAccountManager::updateAccountSettings(int p0, int p1, int p2, gd::string p3, gd::string p4, gd::string p5) -> decltype(updateAccountSettings(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(updateAccountSettings(p0, p1, p2, p3, p4, p5))(*)(GJAccountManager*, int, int, int, gd::string, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x18cc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJAccountManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJAccountManager::init), this);
	using FunctionType = decltype(init())(*)(GJAccountManager*);
	static auto func = wrapFunction(base::get() + 0x18ab70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJAccountSettingsDelegate::updateSettingsFinished() -> decltype(updateSettingsFinished()) {
	throw std::runtime_error("GJAccountSettingsDelegate::updateSettingsFinished not implemented");
}

auto GJAccountSettingsDelegate::updateSettingsFailed() -> decltype(updateSettingsFailed()) {
	throw std::runtime_error("GJAccountSettingsDelegate::updateSettingsFailed not implemented");
}

auto GJAccountSettingsLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x208440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJAccountSettingsLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJAccountSettingsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2084f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJAccountSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJAccountSettingsLayer::keyBackClicked not implemented");
}

auto GJAccountSettingsLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("GJAccountSettingsLayer::textInputShouldOffset not implemented");
}

auto GJAccountSettingsLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("GJAccountSettingsLayer::textInputReturn not implemented");
}

auto GJActionManager::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x18d340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJActionManager::init() -> decltype(init()) {
	throw std::runtime_error("GJActionManager::init not implemented");
}

auto GJGameState::stopTweenAction(int p0) -> decltype(stopTweenAction(p0)) {
	using FunctionType = decltype(stopTweenAction(p0))(*)(GJGameState*, int);
	static auto func = wrapFunction(base::get() + 0x18ea30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameState::tweenValue(float p0, float p1, int p2, float p3, int p4, float p5, int p6, int p7) -> decltype(tweenValue(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(tweenValue(p0, p1, p2, p3, p4, p5, p6, p7))(*)(GJGameState*, float, float, int, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x18e920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

TodoReturn TriggerEffectDelegate::pure_virtual_00a1b9c0() {}

TodoReturn TriggerEffectDelegate::pure_virtual_00a1b9c4() {}

TodoReturn TriggerEffectDelegate::pure_virtual_00a1b9c8() {}

GJBaseGameLayer::~GJBaseGameLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x18ef50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) GJBaseGameLayer(geode::CutoffConstructor, sizeof(GJBaseGameLayer));
	CCDestructor::lock(this) = true;
}

auto GJBaseGameLayer::activateCustomRing(RingObject* p0) -> decltype(activateCustomRing(p0)) {
	using FunctionType = decltype(activateCustomRing(p0))(*)(GJBaseGameLayer*, RingObject*);
	static auto func = wrapFunction(base::get() + 0x1a4270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::activateSFXEditTrigger(SFXTriggerGameObject* p0) -> decltype(activateSFXEditTrigger(p0)) {
	using FunctionType = decltype(activateSFXEditTrigger(p0))(*)(GJBaseGameLayer*, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1c4370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::activateSFXTrigger(SFXTriggerGameObject* p0) -> decltype(activateSFXTrigger(p0)) {
	using FunctionType = decltype(activateSFXTrigger(p0))(*)(GJBaseGameLayer*, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1c4230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::activateSongTrigger(SongTriggerGameObject* p0) -> decltype(activateSongTrigger(p0)) {
	using FunctionType = decltype(activateSongTrigger(p0))(*)(GJBaseGameLayer*, SongTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1c3df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::addObjectCounter(LabelGameObject* p0) -> decltype(addObjectCounter(p0)) {
	using FunctionType = decltype(addObjectCounter(p0))(*)(GJBaseGameLayer*, LabelGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b74c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::addProximityVolumeEffect(int p0, int p1, SFXTriggerGameObject* p2) -> decltype(addProximityVolumeEffect(p0, p1, p2)) {
	using FunctionType = decltype(addProximityVolumeEffect(p0, p1, p2))(*)(GJBaseGameLayer*, int, int, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1c4a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::addToGroupParents(GameObject* p0) -> decltype(addToGroupParents(p0)) {
	using FunctionType = decltype(addToGroupParents(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1a96a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::addToGroups(GameObject* p0, bool p1) -> decltype(addToGroups(p0, p1)) {
	using FunctionType = decltype(addToGroups(p0, p1))(*)(GJBaseGameLayer*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1a8c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::animateInDualGroundNew(GameObject* p0, float p1, bool p2, float p3) -> decltype(animateInDualGroundNew(p0, p1, p2, p3)) {
	using FunctionType = decltype(animateInDualGroundNew(p0, p1, p2, p3))(*)(GJBaseGameLayer*, GameObject*, float, bool, float);
	static auto func = wrapFunction(base::get() + 0x19ae90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::animateOutGroundNew(bool p0) -> decltype(animateOutGroundNew(p0)) {
	using FunctionType = decltype(animateOutGroundNew(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x19b120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::applyLevelSettings(GameObject* p0) -> decltype(applyLevelSettings(p0)) {
	using FunctionType = decltype(applyLevelSettings(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1bd900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::applySFXEditTrigger(int p0, int p1, SFXTriggerGameObject* p2) -> decltype(applySFXEditTrigger(p0, p1, p2)) {
	using FunctionType = decltype(applySFXEditTrigger(p0, p1, p2))(*)(GJBaseGameLayer*, int, int, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1c45b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::applyShake(cocos2d::CCPoint& p0) -> decltype(applyShake(p0)) {
	using FunctionType = decltype(applyShake(p0))(*)(GJBaseGameLayer*, cocos2d::CCPoint&);
	static auto func = wrapFunction(base::get() + 0x1c18c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::assignNewStickyGroups(cocos2d::CCArray* p0) -> decltype(assignNewStickyGroups(p0)) {
	using FunctionType = decltype(assignNewStickyGroups(p0))(*)(GJBaseGameLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1a9cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::bumpPlayer(PlayerObject* p0, EffectGameObject* p1) -> decltype(bumpPlayer(p0, p1)) {
	using FunctionType = decltype(bumpPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x19e670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::calculateColorGroups() -> decltype(calculateColorGroups()) {
	using FunctionType = decltype(calculateColorGroups())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1960b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::canBeActivatedByPlayer(PlayerObject* p0, EffectGameObject* p1) -> decltype(canBeActivatedByPlayer(p0, p1)) {
	using FunctionType = decltype(canBeActivatedByPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x19e470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::checkCollisions(PlayerObject* p0, float p1, bool p2) -> decltype(checkCollisions(p0, p1, p2)) {
	using FunctionType = decltype(checkCollisions(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, float, bool);
	static auto func = wrapFunction(base::get() + 0x19b310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::checkSpawnObjects() -> decltype(checkSpawnObjects()) {
	using FunctionType = decltype(checkSpawnObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a1390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::clearActivatedAudioTriggers() -> decltype(clearActivatedAudioTriggers()) {
	using FunctionType = decltype(clearActivatedAudioTriggers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c5590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::collisionCheckObjects(PlayerObject* p0, gd::vector<GameObject*>* p1, int p2, float p3) -> decltype(collisionCheckObjects(p0, p1, p2, p3)) {
	using FunctionType = decltype(collisionCheckObjects(p0, p1, p2, p3))(*)(GJBaseGameLayer*, PlayerObject*, gd::vector<GameObject*>*, int, float);
	static auto func = wrapFunction(base::get() + 0x19c1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::convertToClosestDirection(float p0, float p1) -> decltype(convertToClosestDirection(p0, p1)) {
	using FunctionType = decltype(convertToClosestDirection(p0, p1))(*)(GJBaseGameLayer*, float, float);
	static auto func = wrapFunction(base::get() + 0x1b2c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::createBackground(int p0) -> decltype(createBackground(p0)) {
	using FunctionType = decltype(createBackground(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x193890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::createGroundLayer(int p0, int p1) -> decltype(createGroundLayer(p0, p1)) {
	using FunctionType = decltype(createGroundLayer(p0, p1))(*)(GJBaseGameLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x193c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::createMiddleground(int p0) -> decltype(createMiddleground(p0)) {
	using FunctionType = decltype(createMiddleground(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x193bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::createNewKeyframeAnim() -> decltype(createNewKeyframeAnim()) {
	using FunctionType = decltype(createNewKeyframeAnim())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b6bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::createParticle(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) -> decltype(createParticle(p0, p1, p2, p3)) {
	using FunctionType = decltype(createParticle(p0, p1, p2, p3))(*)(GJBaseGameLayer*, int, char const*, int, cocos2d::tCCPositionType);
	static auto func = wrapFunction(base::get() + 0x1c2fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::createPlayer() -> decltype(createPlayer()) {
	using FunctionType = decltype(createPlayer())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x193550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::createPlayerCollisionBlock() -> decltype(createPlayerCollisionBlock()) {
	using FunctionType = decltype(createPlayerCollisionBlock())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x19f1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::createTextLayers() -> decltype(createTextLayers()) {
	using FunctionType = decltype(createTextLayers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x197090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::destroyObject(GameObject* p0) -> decltype(destroyObject(p0)) {
	using FunctionType = decltype(destroyObject(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x19cf50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::flipGravity(PlayerObject* p0, bool p1, bool p2) -> decltype(flipGravity(p0, p1, p2)) {
	using FunctionType = decltype(flipGravity(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x19a5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::flipObjects() -> decltype(flipObjects()) {
	using FunctionType = decltype(flipObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c8980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::gameEventTriggered(GJGameEvent p0, int p1, int p2) -> decltype(gameEventTriggered(p0, p1, p2)) {
	using FunctionType = decltype(gameEventTriggered(p0, p1, p2))(*)(GJBaseGameLayer*, GJGameEvent, int, int);
	static auto func = wrapFunction(base::get() + 0x1b5bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::generateSpawnRemap() -> decltype(generateSpawnRemap()) {
	using FunctionType = decltype(generateSpawnRemap())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a3fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::generateTargetGroups() -> decltype(generateTargetGroups()) {
	using FunctionType = decltype(generateTargetGroups())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a9f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::generateVisibilityGroups() -> decltype(generateVisibilityGroups()) {
	using FunctionType = decltype(generateVisibilityGroups())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b5060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::getBumpMod(PlayerObject* p0, int p1) -> decltype(getBumpMod(p0, p1)) {
	using FunctionType = decltype(getBumpMod(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x19e590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::getCapacityString() -> decltype(getCapacityString()) {
	using FunctionType = decltype(getCapacityString())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x196ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::getGroundHeight(PlayerObject* p0, int p1) -> decltype(getGroundHeight(p0, p1)) {
	using FunctionType = decltype(getGroundHeight(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x199740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::getGroup(int p0) -> decltype(getGroup(p0)) {
	using FunctionType = decltype(getGroup(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1a8f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::getMinDistance(cocos2d::CCPoint p0, cocos2d::CCArray* p1, float p2, int p3) -> decltype(getMinDistance(p0, p1, p2, p3)) {
	using FunctionType = decltype(getMinDistance(p0, p1, p2, p3))(*)(GJBaseGameLayer*, cocos2d::CCPoint, cocos2d::CCArray*, float, int);
	static auto func = wrapFunction(base::get() + 0x1c4ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::getOptimizedGroup(int p0) -> decltype(getOptimizedGroup(p0)) {
	using FunctionType = decltype(getOptimizedGroup(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1a9010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::getParticleKey(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) -> decltype(getParticleKey(p0, p1, p2, p3)) {
	using FunctionType = decltype(getParticleKey(p0, p1, p2, p3))(*)(GJBaseGameLayer*, int, char const*, int, cocos2d::tCCPositionType);
	static auto func = wrapFunction(base::get() + 0x1c2d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::getPortalTarget(TeleportPortalObject* p0) -> decltype(getPortalTarget(p0)) {
	using FunctionType = decltype(getPortalTarget(p0))(*)(GJBaseGameLayer*, TeleportPortalObject*);
	static auto func = wrapFunction(base::get() + 0x1985c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::getSingleGroupObject(int p0) -> decltype(getSingleGroupObject(p0)) {
	using FunctionType = decltype(getSingleGroupObject(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1a9070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::getStaticGroup(int p0) -> decltype(getStaticGroup(p0)) {
	using FunctionType = decltype(getStaticGroup(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1a8fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::gravBumpPlayer(PlayerObject* p0, EffectGameObject* p1) -> decltype(gravBumpPlayer(p0, p1)) {
	using FunctionType = decltype(gravBumpPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x19e770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::groupStickyObjects(cocos2d::CCArray* p0) -> decltype(groupStickyObjects(p0)) {
	using FunctionType = decltype(groupStickyObjects(p0))(*)(GJBaseGameLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1a9b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::handleButton(bool p0, int p1, bool p2) -> decltype(handleButton(p0, p1, p2)) {
	using FunctionType = decltype(handleButton(p0, p1, p2))(*)(GJBaseGameLayer*, bool, int, bool);
	static auto func = wrapFunction(base::get() + 0x1b69f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::hasUniqueCoin(EffectGameObject* p0) -> decltype(hasUniqueCoin(p0)) {
	using FunctionType = decltype(hasUniqueCoin(p0))(*)(GJBaseGameLayer*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x19d580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::increaseBatchNodeCapacity() -> decltype(increaseBatchNodeCapacity()) {
	using FunctionType = decltype(increaseBatchNodeCapacity())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x194b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::loadLevelSettings() -> decltype(loadLevelSettings()) {
	using FunctionType = decltype(loadLevelSettings())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bd7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::loadStartPosObject() -> decltype(loadStartPosObject()) {
	using FunctionType = decltype(loadStartPosObject())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b8d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::loadUpToPosition(float p0, int p1, int p2) -> decltype(loadUpToPosition(p0, p1, p2)) {
	using FunctionType = decltype(loadUpToPosition(p0, p1, p2))(*)(GJBaseGameLayer*, float, int, int);
	static auto func = wrapFunction(base::get() + 0x1b8e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::moveObjects(cocos2d::CCArray* p0, double p1, double p2, bool p3) -> decltype(moveObjects(p0, p1, p2, p3)) {
	using FunctionType = decltype(moveObjects(p0, p1, p2, p3))(*)(GJBaseGameLayer*, cocos2d::CCArray*, double, double, bool);
	static auto func = wrapFunction(base::get() + 0x1b1fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::objectTypeToGameEvent(int p0) -> decltype(objectTypeToGameEvent(p0)) {
	using FunctionType = decltype(objectTypeToGameEvent(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1b6190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::optimizeMoveGroups() -> decltype(optimizeMoveGroups()) {
	using FunctionType = decltype(optimizeMoveGroups())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b4cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::orderSpawnObjects() -> decltype(orderSpawnObjects()) {
	using FunctionType = decltype(orderSpawnObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c7c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::pauseAudio() -> decltype(pauseAudio()) {
	using FunctionType = decltype(pauseAudio())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bb600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::playerTouchedRing(PlayerObject* p0, RingObject* p1) -> decltype(playerTouchedRing(p0, p1)) {
	using FunctionType = decltype(playerTouchedRing(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, RingObject*);
	static auto func = wrapFunction(base::get() + 0x19eca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::playerWasTouchingObject(PlayerObject* p0, GameObject* p1) -> decltype(playerWasTouchingObject(p0, p1)) {
	using FunctionType = decltype(playerWasTouchingObject(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x19e530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::playerWillSwitchMode(PlayerObject* p0, GameObject* p1) -> decltype(playerWillSwitchMode(p0, p1)) {
	using FunctionType = decltype(playerWillSwitchMode(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x19ab80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::playExitDualEffect(PlayerObject* p0) -> decltype(playExitDualEffect(p0)) {
	using FunctionType = decltype(playExitDualEffect(p0))(*)(GJBaseGameLayer*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x19da70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::positionUIObjects() -> decltype(positionUIObjects()) {
	using FunctionType = decltype(positionUIObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1ab2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::prepareSavePositionObjects() -> decltype(prepareSavePositionObjects()) {
	using FunctionType = decltype(prepareSavePositionObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a0220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::preUpdateVisibility(float p0) -> decltype(preUpdateVisibility(p0)) {
	using FunctionType = decltype(preUpdateVisibility(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x1b97e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::processActivatedAudioTriggers(float p0) -> decltype(processActivatedAudioTriggers(p0)) {
	using FunctionType = decltype(processActivatedAudioTriggers(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x1c5960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::processDynamicObjectActions(int p0, float p1) -> decltype(processDynamicObjectActions(p0, p1)) {
	using FunctionType = decltype(processDynamicObjectActions(p0, p1))(*)(GJBaseGameLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x1b2740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::processItems() -> decltype(processItems()) {
	using FunctionType = decltype(processItems())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x19d2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processMoveActions() -> decltype(processMoveActions()) {
	using FunctionType = decltype(processMoveActions())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b1b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processMoveActionsStep(float p0, bool p1) -> decltype(processMoveActionsStep(p0, p1)) {
	using FunctionType = decltype(processMoveActionsStep(p0, p1))(*)(GJBaseGameLayer*, float, bool);
	static auto func = wrapFunction(base::get() + 0x1afce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::processPlayerFollowActions(float p0) -> decltype(processPlayerFollowActions(p0)) {
	using FunctionType = decltype(processPlayerFollowActions(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x1b2400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::processQueuedAudioTriggers() -> decltype(processQueuedAudioTriggers()) {
	using FunctionType = decltype(processQueuedAudioTriggers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1be520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processQueuedButtons() -> decltype(processQueuedButtons()) {
	using FunctionType = decltype(processQueuedButtons())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b5b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processSFXObjects() -> decltype(processSFXObjects()) {
	using FunctionType = decltype(processSFXObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c3fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::queueButton(int p0, bool p1, bool p2) -> decltype(queueButton(p0, p1, p2)) {
	using FunctionType = decltype(queueButton(p0, p1, p2))(*)(GJBaseGameLayer*, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x1b5af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::reAddToStickyGroup(GameObject* p0) -> decltype(reAddToStickyGroup(p0)) {
	using FunctionType = decltype(reAddToStickyGroup(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1a9e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::refreshCounterLabels() -> decltype(refreshCounterLabels()) {
	using FunctionType = decltype(refreshCounterLabels())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b87a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::refreshKeyframeAnims() -> decltype(refreshKeyframeAnims()) {
	using FunctionType = decltype(refreshKeyframeAnims())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b6d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::regenerateEnterEasingBuffers() -> decltype(regenerateEnterEasingBuffers()) {
	using FunctionType = decltype(regenerateEnterEasingBuffers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x196be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::removeFromGroupParents(GameObject* p0) -> decltype(removeFromGroupParents(p0)) {
	using FunctionType = decltype(removeFromGroupParents(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1a9600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::removeFromGroups(GameObject* p0) -> decltype(removeFromGroups(p0)) {
	using FunctionType = decltype(removeFromGroups(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1a8da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::removeFromStickyGroup(GameObject* p0) -> decltype(removeFromStickyGroup(p0)) {
	using FunctionType = decltype(removeFromStickyGroup(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1a9da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::removeGroupParent(int p0) -> decltype(removeGroupParent(p0)) {
	using FunctionType = decltype(removeGroupParent(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1a9550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::removeKeyframe(KeyframeGameObject* p0) -> decltype(removeKeyframe(p0)) {
	using FunctionType = decltype(removeKeyframe(p0))(*)(GJBaseGameLayer*, KeyframeGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b6c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::removeObjectFromSection(GameObject* p0) -> decltype(removeObjectFromSection(p0)) {
	using FunctionType = decltype(removeObjectFromSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1abea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::removeTemporaryParticles() -> decltype(removeTemporaryParticles()) {
	using FunctionType = decltype(removeTemporaryParticles())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c3d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetActiveEnterEffects() -> decltype(resetActiveEnterEffects()) {
	using FunctionType = decltype(resetActiveEnterEffects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x196350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetCamera() -> decltype(resetCamera()) {
	using FunctionType = decltype(resetCamera())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c22b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetLevelVariables() -> decltype(resetLevelVariables()) {
	using FunctionType = decltype(resetLevelVariables())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bdb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetSongTriggerValues() -> decltype(resetSongTriggerValues()) {
	using FunctionType = decltype(resetSongTriggerValues())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x3bf30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetSpawnChannelIndex() -> decltype(resetSpawnChannelIndex()) {
	using FunctionType = decltype(resetSpawnChannelIndex())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c7e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resumeAudio() -> decltype(resumeAudio()) {
	using FunctionType = decltype(resumeAudio())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bb660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::setGroupParent(GameObject* p0, int p1) -> decltype(setGroupParent(p0, p1)) {
	using FunctionType = decltype(setGroupParent(p0, p1))(*)(GJBaseGameLayer*, GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x1a9460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::setStartPosObject(StartPosObject* p0) -> decltype(setStartPosObject(p0)) {
	using FunctionType = decltype(setStartPosObject(p0))(*)(GJBaseGameLayer*, StartPosObject*);
	static auto func = wrapFunction(base::get() + 0x199e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::setupLayers() -> decltype(setupLayers()) {
	using FunctionType = decltype(setupLayers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x191440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::setupLevelStart(LevelSettingsObject* p0) -> decltype(setupLevelStart(p0)) {
	using FunctionType = decltype(setupLevelStart(p0))(*)(GJBaseGameLayer*, LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x199ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::setupReplay(gd::string p0) -> decltype(setupReplay(p0)) {
	using FunctionType = decltype(setupReplay(p0))(*)(GJBaseGameLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1bd3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::shakeCamera(float p0, float p1, float p2) -> decltype(shakeCamera(p0, p1, p2)) {
	using FunctionType = decltype(shakeCamera(p0, p1, p2))(*)(GJBaseGameLayer*, float, float, float);
	static auto func = wrapFunction(base::get() + 0x1be5d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::shouldExitHackedLevel() -> decltype(shouldExitHackedLevel()) {
	using FunctionType = decltype(shouldExitHackedLevel())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1934a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::sortGroups() -> decltype(sortGroups()) {
	using FunctionType = decltype(sortGroups())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a90f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::sortSectionVector() -> decltype(sortSectionVector()) {
	using FunctionType = decltype(sortSectionVector())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1ac070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::sortStickyGroups() -> decltype(sortStickyGroups()) {
	using FunctionType = decltype(sortStickyGroups())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a99e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::spawnParticle(char const* p0, int p1, cocos2d::tCCPositionType p2, cocos2d::CCPoint p3) -> decltype(spawnParticle(p0, p1, p2, p3)) {
	using FunctionType = decltype(spawnParticle(p0, p1, p2, p3))(*)(GJBaseGameLayer*, char const*, int, cocos2d::tCCPositionType, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x1c2b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::spawnPlayer2() -> decltype(spawnPlayer2()) {
	using FunctionType = decltype(spawnPlayer2())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x19d970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::switchToFlyMode(PlayerObject* p0, GameObject* p1, bool p2, int p3) -> decltype(switchToFlyMode(p0, p1, p2, p3)) {
	using FunctionType = decltype(switchToFlyMode(p0, p1, p2, p3))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*, bool, int);
	static auto func = wrapFunction(base::get() + 0x19a6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::switchToRobotMode(PlayerObject* p0, GameObject* p1, bool p2) -> decltype(switchToRobotMode(p0, p1, p2)) {
	using FunctionType = decltype(switchToRobotMode(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x19a800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::switchToRollMode(PlayerObject* p0, GameObject* p1, bool p2) -> decltype(switchToRollMode(p0, p1, p2)) {
	using FunctionType = decltype(switchToRollMode(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x19a9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::switchToSpiderMode(PlayerObject* p0, GameObject* p1, bool p2) -> decltype(switchToSpiderMode(p0, p1, p2)) {
	using FunctionType = decltype(switchToSpiderMode(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x19a8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::syncBGTextures() -> decltype(syncBGTextures()) {
	using FunctionType = decltype(syncBGTextures())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bda80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::teleportPlayer(TeleportPortalObject* p0, PlayerObject* p1) -> decltype(teleportPlayer(p0, p1)) {
	using FunctionType = decltype(teleportPlayer(p0, p1))(*)(GJBaseGameLayer*, TeleportPortalObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x1980c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::toggleAudioVisualizer(bool p0) -> decltype(toggleAudioVisualizer(p0)) {
	using FunctionType = decltype(toggleAudioVisualizer(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x1ca4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) -> decltype(toggleDualMode(p0, p1, p2, p3)) {
	using FunctionType = decltype(toggleDualMode(p0, p1, p2, p3))(*)(GJBaseGameLayer*, GameObject*, bool, PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x19d6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::toggleFlipped(bool p0, bool p1) -> decltype(toggleFlipped(p0, p1)) {
	using FunctionType = decltype(toggleFlipped(p0, p1))(*)(GJBaseGameLayer*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x1c87e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::tryGetMainObject(int p0) -> decltype(tryGetMainObject(p0)) {
	using FunctionType = decltype(tryGetMainObject(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1a9340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::tryGetObject(int p0) -> decltype(tryGetObject(p0)) {
	using FunctionType = decltype(tryGetObject(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1a9380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::ungroupStickyObjects(cocos2d::CCArray* p0) -> decltype(ungroupStickyObjects(p0)) {
	using FunctionType = decltype(ungroupStickyObjects(p0))(*)(GJBaseGameLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1a9c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateAudioVisualizer() -> decltype(updateAudioVisualizer()) {
	using FunctionType = decltype(updateAudioVisualizer())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1ca410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateCamera(float p0) -> decltype(updateCamera(p0)) {
	using FunctionType = decltype(updateCamera(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x1be670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateCameraMode(EffectGameObject* p0, bool p1) -> decltype(updateCameraMode(p0, p1)) {
	using FunctionType = decltype(updateCameraMode(p0, p1))(*)(GJBaseGameLayer*, EffectGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x19aaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::updateDualGround(PlayerObject* p0, int p1, bool p2, float p3) -> decltype(updateDualGround(p0, p1, p2, p3)) {
	using FunctionType = decltype(updateDualGround(p0, p1, p2, p3))(*)(GJBaseGameLayer*, PlayerObject*, int, bool, float);
	static auto func = wrapFunction(base::get() + 0x19ad50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::updateGradientLayers() -> decltype(updateGradientLayers()) {
	using FunctionType = decltype(updateGradientLayers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a57c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateGuideArt() -> decltype(updateGuideArt()) {
	using FunctionType = decltype(updateGuideArt())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c8700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateKeyframeOrder(int p0) -> decltype(updateKeyframeOrder(p0)) {
	using FunctionType = decltype(updateKeyframeOrder(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1b6ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateLayerCapacity(gd::string p0) -> decltype(updateLayerCapacity(p0)) {
	using FunctionType = decltype(updateLayerCapacity(p0))(*)(GJBaseGameLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x194ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateLevelColors() -> decltype(updateLevelColors()) {
	using FunctionType = decltype(updateLevelColors())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x194490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateMaxGameplayY() -> decltype(updateMaxGameplayY()) {
	using FunctionType = decltype(updateMaxGameplayY())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bd960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updatePlatformerTime() -> decltype(updatePlatformerTime()) {
	using FunctionType = decltype(updatePlatformerTime())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bcd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateShaderLayer(float p0) -> decltype(updateShaderLayer(p0)) {
	using FunctionType = decltype(updateShaderLayer(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x1a7820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateSpecialGroupData() -> decltype(updateSpecialGroupData()) {
	using FunctionType = decltype(updateSpecialGroupData())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x196060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateSpecialLabels() -> decltype(updateSpecialLabels()) {
	using FunctionType = decltype(updateSpecialLabels())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bc9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateStaticCameraPos(cocos2d::CCPoint p0, bool p1, bool p2, bool p3, float p4, int p5, float p6) -> decltype(updateStaticCameraPos(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(updateStaticCameraPos(p0, p1, p2, p3, p4, p5, p6))(*)(GJBaseGameLayer*, cocos2d::CCPoint, bool, bool, bool, float, int, float);
	static auto func = wrapFunction(base::get() + 0x1c1cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto GJBaseGameLayer::updateZoom(float p0, float p1, int p2, float p3, int p4, int p5) -> decltype(updateZoom(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(updateZoom(p0, p1, p2, p3, p4, p5))(*)(GJBaseGameLayer*, float, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x1b9350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJBaseGameLayer::volumeForProximityEffect(SFXTriggerInstance& p0) -> decltype(volumeForProximityEffect(p0)) {
	using FunctionType = decltype(volumeForProximityEffect(p0))(*)(GJBaseGameLayer*, SFXTriggerInstance&);
	static auto func = wrapFunction(base::get() + 0x1c4ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJBaseGameLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x1bb780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::init), this);
	using FunctionType = decltype(init())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x190290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::visit), this);
	using FunctionType = decltype(visit())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c8ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	throw std::runtime_error("GJBaseGameLayer::postUpdate not implemented");
}

auto GJBaseGameLayer::checkForEnd() -> decltype(checkForEnd()) {
	throw std::runtime_error("GJBaseGameLayer::checkForEnd not implemented");
}

auto GJBaseGameLayer::testTime() -> decltype(testTime()) {
	throw std::runtime_error("GJBaseGameLayer::testTime not implemented");
}

auto GJBaseGameLayer::updateVerifyDamage() -> decltype(updateVerifyDamage()) {
	throw std::runtime_error("GJBaseGameLayer::updateVerifyDamage not implemented");
}

auto GJBaseGameLayer::updateAttemptTime(float p0) -> decltype(updateAttemptTime(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateAttemptTime not implemented");
}

auto GJBaseGameLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateVisibility not implemented");
}

auto GJBaseGameLayer::playerTookDamage(PlayerObject* p0) -> decltype(playerTookDamage(p0)) {
	throw std::runtime_error("GJBaseGameLayer::playerTookDamage not implemented");
}

auto GJBaseGameLayer::opacityForObject(GameObject* p0) -> decltype(opacityForObject(p0)) {
	throw std::runtime_error("GJBaseGameLayer::opacityForObject not implemented");
}

auto GJBaseGameLayer::addToSpeedObjects(EffectGameObject* p0) -> decltype(addToSpeedObjects(p0)) {
	throw std::runtime_error("GJBaseGameLayer::addToSpeedObjects not implemented");
}

auto GJBaseGameLayer::objectsCollided(int p0, int p1) -> decltype(objectsCollided(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJBaseGameLayer::objectsCollided), this);
	using FunctionType = decltype(objectsCollided(p0, p1))(*)(GJBaseGameLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x19fac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::updateColor(cocos2d::ccColor3B& p0, float p1, int p2, bool p3, float p4, cocos2d::ccHSVValue& p5, int p6, bool p7, EffectGameObject* p8, int p9, int p10) -> decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int>::func(&GJBaseGameLayer::updateColor), this);
	using FunctionType = decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10))(*)(GJBaseGameLayer*, cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int);
	static auto func = wrapFunction(base::get() + 0x1a8760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
}

auto GJBaseGameLayer::toggleGroupTriggered(int p0, bool p1, gd::vector<int> const& p2, int p3, int p4) -> decltype(toggleGroupTriggered(p0, p1, p2, p3, p4)) {
	throw std::runtime_error("GJBaseGameLayer::toggleGroupTriggered not implemented");
}

auto GJBaseGameLayer::spawnGroup(int p0, bool p1, double p2, gd::vector<int> const& p3, int p4, int p5) -> decltype(spawnGroup(p0, p1, p2, p3, p4, p5)) {
	throw std::runtime_error("GJBaseGameLayer::spawnGroup not implemented");
}

auto GJBaseGameLayer::spawnObject(GameObject* p0, double p1, gd::vector<int> const& p2) -> decltype(spawnObject(p0, p1, p2)) {
	throw std::runtime_error("GJBaseGameLayer::spawnObject not implemented");
}

auto GJBaseGameLayer::activateEndTrigger(int p0, bool p1, bool p2) -> decltype(activateEndTrigger(p0, p1, p2)) {
	throw std::runtime_error("GJBaseGameLayer::activateEndTrigger not implemented");
}

auto GJBaseGameLayer::activatePlatformerEndTrigger(EndTriggerGameObject* p0, gd::vector<int> const& p1) -> decltype(activatePlatformerEndTrigger(p0, p1)) {
	throw std::runtime_error("GJBaseGameLayer::activatePlatformerEndTrigger not implemented");
}

auto GJBaseGameLayer::toggleGlitter(bool p0) -> decltype(toggleGlitter(p0)) {
	throw std::runtime_error("GJBaseGameLayer::toggleGlitter not implemented");
}

auto GJBaseGameLayer::destroyPlayer(PlayerObject* p0, GameObject* p1) -> decltype(destroyPlayer(p0, p1)) {
	throw std::runtime_error("GJBaseGameLayer::destroyPlayer not implemented");
}

auto GJBaseGameLayer::updateDebugDraw() -> decltype(updateDebugDraw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::updateDebugDraw), this);
	using FunctionType = decltype(updateDebugDraw())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1986f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::addToSection(GameObject* p0) -> decltype(addToSection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&GJBaseGameLayer::addToSection), this);
	using FunctionType = decltype(addToSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1ab800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::addToGroup(GameObject* p0, int p1, bool p2) -> decltype(addToGroup(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int, bool>::func(&GJBaseGameLayer::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0, p1, p2))(*)(GJBaseGameLayer*, GameObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x1a8ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GJBaseGameLayer::removeFromGroup(GameObject* p0, int p1) -> decltype(removeFromGroup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int>::func(&GJBaseGameLayer::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0, p1))(*)(GJBaseGameLayer*, GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x1a8e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::updateObjectSection(GameObject* p0) -> decltype(updateObjectSection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&GJBaseGameLayer::updateObjectSection), this);
	using FunctionType = decltype(updateObjectSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1acd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::updateDisabledObjectsLastPos(cocos2d::CCArray* p0) -> decltype(updateDisabledObjectsLastPos(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateDisabledObjectsLastPos not implemented");
}

auto GJBaseGameLayer::toggleGroundVisibility(bool p0) -> decltype(toggleGroundVisibility(p0)) {
	throw std::runtime_error("GJBaseGameLayer::toggleGroundVisibility not implemented");
}

auto GJBaseGameLayer::toggleMGVisibility(bool p0) -> decltype(toggleMGVisibility(p0)) {
	throw std::runtime_error("GJBaseGameLayer::toggleMGVisibility not implemented");
}

auto GJBaseGameLayer::toggleHideAttempts(bool p0) -> decltype(toggleHideAttempts(p0)) {
	throw std::runtime_error("GJBaseGameLayer::toggleHideAttempts not implemented");
}

TodoReturn GJBaseGameLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) {}

TodoReturn GJBaseGameLayer::posForTime(float p0) {}

TodoReturn GJBaseGameLayer::resetSPTriggered() {}

auto GJBaseGameLayer::updateScreenRotation(float p0, bool p1, bool p2, float p3, int p4, float p5, int p6, int p7) -> decltype(updateScreenRotation(p0, p1, p2, p3, p4, p5, p6, p7)) {
	auto self = addresser::thunkAdjust(Resolve<float, bool, bool, float, int, float, int, int>::func(&GJBaseGameLayer::updateScreenRotation), this);
	using FunctionType = decltype(updateScreenRotation(p0, p1, p2, p3, p4, p5, p6, p7))(*)(GJBaseGameLayer*, float, bool, bool, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x1b9450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto GJBaseGameLayer::reverseDirection(EffectGameObject* p0) -> decltype(reverseDirection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<EffectGameObject*>::func(&GJBaseGameLayer::reverseDirection), this);
	using FunctionType = decltype(reverseDirection(p0))(*)(GJBaseGameLayer*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x19efb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::rotateGameplay(RotateGameplayGameObject* p0) -> decltype(rotateGameplay(p0)) {
	auto self = addresser::thunkAdjust(Resolve<RotateGameplayGameObject*>::func(&GJBaseGameLayer::rotateGameplay), this);
	using FunctionType = decltype(rotateGameplay(p0))(*)(GJBaseGameLayer*, RotateGameplayGameObject*);
	static auto func = wrapFunction(base::get() + 0x19f010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::didRotateGameplay() -> decltype(didRotateGameplay()) {
	throw std::runtime_error("GJBaseGameLayer::didRotateGameplay not implemented");
}

auto GJBaseGameLayer::updateTimeWarp(float p0) -> decltype(updateTimeWarp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJBaseGameLayer::updateTimeWarp), this);
	using FunctionType = decltype(updateTimeWarp(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2dfda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::updateTimeWarp(GameObject* p0, float p1) -> decltype(updateTimeWarp(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, float>::func(&GJBaseGameLayer::updateTimeWarp), this);
	using FunctionType = decltype(updateTimeWarp(p0, p1))(*)(GJBaseGameLayer*, GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x2dfda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::applyTimeWarp(float p0) -> decltype(applyTimeWarp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJBaseGameLayer::applyTimeWarp), this);
	using FunctionType = decltype(applyTimeWarp(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x1b9770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::playGravityEffect(bool p0) -> decltype(playGravityEffect(p0)) {
	throw std::runtime_error("GJBaseGameLayer::playGravityEffect not implemented");
}

auto GJBaseGameLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	throw std::runtime_error("GJBaseGameLayer::manualUpdateObjectColors not implemented");
}

auto GJBaseGameLayer::createCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, bool p3) -> decltype(createCustomParticle(p0, p1, p2, p3)) {
	throw std::runtime_error("GJBaseGameLayer::createCustomParticle not implemented");
}

auto GJBaseGameLayer::claimCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, int p3, int p4, bool p5) -> decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5)) {
	throw std::runtime_error("GJBaseGameLayer::claimCustomParticle not implemented");
}

auto GJBaseGameLayer::unclaimCustomParticle(gd::string const& p0, cocos2d::CCParticleSystemQuad* p1) -> decltype(unclaimCustomParticle(p0, p1)) {
	throw std::runtime_error("GJBaseGameLayer::unclaimCustomParticle not implemented");
}

auto GJBaseGameLayer::activatedAudioTrigger(SFXTriggerGameObject* p0) -> decltype(activatedAudioTrigger(p0)) {
	throw std::runtime_error("GJBaseGameLayer::activatedAudioTrigger not implemented");
}

auto GJBaseGameLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CheckpointGameObject*>::func(&GJBaseGameLayer::checkpointActivated), this);
	using FunctionType = decltype(checkpointActivated(p0))(*)(GJBaseGameLayer*, CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x1c8a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::flipArt(bool p0) -> decltype(flipArt(p0)) {
	throw std::runtime_error("GJBaseGameLayer::flipArt not implemented");
}

auto GJBaseGameLayer::addKeyframe(KeyframeGameObject* p0) -> decltype(addKeyframe(p0)) {
	throw std::runtime_error("GJBaseGameLayer::addKeyframe not implemented");
}

auto GJBaseGameLayer::updateTimeLabel(int p0, int p1, bool p2) -> decltype(updateTimeLabel(p0, p1, p2)) {
	throw std::runtime_error("GJBaseGameLayer::updateTimeLabel not implemented");
}

auto GJBaseGameLayer::checkSnapshot() -> decltype(checkSnapshot()) {
	throw std::runtime_error("GJBaseGameLayer::checkSnapshot not implemented");
}

auto GJBaseGameLayer::toggleProgressbar() -> decltype(toggleProgressbar()) {
	throw std::runtime_error("GJBaseGameLayer::toggleProgressbar not implemented");
}

auto GJBaseGameLayer::toggleInfoLabel() -> decltype(toggleInfoLabel()) {
	throw std::runtime_error("GJBaseGameLayer::toggleInfoLabel not implemented");
}

auto GJBaseGameLayer::removeAllCheckpoints() -> decltype(removeAllCheckpoints()) {
	throw std::runtime_error("GJBaseGameLayer::removeAllCheckpoints not implemented");
}

auto GJBaseGameLayer::toggleMusicInPractice() -> decltype(toggleMusicInPractice()) {
	throw std::runtime_error("GJBaseGameLayer::toggleMusicInPractice not implemented");
}

auto GJBigSprite::init() -> decltype(init()) {
	throw std::runtime_error("GJBigSprite::init not implemented");
}

auto GJBigSpriteNode::init() -> decltype(init()) {
	throw std::runtime_error("GJBigSpriteNode::init not implemented");
}

auto GJChestSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2fa380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJChestSprite::switchToState(ChestSpriteState p0, bool p1) -> decltype(switchToState(p0, p1)) {
	using FunctionType = decltype(switchToState(p0, p1))(*)(GJChestSprite*, ChestSpriteState, bool);
	static auto func = wrapFunction(base::get() + 0x2fa590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJChestSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("GJChestSprite::setOpacity not implemented");
}

auto GJChestSprite::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	throw std::runtime_error("GJChestSprite::setColor not implemented");
}

auto GJColorSetupLayer::create(LevelSettingsObject* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x1d5ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJColorSetupLayer::init(LevelSettingsObject* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJColorSetupLayer*, LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x1d5b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJColorSetupLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJColorSetupLayer::keyBackClicked not implemented");
}

auto GJColorSetupLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	throw std::runtime_error("GJColorSetupLayer::colorSelectClosed not implemented");
}

auto GJComment::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x11b650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJComment::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJComment::init), this);
	using FunctionType = decltype(init())(*)(GJComment*);
	static auto func = wrapFunction(base::get() + 0x11b6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJCommentListLayer::create(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, bool blueBorder) -> decltype(create(listView, title, color, width, height, blueBorder)) {
	using FunctionType = decltype(create(listView, title, color, width, height, blueBorder))(*)(BoomListView*, char const*, cocos2d::ccColor4B, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x207dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(listView, title, color, width, height, blueBorder);
}

auto GJCommentListLayer::init(BoomListView* listView, char const* title, cocos2d::ccColor4B color, float width, float height, bool blueBorder) -> decltype(init(listView, title, color, width, height, blueBorder)) {
	using FunctionType = decltype(init(listView, title, color, width, height, blueBorder))(*)(GJCommentListLayer*, BoomListView*, char const*, cocos2d::ccColor4B, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x207eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, listView, title, color, width, height, blueBorder);
}

auto GJDifficultySprite::create(int p0, GJDifficultyName p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x216be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJDifficultySprite::init(int p0, GJDifficultyName p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJDifficultySprite*, int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x216cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJDifficultySprite::updateDifficultyFrame(int p0, GJDifficultyName p1) -> decltype(updateDifficultyFrame(p0, p1)) {
	using FunctionType = decltype(updateDifficultyFrame(p0, p1))(*)(GJDifficultySprite*, int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x216e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJDifficultySprite::updateFeatureState(GJFeatureState p0) -> decltype(updateFeatureState(p0)) {
	using FunctionType = decltype(updateFeatureState(p0))(*)(GJDifficultySprite*, GJFeatureState);
	static auto func = wrapFunction(base::get() + 0x216ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJDifficultySprite::updateFeatureStateFromLevel(GJGameLevel* p0) -> decltype(updateFeatureStateFromLevel(p0)) {
	using FunctionType = decltype(updateFeatureStateFromLevel(p0))(*)(GJDifficultySprite*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x216f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x1db2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJEffectManager::activeColorForIndex(int p0) -> decltype(activeColorForIndex(p0)) {
	using FunctionType = decltype(activeColorForIndex(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x1db7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::calculateBaseActiveColors() -> decltype(calculateBaseActiveColors()) {
	using FunctionType = decltype(calculateBaseActiveColors())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x1db830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::calculateLightBGColor(cocos2d::ccColor3B p0) -> decltype(calculateLightBGColor(p0)) {
	using FunctionType = decltype(calculateLightBGColor(p0))(*)(GJEffectManager*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x1e3b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::colorForPulseEffect(cocos2d::ccColor3B const& p0, PulseEffectAction* p1) -> decltype(colorForPulseEffect(p0, p1)) {
	using FunctionType = decltype(colorForPulseEffect(p0, p1))(*)(GJEffectManager*, cocos2d::ccColor3B const&, PulseEffectAction*);
	static auto func = wrapFunction(base::get() + 0x1e2010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJEffectManager::getColorAction(int p0) -> decltype(getColorAction(p0)) {
	using FunctionType = decltype(getColorAction(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x1dbe80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::getColorSprite(int p0) -> decltype(getColorSprite(p0)) {
	using FunctionType = decltype(getColorSprite(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x1dbf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::loadFromState(EffectManagerState& p0) -> decltype(loadFromState(p0)) {
	using FunctionType = decltype(loadFromState(p0))(*)(GJEffectManager*, EffectManagerState&);
	static auto func = wrapFunction(base::get() + 0x1e44a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::objectsCollided(int p0, int p1) -> decltype(objectsCollided(p0, p1)) {
	using FunctionType = decltype(objectsCollided(p0, p1))(*)(GJEffectManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x1dc3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJEffectManager::playerDied() -> decltype(playerDied()) {
	using FunctionType = decltype(playerDied())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x1e29b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::processCopyColorPulseActions() -> decltype(processCopyColorPulseActions()) {
	using FunctionType = decltype(processCopyColorPulseActions())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x1e1df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::processInheritedColors() -> decltype(processInheritedColors()) {
	using FunctionType = decltype(processInheritedColors())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x1db900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::processPulseActions() -> decltype(processPulseActions()) {
	using FunctionType = decltype(processPulseActions())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x1e1d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::saveToState(EffectManagerState& p0) -> decltype(saveToState(p0)) {
	using FunctionType = decltype(saveToState(p0))(*)(GJEffectManager*, EffectManagerState&);
	static auto func = wrapFunction(base::get() + 0x1e42a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::traverseInheritanceChain(InheritanceNode* p0) -> decltype(traverseInheritanceChain(p0)) {
	using FunctionType = decltype(traverseInheritanceChain(p0))(*)(GJEffectManager*, InheritanceNode*);
	static auto func = wrapFunction(base::get() + 0x1dbb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::wouldCreateLoop(InheritanceNode* p0, int p1) -> decltype(wouldCreateLoop(p0, p1)) {
	using FunctionType = decltype(wouldCreateLoop(p0, p1))(*)(GJEffectManager*, InheritanceNode*, int);
	static auto func = wrapFunction(base::get() + 0x1dbe50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJEffectManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJEffectManager::init), this);
	using FunctionType = decltype(init())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x1db370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGroundLayer::create(int p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, int);
	static auto func = wrapFunction(base::get() + 0x1f73f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJGroundLayer::createLine(int p0) -> decltype(createLine(p0)) {
	using FunctionType = decltype(createLine(p0))(*)(GJGroundLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1f7b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::init(int p0, int p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJGroundLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x1f74a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGroundLayer::loadGroundSprites(int p0, bool p1) -> decltype(loadGroundSprites(p0, p1)) {
	using FunctionType = decltype(loadGroundSprites(p0, p1))(*)(GJGroundLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x1f7900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGroundLayer::updateGround01Color(cocos2d::ccColor3B p0) -> decltype(updateGround01Color(p0)) {
	using FunctionType = decltype(updateGround01Color(p0))(*)(GJGroundLayer*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x1f7ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::updateGround02Color(cocos2d::ccColor3B p0) -> decltype(updateGround02Color(p0)) {
	using FunctionType = decltype(updateGround02Color(p0))(*)(GJGroundLayer*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x1f7b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("GJGroundLayer::draw not implemented");
}

auto GJGroundLayer::showGround() -> decltype(showGround()) {
	throw std::runtime_error("GJGroundLayer::showGround not implemented");
}

auto GJGroundLayer::fadeInGround(float p0) -> decltype(fadeInGround(p0)) {
	throw std::runtime_error("GJGroundLayer::fadeInGround not implemented");
}

auto GJGroundLayer::fadeOutGround(float p0) -> decltype(fadeOutGround(p0)) {
	throw std::runtime_error("GJGroundLayer::fadeOutGround not implemented");
}

auto GJFlyGroundLayer::init() -> decltype(init()) {
	throw std::runtime_error("GJFlyGroundLayer::init not implemented");
}

auto GJFollowCommandLayer::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1ecb80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJFollowCommandLayer::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJFollowCommandLayer*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1ecc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJFollowCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("GJFollowCommandLayer::determineStartValues not implemented");
}

auto GJFollowCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("GJFollowCommandLayer::onClose not implemented");
}

auto GJFollowCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("GJFollowCommandLayer::textChanged not implemented");
}

auto GJFriendRequest::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x1194e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJFriendRequest::create(cocos2d::CCDictionary* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x1190e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJFriendRequest::init() -> decltype(init()) {
	throw std::runtime_error("GJFriendRequest::init not implemented");
}

auto GJGameLevel::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x113a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJGameLevel::create(cocos2d::CCDictionary* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCDictionary*, bool);
	static auto func = wrapFunction(base::get() + 0x112680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJGameLevel::areCoinsVerified() -> decltype(areCoinsVerified()) {
	using FunctionType = decltype(areCoinsVerified())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x116e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GJGameLevel*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x115060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameLevel::getAudioFileName() -> decltype(getAudioFileName()) {
	using FunctionType = decltype(getAudioFileName())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x114440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::getAverageDifficulty() -> decltype(getAverageDifficulty()) {
	using FunctionType = decltype(getAverageDifficulty())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x114180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::getCoinKey(int p0) -> decltype(getCoinKey(p0)) {
	using FunctionType = decltype(getCoinKey(p0))(*)(GJGameLevel*, int);
	static auto func = wrapFunction(base::get() + 0x114220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameLevel::getLengthKey(int p0, bool p1) -> decltype(getLengthKey(p0, p1)) {
	using FunctionType = decltype(getLengthKey(p0, p1))(*)(GJGameLevel*, int, bool);
	static auto func = wrapFunction(base::get() + 0x1140c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGameLevel::getUnpackedLevelDescription() -> decltype(getUnpackedLevelDescription()) {
	using FunctionType = decltype(getUnpackedLevelDescription())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x116f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::savePercentage(int p0, bool p1, int p2, int p3, bool p4) -> decltype(savePercentage(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(savePercentage(p0, p1, p2, p3, p4))(*)(GJGameLevel*, int, bool, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x113d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto GJGameLevel::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJGameLevel::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJGameLevel*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x1160d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGameLevel::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJGameLevel::canEncode not implemented");
}

auto GJGameLevel::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGameLevel::init), this);
	using FunctionType = decltype(init())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x113b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGameLoadingLayer::create(GJGameLevel* level, bool editor) -> decltype(create(level, editor)) {
	using FunctionType = decltype(create(level, editor))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x1ca920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(level, editor);
}

auto GJGameLoadingLayer::init(GJGameLevel* level, bool editor) -> decltype(init(level, editor)) {
	using FunctionType = decltype(init(level, editor))(*)(GJGameLoadingLayer*, GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x1ca9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, level, editor);
}

auto GJGameLoadingLayer::loadLevel() -> decltype(loadLevel()) {
	using FunctionType = decltype(loadLevel())(*)(GJGameLoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x1caab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLoadingLayer::transitionToLoadingLayer(GJGameLevel* level, bool editor) -> decltype(transitionToLoadingLayer(level, editor)) {
	using FunctionType = decltype(transitionToLoadingLayer(level, editor))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x1ca820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(level, editor);
}

auto GJGameLoadingLayer::onEnter() -> decltype(onEnter()) {
	throw std::runtime_error("GJGameLoadingLayer::onEnter not implemented");
}

auto GJGameLoadingLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	throw std::runtime_error("GJGameLoadingLayer::onEnterTransitionDidFinish not implemented");
}

auto ListButtonBarDelegate::listButtonBarSwitchedPage(ListButtonBar* p0, int p1) -> decltype(listButtonBarSwitchedPage(p0, p1)) {
	throw std::runtime_error("ListButtonBarDelegate::listButtonBarSwitchedPage not implemented");
}

auto GJGarageLayer::getItems(int p0, int p1, IconType p2, int p3) -> decltype(getItems(p0, p1, p2, p3)) {
	using FunctionType = decltype(getItems(p0, p1, p2, p3))(*)(GJGarageLayer*, int, int, IconType, int);
	static auto func = wrapFunction(base::get() + 0x1f2310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJGarageLayer::node() -> decltype(node()) {
	using FunctionType = decltype(node())(*)();
	static auto func = wrapFunction(base::get() + 0x1eedc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJGarageLayer::onArrow(cocos2d::CCObject* sender) -> decltype(onArrow(sender)) {
	using FunctionType = decltype(onArrow(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f1bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f3c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onPaint(cocos2d::CCObject* sender) -> decltype(onPaint(sender)) {
	using FunctionType = decltype(onPaint(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f3bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f2d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onShards(cocos2d::CCObject* sender) -> decltype(onShards(sender)) {
	using FunctionType = decltype(onShards(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f3b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onShop(cocos2d::CCObject* sender) -> decltype(onShop(sender)) {
	using FunctionType = decltype(onShop(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f3c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onToggleItem(cocos2d::CCObject* sender) -> decltype(onToggleItem(sender)) {
	using FunctionType = decltype(onToggleItem(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1f3050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::playRainbowEffect() -> decltype(playRainbowEffect()) {
	using FunctionType = decltype(playRainbowEffect())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x1f3a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::selectTab(IconType p0) -> decltype(selectTab(p0)) {
	using FunctionType = decltype(selectTab(p0))(*)(GJGarageLayer*, IconType);
	static auto func = wrapFunction(base::get() + 0x1f1cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGarageLayer::setupIconSelect() -> decltype(setupIconSelect()) {
	using FunctionType = decltype(setupIconSelect())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x1f1170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::setupPage(int p0, IconType p1) -> decltype(setupPage(p0, p1)) {
	using FunctionType = decltype(setupPage(p0, p1))(*)(GJGarageLayer*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x1f1d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGarageLayer::setupSpecialPage() -> decltype(setupSpecialPage()) {
	using FunctionType = decltype(setupSpecialPage())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x1f2590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::updatePlayerColors() -> decltype(updatePlayerColors()) {
	using FunctionType = decltype(updatePlayerColors())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x1f3180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::init), this);
	using FunctionType = decltype(init())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x1ef250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJGarageLayer::keyBackClicked not implemented");
}

auto GJGarageLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("GJGarageLayer::textInputOpened not implemented");
}

auto GJGarageLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("GJGarageLayer::textInputClosed not implemented");
}

auto GJGarageLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("GJGarageLayer::textChanged not implemented");
}

auto GJGarageLayer::listButtonBarSwitchedPage(ListButtonBar* p0, int p1) -> decltype(listButtonBarSwitchedPage(p0, p1)) {
	throw std::runtime_error("GJGarageLayer::listButtonBarSwitchedPage not implemented");
}

auto GJGarageLayer::showUnlockPopup(int p0, UnlockType p1) -> decltype(showUnlockPopup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, UnlockType>::func(&GJGarageLayer::showUnlockPopup), this);
	using FunctionType = decltype(showUnlockPopup(p0, p1))(*)(GJGarageLayer*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x1f32b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJGarageLayer::updateRate() -> decltype(updateRate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::updateRate), this);
	using FunctionType = decltype(updateRate())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x1f3880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("GJGarageLayer::FLAlert_Clicked not implemented");
}

auto GJGarageLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("GJGarageLayer::dialogClosed not implemented");
}

auto GJGarageLayer::playerColorChanged() -> decltype(playerColorChanged()) {
	throw std::runtime_error("GJGarageLayer::playerColorChanged not implemented");
}

auto GJGradientLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x1ca710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJGradientLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGradientLayer::init), this);
	using FunctionType = decltype(init())(*)(GJGradientLayer*);
	static auto func = wrapFunction(base::get() + 0x1ca7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJItemIcon::create(UnlockType p0, int p1, cocos2d::ccColor3B p2, cocos2d::ccColor3B p3, bool p4, bool p5, bool p6, cocos2d::ccColor3B p7) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7))(*)(UnlockType, int, cocos2d::ccColor3B, cocos2d::ccColor3B, bool, bool, bool, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x1f5010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7);
}

auto GJItemIcon::changeToLockedState(float p0) -> decltype(changeToLockedState(p0)) {
	using FunctionType = decltype(changeToLockedState(p0))(*)(GJItemIcon*, float);
	static auto func = wrapFunction(base::get() + 0x1f5920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJItemIcon::darkenStoreItem(cocos2d::ccColor3B p0) -> decltype(darkenStoreItem(p0)) {
	using FunctionType = decltype(darkenStoreItem(p0))(*)(GJItemIcon*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x1f5720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJItemIcon::init(UnlockType p0, int p1, cocos2d::ccColor3B p2, cocos2d::ccColor3B p3, bool p4, bool p5, bool p6, cocos2d::ccColor3B p7) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7))(*)(GJItemIcon*, UnlockType, int, cocos2d::ccColor3B, cocos2d::ccColor3B, bool, bool, bool, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x1f50f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto GJItemIcon::scaleForType(UnlockType p0) -> decltype(scaleForType(p0)) {
	using FunctionType = decltype(scaleForType(p0))(*)(GJItemIcon*, UnlockType);
	static auto func = wrapFunction(base::get() + 0x1f59e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJItemIcon::toggleEnabledState(bool p0) -> decltype(toggleEnabledState(p0)) {
	using FunctionType = decltype(toggleEnabledState(p0))(*)(GJItemIcon*, bool);
	static auto func = wrapFunction(base::get() + 0x1f5870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJItemIcon::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("GJItemIcon::setOpacity not implemented");
}

auto GJLevelList::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x11bf40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJLevelList::completedLevels() -> decltype(completedLevels()) {
	using FunctionType = decltype(completedLevels())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x11cdd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJLevelList::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GJLevelList*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x11d290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLevelList::frameForListDifficulty(int p0, DifficultyIconType p1) -> decltype(frameForListDifficulty(p0, p1)) {
	using FunctionType = decltype(frameForListDifficulty(p0, p1))(*)(GJLevelList*, int, DifficultyIconType);
	static auto func = wrapFunction(base::get() + 0x11d7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJLevelList::getUnpackedDescription() -> decltype(getUnpackedDescription()) {
	using FunctionType = decltype(getUnpackedDescription())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x11c1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJLevelList::showListInfo() -> decltype(showListInfo()) {
	using FunctionType = decltype(showListInfo())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x11cef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJLevelList::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	throw std::runtime_error("GJLevelList::encodeWithCoder not implemented");
}

auto GJLevelList::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJLevelList::canEncode not implemented");
}

auto GJLevelList::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLevelList::init), this);
	using FunctionType = decltype(init())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x11bfe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJLevelScoreCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJLevelScoreCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x87cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLevelScoreCell::init() -> decltype(init()) {
	throw std::runtime_error("GJLevelScoreCell::init not implemented");
}

auto GJLevelScoreCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJLevelScoreCell::draw not implemented");
}

auto GJListLayer::create(BoomListView* p0, char const* p1, cocos2d::ccColor4B p2, float p3, float p4, int p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(BoomListView*, char const*, cocos2d::ccColor4B, float, float, int);
	static auto func = wrapFunction(base::get() + 0x1f8930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

auto GJListLayer::init(BoomListView* p0, char const* p1, cocos2d::ccColor4B p2, float p3, float p4, int p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(GJListLayer*, BoomListView*, char const*, cocos2d::ccColor4B, float, float, int);
	static auto func = wrapFunction(base::get() + 0x1f8a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GJLocalLevelScoreCell::loadFromScore(GJLocalScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJLocalLevelScoreCell*, GJLocalScore*);
	static auto func = wrapFunction(base::get() + 0x878f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLocalLevelScoreCell::updateBGColor(int p0) -> decltype(updateBGColor(p0)) {
	using FunctionType = decltype(updateBGColor(p0))(*)(GJLocalLevelScoreCell*, int);
	static auto func = wrapFunction(base::get() + 0x87b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLocalLevelScoreCell::init() -> decltype(init()) {
	throw std::runtime_error("GJLocalLevelScoreCell::init not implemented");
}

auto GJLocalLevelScoreCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJLocalLevelScoreCell::draw not implemented");
}

auto GJMapPack::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x117650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJMapPack::create(cocos2d::CCDictionary* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x117050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJMapPack::completedMaps() -> decltype(completedMaps()) {
	using FunctionType = decltype(completedMaps())(*)(GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x117ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJMapPack::hasCompletedMapPack() -> decltype(hasCompletedMapPack()) {
	using FunctionType = decltype(hasCompletedMapPack())(*)(GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x117cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

int GJMapPack::totalMaps() {
		if (this->m_levels) {
			return this->m_levels->count();
		}

		return 0;
	}

auto GJMapPack::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMapPack::init), this);
	using FunctionType = decltype(init())(*)(GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x1176f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMessageCell::loadFromMessage(GJUserMessage* p0) -> decltype(loadFromMessage(p0)) {
	using FunctionType = decltype(loadFromMessage(p0))(*)(GJMessageCell*, GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0x8a3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJMessageCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMessageCell::init), this);
	using FunctionType = decltype(init())(*)(GJMessageCell*);
	static auto func = wrapFunction(base::get() + 0x896b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMessageCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJMessageCell::draw not implemented");
}

auto GJMessageCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("GJMessageCell::FLAlert_Clicked not implemented");
}

auto GJMessageCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("GJMessageCell::uploadActionFinished not implemented");
}

auto GJMessageCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("GJMessageCell::uploadActionFailed not implemented");
}

auto GJMessageCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("GJMessageCell::onClosePopup not implemented");
}

auto GJMessagePopup::create(GJUserMessage* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0x20c7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJMessagePopup::init(GJUserMessage* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJMessagePopup*, GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0x20c870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJMessagePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJMessagePopup::keyBackClicked not implemented");
}

auto GJMessagePopup::downloadMessageFinished(GJUserMessage* p0) -> decltype(downloadMessageFinished(p0)) {
	throw std::runtime_error("GJMessagePopup::downloadMessageFinished not implemented");
}

auto GJMessagePopup::downloadMessageFailed(int p0) -> decltype(downloadMessageFailed(p0)) {
	throw std::runtime_error("GJMessagePopup::downloadMessageFailed not implemented");
}

auto GJMessagePopup::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("GJMessagePopup::uploadActionFinished not implemented");
}

auto GJMessagePopup::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("GJMessagePopup::uploadActionFailed not implemented");
}

auto GJMessagePopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("GJMessagePopup::onClosePopup not implemented");
}

auto GJMessagePopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("GJMessagePopup::FLAlert_Clicked not implemented");
}

auto GJMGLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("GJMGLayer::draw not implemented");
}

auto GJMGLayer::showGround() -> decltype(showGround()) {
	throw std::runtime_error("GJMGLayer::showGround not implemented");
}

auto GJMoreGamesLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x1f9090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJMoreGamesLayer::getMoreGamesList() -> decltype(getMoreGamesList()) {
	using FunctionType = decltype(getMoreGamesList())(*)(GJMoreGamesLayer*);
	static auto func = wrapFunction(base::get() + 0x1f9330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJMoreGamesLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMoreGamesLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(GJMoreGamesLayer*);
	static auto func = wrapFunction(base::get() + 0x1f95e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMPDelegate::joinLobbyFinished(int p0) -> decltype(joinLobbyFinished(p0)) {
	throw std::runtime_error("GJMPDelegate::joinLobbyFinished not implemented");
}

auto GJMPDelegate::joinLobbyFailed(int p0, GJMPErrorCode p1) -> decltype(joinLobbyFailed(p0, p1)) {
	throw std::runtime_error("GJMPDelegate::joinLobbyFailed not implemented");
}

auto GJMPDelegate::didUploadMPComment(int p0) -> decltype(didUploadMPComment(p0)) {
	throw std::runtime_error("GJMPDelegate::didUploadMPComment not implemented");
}

auto GJMPDelegate::updateComments() -> decltype(updateComments()) {
	throw std::runtime_error("GJMPDelegate::updateComments not implemented");
}

auto GJMultiplayerManager::addComment(gd::string p0, int p1) -> decltype(addComment(p0, p1)) {
	using FunctionType = decltype(addComment(p0, p1))(*)(GJMultiplayerManager*, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x1fc100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJMultiplayerManager::createAndAddComment(gd::string p0, int p1) -> decltype(createAndAddComment(p0, p1)) {
	using FunctionType = decltype(createAndAddComment(p0, p1))(*)(GJMultiplayerManager*, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x1fbfc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJMultiplayerManager::handleIt(bool p0, gd::string p1, gd::string p2, GJHttpType p3) -> decltype(handleIt(p0, p1, p2, p3)) {
	using FunctionType = decltype(handleIt(p0, p1, p2, p3))(*)(GJMultiplayerManager*, bool, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0x1faf80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJMultiplayerManager::onExitLobbyCompleted(gd::string p0, gd::string p1) -> decltype(onExitLobbyCompleted(p0, p1)) {
	using FunctionType = decltype(onExitLobbyCompleted(p0, p1))(*)(GJMultiplayerManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1fb820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJMultiplayerManager::onJoinLobbyCompleted(gd::string p0, gd::string p1) -> decltype(onJoinLobbyCompleted(p0, p1)) {
	using FunctionType = decltype(onJoinLobbyCompleted(p0, p1))(*)(GJMultiplayerManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1fb220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJMultiplayerManager::onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* p0, cocos2d::extension::CCHttpResponse* p1) -> decltype(onProcessHttpRequestCompleted(p0, p1)) {
	using FunctionType = decltype(onProcessHttpRequestCompleted(p0, p1))(*)(GJMultiplayerManager*, cocos2d::extension::CCHttpClient*, cocos2d::extension::CCHttpResponse*);
	static auto func = wrapFunction(base::get() + 0x1fae60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJMultiplayerManager::onUploadCommentCompleted(gd::string p0, gd::string p1) -> decltype(onUploadCommentCompleted(p0, p1)) {
	using FunctionType = decltype(onUploadCommentCompleted(p0, p1))(*)(GJMultiplayerManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x1fbe80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJMultiplayerManager::ProcessHttpRequest(gd::string p0, gd::string p1, gd::string p2, GJHttpType p3) -> decltype(ProcessHttpRequest(p0, p1, p2, p3)) {
	using FunctionType = decltype(ProcessHttpRequest(p0, p1, p2, p3))(*)(GJMultiplayerManager*, gd::string, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0x1fac50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJMultiplayerManager::uploadComment(gd::string p0, int p1) -> decltype(uploadComment(p0, p1)) {
	using FunctionType = decltype(uploadComment(p0, p1))(*)(GJMultiplayerManager*, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x1fb970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJMultiplayerManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMultiplayerManager::init), this);
	using FunctionType = decltype(init())(*)(GJMultiplayerManager*);
	static auto func = wrapFunction(base::get() + 0x1fb1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ObjectDecoderDelegate::getDecodedObject(int p0, DS_Dictionary* p1) -> decltype(getDecodedObject(p0, p1)) {
	throw std::runtime_error("ObjectDecoderDelegate::getDecodedObject not implemented");
}

auto GJObjectDecoder::sharedDecoder() -> decltype(sharedDecoder()) {
	using FunctionType = decltype(sharedDecoder())(*)();
	static auto func = wrapFunction(base::get() + 0x1fc3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJObjectDecoder::init() -> decltype(init()) {
	throw std::runtime_error("GJObjectDecoder::init not implemented");
}

auto GJObjectDecoder::getDecodedObject(int p0, DS_Dictionary* p1) -> decltype(getDecodedObject(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, DS_Dictionary*>::func(&GJObjectDecoder::getDecodedObject), this);
	using FunctionType = decltype(getDecodedObject(p0, p1))(*)(GJObjectDecoder*, int, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x1fc490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJPurchaseDelegate::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	throw std::runtime_error("GJPurchaseDelegate::didPurchaseItem not implemented");
}

auto GJPathPage::create(int p0, GJPathsLayer* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x1fd2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJPathPage::init(int p0, GJPathsLayer* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJPathPage*, int, GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x1fd370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJPathPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("GJPathPage::registerWithTouchDispatcher not implemented");
}

auto GJPathPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJPathPage::keyBackClicked not implemented");
}

auto GJPathPage::show() -> decltype(show()) {
	throw std::runtime_error("GJPathPage::show not implemented");
}

auto GJPathPage::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	throw std::runtime_error("GJPathPage::didPurchaseItem not implemented");
}

auto GJPathRewardPopup::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x200930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJPathRewardPopup::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJPathRewardPopup*, int);
	static auto func = wrapFunction(base::get() + 0x2009d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPathRewardPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJPathRewardPopup::keyBackClicked not implemented");
}

auto GJPathsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x1fcb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJPathsLayer::nameForPath(int p0) -> decltype(nameForPath(p0)) {
	using FunctionType = decltype(nameForPath(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x1fc9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJPathsLayer::onPath(cocos2d::CCObject* sender) -> decltype(onPath(sender)) {
	using FunctionType = decltype(onPath(sender))(*)(GJPathsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1fd0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::init), this);
	using FunctionType = decltype(init())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x1fcbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("GJPathsLayer::onExit not implemented");
}

auto GJPathsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("GJPathsLayer::registerWithTouchDispatcher not implemented");
}

auto GJPathsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJPathsLayer::keyBackClicked not implemented");
}

auto GJPathsLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::show), this);
	using FunctionType = decltype(show())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x5d6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x200120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJPathSprite::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJPathSprite*, int);
	static auto func = wrapFunction(base::get() + 0x2001e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPathSprite::updateState() -> decltype(updateState()) {
	using FunctionType = decltype(updateState())(*)(GJPathSprite*);
	static auto func = wrapFunction(base::get() + 0x2002c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPFollowCommandLayer::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2010e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJPFollowCommandLayer::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJPFollowCommandLayer*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x201190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJPFollowCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("GJPFollowCommandLayer::determineStartValues not implemented");
}

auto GJPFollowCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("GJPFollowCommandLayer::onClose not implemented");
}

auto GJPFollowCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("GJPFollowCommandLayer::textChanged not implemented");
}

auto GJPromoPopup::create(gd::string p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x216860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJPromoPopup::init(gd::string p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJPromoPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x216920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPromoPopup::onExit() -> decltype(onExit()) {
	throw std::runtime_error("GJPromoPopup::onExit not implemented");
}

auto GJPromoPopup::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("GJPromoPopup::registerWithTouchDispatcher not implemented");
}

auto GJPromoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJPromoPopup::keyBackClicked not implemented");
}

auto GJPromoPopup::show() -> decltype(show()) {
	throw std::runtime_error("GJPromoPopup::show not implemented");
}

auto GJRequestCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJRequestCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x896e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRequestCell::init() -> decltype(init()) {
	throw std::runtime_error("GJRequestCell::init not implemented");
}

auto GJRequestCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJRequestCell::draw not implemented");
}

auto GJRequestCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("GJRequestCell::FLAlert_Clicked not implemented");
}

auto GJRequestCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("GJRequestCell::uploadActionFinished not implemented");
}

auto GJRequestCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("GJRequestCell::uploadActionFailed not implemented");
}

auto GJRequestCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("GJRequestCell::onClosePopup not implemented");
}

auto GJRewardDelegate::rewardsStatusFinished(int p0) -> decltype(rewardsStatusFinished(p0)) {
	throw std::runtime_error("GJRewardDelegate::rewardsStatusFinished not implemented");
}

auto GJRewardDelegate::rewardsStatusFailed() -> decltype(rewardsStatusFailed()) {
	throw std::runtime_error("GJRewardDelegate::rewardsStatusFailed not implemented");
}

auto GJRewardItem::createSpecial(GJRewardType p0, int p1, int p2, SpecialRewardItem p3, int p4, SpecialRewardItem p5, int p6, int p7, int p8) -> decltype(createSpecial(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(createSpecial(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(GJRewardItem*, GJRewardType, int, int, SpecialRewardItem, int, SpecialRewardItem, int, int, int);
	static auto func = wrapFunction(base::get() + 0x181cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto GJRewardItem::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(GJRewardItem*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x1826b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRewardItem::createWithObjects(GJRewardType p0, cocos2d::CCArray* p1) -> decltype(createWithObjects(p0, p1)) {
	using FunctionType = decltype(createWithObjects(p0, p1))(*)(GJRewardItem*, GJRewardType, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x181e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJRewardItem::getRewardObjectForType(SpecialRewardItem p0) -> decltype(getRewardObjectForType(p0)) {
	using FunctionType = decltype(getRewardObjectForType(p0))(*)(GJRewardItem*, SpecialRewardItem);
	static auto func = wrapFunction(base::get() + 0x1825b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRewardItem::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	throw std::runtime_error("GJRewardItem::encodeWithCoder not implemented");
}

auto GJRewardItem::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJRewardItem::canEncode not implemented");
}

auto GJRewardObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x181ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJRewardObject::create(SpecialRewardItem p0, int p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(SpecialRewardItem, int, int);
	static auto func = wrapFunction(base::get() + 0x181c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto GJRewardObject::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(GJRewardObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x181d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRewardObject::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	throw std::runtime_error("GJRewardObject::encodeWithCoder not implemented");
}

auto GJRewardObject::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJRewardObject::canEncode not implemented");
}

auto GJRobotSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x217510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJRobotSprite::init(int p0, gd::string p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJRobotSprite*, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x2175e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJRobotSprite::updateColors() -> decltype(updateColors()) {
	using FunctionType = decltype(updateColors())(*)(GJRobotSprite*);
	static auto func = wrapFunction(base::get() + 0x217b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJRobotSprite::updateFrame(int p0) -> decltype(updateFrame(p0)) {
	using FunctionType = decltype(updateFrame(p0))(*)(GJRobotSprite*, int);
	static auto func = wrapFunction(base::get() + 0x2180b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRobotSprite::updateGlowColor(cocos2d::ccColor3B p0, bool p1) -> decltype(updateGlowColor(p0, p1)) {
	using FunctionType = decltype(updateGlowColor(p0, p1))(*)(GJRobotSprite*, cocos2d::ccColor3B, bool);
	static auto func = wrapFunction(base::get() + 0x217b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJRobotSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GJRobotSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GJRobotSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x217ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRobotSprite::hideSecondary() -> decltype(hideSecondary()) {
	throw std::runtime_error("GJRobotSprite::hideSecondary not implemented");
}

auto GJRotateCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("GJRotateCommandLayer::determineStartValues not implemented");
}

auto GJRotateCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("GJRotateCommandLayer::onClose not implemented");
}

auto GJRotateCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("GJRotateCommandLayer::textChanged not implemented");
}

auto GJRotateCommandLayer::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("GJRotateCommandLayer::valuePopupClosed not implemented");
}

auto GJRotationControl::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0xddc40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJRotationControl::finishTouch() -> decltype(finishTouch()) {
	using FunctionType = decltype(finishTouch())(*)(GJRotationControl*);
	static auto func = wrapFunction(base::get() + 0xddf70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJRotationControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRotationControl::init), this);
	using FunctionType = decltype(init())(*)(GJRotationControl*);
	static auto func = wrapFunction(base::get() + 0xddce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotationControl::draw() -> decltype(draw()) {
	throw std::runtime_error("GJRotationControl::draw not implemented");
}

auto GJRotationControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("GJRotationControl::ccTouchBegan not implemented");
}

auto GJRotationControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("GJRotationControl::ccTouchMoved not implemented");
}

auto GJRotationControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("GJRotationControl::ccTouchEnded not implemented");
}

auto GJRotationControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("GJRotationControl::ccTouchCancelled not implemented");
}

auto GJScaleControl::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0xde1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJScaleControl::loadValues(GameObject* p0, cocos2d::CCArray* p1, gd::unordered_map<int, GameObjectEditorState>& p2) -> decltype(loadValues(p0, p1, p2)) {
	using FunctionType = decltype(loadValues(p0, p1, p2))(*)(GJScaleControl*, GameObject*, cocos2d::CCArray*, gd::unordered_map<int, GameObjectEditorState>&);
	static auto func = wrapFunction(base::get() + 0xde650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJScaleControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJScaleControl::init), this);
	using FunctionType = decltype(init())(*)(GJScaleControl*);
	static auto func = wrapFunction(base::get() + 0xde260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJScaleControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("GJScaleControl::ccTouchBegan not implemented");
}

auto GJScaleControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("GJScaleControl::ccTouchMoved not implemented");
}

auto GJScaleControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("GJScaleControl::ccTouchEnded not implemented");
}

auto GJScaleControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("GJScaleControl::ccTouchCancelled not implemented");
}

auto GJScoreCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJScoreCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x865b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJScoreCell::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(GJScoreCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x876f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJScoreCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJScoreCell::init), this);
	using FunctionType = decltype(init())(*)(GJScoreCell*);
	static auto func = wrapFunction(base::get() + 0x83190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJScoreCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJScoreCell::draw not implemented");
}

auto GJScoreCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("GJScoreCell::FLAlert_Clicked not implemented");
}

auto GJSearchObject::create(SearchType searchType, gd::string searchQuery, gd::string difficulty, gd::string length, int page, bool star, bool uncompleted, bool featured, int songID, bool original, bool twoPlayer, bool customSong, bool songFilter, bool noStar, bool coins, bool epic, bool legendary, bool mythic, bool onlyCompleted, int demonFilter, int folder, int searchMode) -> decltype(create(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode)) {
	using FunctionType = decltype(create(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode))(*)(SearchType, gd::string, gd::string, gd::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, int, int, int);
	static auto func = wrapFunction(base::get() + 0x11a480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode);
}

auto GJSearchObject::create(SearchType searchType, gd::string searchQuery) -> decltype(create(searchType, searchQuery)) {
	using FunctionType = decltype(create(searchType, searchQuery))(*)(SearchType, gd::string);
	static auto func = wrapFunction(base::get() + 0x11a380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(searchType, searchQuery);
}

auto GJSearchObject::create(SearchType searchType) -> decltype(create(searchType)) {
	using FunctionType = decltype(create(searchType))(*)(SearchType);
	static auto func = wrapFunction(base::get() + 0x11a290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(searchType);
}

auto GJSearchObject::createFromKey(char const* key) -> decltype(createFromKey(key)) {
	using FunctionType = decltype(createFromKey(key))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x119ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(key);
}

auto GJSearchObject::getKey() -> decltype(getKey()) {
	using FunctionType = decltype(getKey())(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x11a7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJSearchObject::getPageObject(int page) -> decltype(getPageObject(page)) {
	using FunctionType = decltype(getPageObject(page))(*)(GJSearchObject*, int);
	static auto func = wrapFunction(base::get() + 0x11aa90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, page);
}

auto GJSearchObject::init(SearchType searchType, gd::string searchQuery, gd::string difficulty, gd::string length, int page, bool star, bool uncompleted, bool featured, int songID, bool original, bool twoPlayer, bool customSong, bool songFilter, bool noStar, bool coins, bool epic, bool legendary, bool mythic, bool onlyCompleted, int demonFilter, int folder, int searchMode) -> decltype(init(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode)) {
	using FunctionType = decltype(init(searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode))(*)(GJSearchObject*, SearchType, gd::string, gd::string, gd::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, int, int, int);
	static auto func = wrapFunction(base::get() + 0x11a630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, searchType, searchQuery, difficulty, length, page, star, uncompleted, featured, songID, original, twoPlayer, customSong, songFilter, noStar, coins, epic, legendary, mythic, onlyCompleted, demonFilter, folder, searchMode);
}

auto GJSearchObject::isLevelSearchObject() -> decltype(isLevelSearchObject()) {
	using FunctionType = decltype(isLevelSearchObject())(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x11ade0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJShopLayer::create(ShopType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(ShopType);
	static auto func = wrapFunction(base::get() + 0x219ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJShopLayer::init(ShopType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJShopLayer*, ShopType);
	static auto func = wrapFunction(base::get() + 0x219b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJShopLayer::onSelectItem(cocos2d::CCObject* sender) -> decltype(onSelectItem(sender)) {
	using FunctionType = decltype(onSelectItem(sender))(*)(GJShopLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x21b2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJShopLayer::scene(ShopType p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(GJShopLayer*, ShopType);
	static auto func = wrapFunction(base::get() + 0x219a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJShopLayer::showReactMessage() -> decltype(showReactMessage()) {
	using FunctionType = decltype(showReactMessage())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x21be50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJShopLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("GJShopLayer::onExit not implemented");
}

auto GJShopLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("GJShopLayer::ccTouchBegan not implemented");
}

auto GJShopLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("GJShopLayer::ccTouchMoved not implemented");
}

auto GJShopLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("GJShopLayer::ccTouchEnded not implemented");
}

auto GJShopLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("GJShopLayer::ccTouchCancelled not implemented");
}

auto GJShopLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("GJShopLayer::registerWithTouchDispatcher not implemented");
}

auto GJShopLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJShopLayer::keyBackClicked not implemented");
}

auto GJShopLayer::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	throw std::runtime_error("GJShopLayer::didPurchaseItem not implemented");
}

auto GJShopLayer::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	throw std::runtime_error("GJShopLayer::rewardedVideoFinished not implemented");
}

auto GJShopLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("GJShopLayer::dialogClosed not implemented");
}

auto GJSmartBlockPreview::create(gd::string p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x222fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJSmartBlockPreview::init(gd::string p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJSmartBlockPreview*, gd::string);
	static auto func = wrapFunction(base::get() + 0x223080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartBlockPreviewSprite::init() -> decltype(init()) {
	throw std::runtime_error("GJSmartBlockPreviewSprite::init not implemented");
}

auto GJSmartBlockPreviewSprite::visit() -> decltype(visit()) {
	throw std::runtime_error("GJSmartBlockPreviewSprite::visit not implemented");
}

auto GJSmartPrefab::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x222e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJSmartPrefab::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GJSmartPrefab*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x222ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartPrefab::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	throw std::runtime_error("GJSmartPrefab::encodeWithCoder not implemented");
}

auto GJSmartPrefab::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJSmartPrefab::canEncode not implemented");
}

auto GJSmartTemplate::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x21e860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJSmartTemplate::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GJSmartTemplate*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x222ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartTemplate::init() -> decltype(init()) {
	using FunctionType = decltype(init())(*)(GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0x21e900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJSmartTemplate::logTemplateStatus(bool p0) -> decltype(logTemplateStatus(p0)) {
	using FunctionType = decltype(logTemplateStatus(p0))(*)(GJSmartTemplate*, bool);
	static auto func = wrapFunction(base::get() + 0x222330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartTemplate::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	throw std::runtime_error("GJSmartTemplate::encodeWithCoder not implemented");
}

auto GJSmartTemplate::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("GJSmartTemplate::canEncode not implemented");
}

auto TableViewCellDelegate::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("TableViewCellDelegate::cellPerformedAction not implemented");
}

auto TableViewCellDelegate::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	throw std::runtime_error("TableViewCellDelegate::getSelectedCellIdx not implemented");
}

auto TableViewCellDelegate::shouldSnapToSelected() -> decltype(shouldSnapToSelected()) {
	throw std::runtime_error("TableViewCellDelegate::shouldSnapToSelected not implemented");
}

auto GJSongBrowser::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x224e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJSongBrowser::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(GJSongBrowser*, int);
	static auto func = wrapFunction(base::get() + 0x2253c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSongBrowser::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSongBrowser::init), this);
	using FunctionType = decltype(init())(*)(GJSongBrowser*);
	static auto func = wrapFunction(base::get() + 0x224fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSongBrowser::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSongBrowser::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(GJSongBrowser*);
	static auto func = wrapFunction(base::get() + 0x225080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSongBrowser::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&GJSongBrowser::exitLayer), this);
	using FunctionType = decltype(exitLayer(p0))(*)(GJSongBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x225010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJSongBrowser::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJSongBrowser::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJSongBrowser*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2257d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJSongBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("GJSongBrowser::cellPerformedAction not implemented");
}

auto GJSongBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	throw std::runtime_error("GJSongBrowser::getSelectedCellIdx not implemented");
}

auto GJSpecialColorSelect::create(int p0, GJSpecialColorSelectDelegate* p1, ColorSelectType p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(int, GJSpecialColorSelectDelegate*, ColorSelectType);
	static auto func = wrapFunction(base::get() + 0x225b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto GJSpecialColorSelect::init(int p0, GJSpecialColorSelectDelegate* p1, ColorSelectType p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(GJSpecialColorSelect*, int, GJSpecialColorSelectDelegate*, ColorSelectType);
	static auto func = wrapFunction(base::get() + 0x225bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJSpecialColorSelect::textForColorIdx(int p0) -> decltype(textForColorIdx(p0)) {
	using FunctionType = decltype(textForColorIdx(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2265d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJSpecialColorSelect::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJSpecialColorSelect::keyBackClicked not implemented");
}

auto GJSpiderSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2186e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJStoreItem::create(int p0, int p1, int p2, int p3, ShopType p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(int, int, int, int, ShopType);
	static auto func = wrapFunction(base::get() + 0x182d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto GJStoreItem::getCurrencyKey() -> decltype(getCurrencyKey()) {
	using FunctionType = decltype(getCurrencyKey())(*)(GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x182ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJStoreItem::init(int p0, int p1, int p2, int p3, ShopType p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(GJStoreItem*, int, int, int, int, ShopType);
	static auto func = wrapFunction(base::get() + 0x182dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto GJTransformControl::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0xdf700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJTransformControl::applyRotation(float p0) -> decltype(applyRotation(p0)) {
	using FunctionType = decltype(applyRotation(p0))(*)(GJTransformControl*, float);
	static auto func = wrapFunction(base::get() + 0xe14d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJTransformControl::loadValues(GameObject* p0, cocos2d::CCArray* p1, gd::unordered_map<int, GameObjectEditorState>& p2) -> decltype(loadValues(p0, p1, p2)) {
	using FunctionType = decltype(loadValues(p0, p1, p2))(*)(GJTransformControl*, GameObject*, cocos2d::CCArray*, gd::unordered_map<int, GameObjectEditorState>&);
	static auto func = wrapFunction(base::get() + 0xdfda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJTransformControl::scaleButtons(float p0) -> decltype(scaleButtons(p0)) {
	using FunctionType = decltype(scaleButtons(p0))(*)(GJTransformControl*, float);
	static auto func = wrapFunction(base::get() + 0xdfd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJTransformControl::updateButtons(bool p0, bool p1) -> decltype(updateButtons(p0, p1)) {
	using FunctionType = decltype(updateButtons(p0, p1))(*)(GJTransformControl*, bool, bool);
	static auto func = wrapFunction(base::get() + 0xdffc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJTransformControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJTransformControl::init), this);
	using FunctionType = decltype(init())(*)(GJTransformControl*);
	static auto func = wrapFunction(base::get() + 0xdf7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJTransformControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("GJTransformControl::ccTouchBegan not implemented");
}

auto GJTransformControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("GJTransformControl::ccTouchMoved not implemented");
}

auto GJTransformControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("GJTransformControl::ccTouchEnded not implemented");
}

auto GJTransformControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("GJTransformControl::ccTouchCancelled not implemented");
}

auto GJUINode::create(UIButtonConfig& p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(UIButtonConfig&);
	static auto func = wrapFunction(base::get() + 0x3c0230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJUINode::init(UIButtonConfig& p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJUINode*, UIButtonConfig&);
	static auto func = wrapFunction(base::get() + 0x3c02d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJUINode::resetState() -> decltype(resetState()) {
	using FunctionType = decltype(resetState())(*)(GJUINode*);
	static auto func = wrapFunction(base::get() + 0x3c04f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJUINode::draw() -> decltype(draw()) {
	throw std::runtime_error("GJUINode::draw not implemented");
}

auto GJUserCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJUserCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x88750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJUserCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUserCell::init), this);
	using FunctionType = decltype(init())(*)(GJUserCell*);
	static auto func = wrapFunction(base::get() + 0x88730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJUserCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJUserCell::draw not implemented");
}

auto GJUserCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("GJUserCell::FLAlert_Clicked not implemented");
}

auto GJUserCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("GJUserCell::uploadActionFinished not implemented");
}

auto GJUserCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("GJUserCell::uploadActionFailed not implemented");
}

auto GJUserCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("GJUserCell::onClosePopup not implemented");
}

auto GJUserMessage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x119d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJUserMessage::init() -> decltype(init()) {
	throw std::runtime_error("GJUserMessage::init not implemented");
}

auto GJUserScore::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x118ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJUserScore::create(cocos2d::CCDictionary* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x117ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJUserScore::isCurrentUser() -> decltype(isCurrentUser()) {
	using FunctionType = decltype(isCurrentUser())(*)(GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x118fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJUserScore::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUserScore::init), this);
	using FunctionType = decltype(init())(*)(GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x118f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadMessageDelegate::uploadMessageFinished(int p0) -> decltype(uploadMessageFinished(p0)) {
	throw std::runtime_error("UploadMessageDelegate::uploadMessageFinished not implemented");
}

auto UploadMessageDelegate::uploadMessageFailed(int p0) -> decltype(uploadMessageFailed(p0)) {
	throw std::runtime_error("UploadMessageDelegate::uploadMessageFailed not implemented");
}

auto GJWriteMessagePopup::create(int p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, int);
	static auto func = wrapFunction(base::get() + 0x20df90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJWriteMessagePopup::init(int p0, int p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJWriteMessagePopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x20e040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJWriteMessagePopup::updateBody(gd::string p0) -> decltype(updateBody(p0)) {
	using FunctionType = decltype(updateBody(p0))(*)(GJWriteMessagePopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x20f0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJWriteMessagePopup::updateCharCountLabel(int p0) -> decltype(updateCharCountLabel(p0)) {
	using FunctionType = decltype(updateCharCountLabel(p0))(*)(GJWriteMessagePopup*, int);
	static auto func = wrapFunction(base::get() + 0x20f340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJWriteMessagePopup::updateSubject(gd::string p0) -> decltype(updateSubject(p0)) {
	using FunctionType = decltype(updateSubject(p0))(*)(GJWriteMessagePopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x20f060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJWriteMessagePopup::updateText(gd::string p0, int p1) -> decltype(updateText(p0, p1)) {
	using FunctionType = decltype(updateText(p0, p1))(*)(GJWriteMessagePopup*, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x20f160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJWriteMessagePopup::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("GJWriteMessagePopup::registerWithTouchDispatcher not implemented");
}

auto GJWriteMessagePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("GJWriteMessagePopup::keyBackClicked not implemented");
}

auto GJWriteMessagePopup::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("GJWriteMessagePopup::textInputOpened not implemented");
}

auto GJWriteMessagePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("GJWriteMessagePopup::textInputClosed not implemented");
}

auto GJWriteMessagePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("GJWriteMessagePopup::textChanged not implemented");
}

auto GJWriteMessagePopup::uploadMessageFinished(int p0) -> decltype(uploadMessageFinished(p0)) {
	throw std::runtime_error("GJWriteMessagePopup::uploadMessageFinished not implemented");
}

auto GJWriteMessagePopup::uploadMessageFailed(int p0) -> decltype(uploadMessageFailed(p0)) {
	throw std::runtime_error("GJWriteMessagePopup::uploadMessageFailed not implemented");
}

auto GJWriteMessagePopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("GJWriteMessagePopup::onClosePopup not implemented");
}

auto GJWriteMessagePopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("GJWriteMessagePopup::FLAlert_Clicked not implemented");
}

auto GJWriteMessagePopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("GJWriteMessagePopup::textInputShouldOffset not implemented");
}

auto GJWriteMessagePopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("GJWriteMessagePopup::textInputReturn not implemented");
}

void GooglePlayDelegate::googlePlaySignedIn() {}

auto GooglePlayManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x478b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GooglePlayManager::init() -> decltype(init()) {
	throw std::runtime_error("GooglePlayManager::init not implemented");
}

auto GradientTriggerObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3915d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GradientTriggerObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GradientTriggerObject::init), this);
	using FunctionType = decltype(init())(*)(GradientTriggerObject*);
	static auto func = wrapFunction(base::get() + 0x391670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GradientTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("GradientTriggerObject::customObjectSetup not implemented");
}

auto GradientTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("GradientTriggerObject::getSaveString not implemented");
}

auto GraphicsReloadLayer::create(cocos2d::TextureQuality p0, cocos2d::CCSize p1, bool p2, bool p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::TextureQuality, cocos2d::CCSize, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2b8460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto GraphicsReloadLayer::init(cocos2d::TextureQuality p0, cocos2d::CCSize p1, bool p2, bool p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(GraphicsReloadLayer*, cocos2d::TextureQuality, cocos2d::CCSize, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2b8520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GravityEffectSprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2eba40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GravityEffectSprite::updateSpritesColor(cocos2d::ccColor3B p0) -> decltype(updateSpritesColor(p0)) {
	using FunctionType = decltype(updateSpritesColor(p0))(*)(GravityEffectSprite*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x2ebd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GravityEffectSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GravityEffectSprite::init), this);
	using FunctionType = decltype(init())(*)(GravityEffectSprite*);
	static auto func = wrapFunction(base::get() + 0x2ebb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GravityEffectSprite::draw() -> decltype(draw()) {
	throw std::runtime_error("GravityEffectSprite::draw not implemented");
}

auto HardStreak::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2267c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto HardStreak::addPoint(cocos2d::CCPoint p0) -> decltype(addPoint(p0)) {
	using FunctionType = decltype(addPoint(p0))(*)(HardStreak*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x227250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto HardStreak::firstSetup() -> decltype(firstSetup()) {
	using FunctionType = decltype(firstSetup())(*)(HardStreak*);
	static auto func = wrapFunction(base::get() + 0x2268c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto HardStreak::updateStroke(float p0) -> decltype(updateStroke(p0)) {
	using FunctionType = decltype(updateStroke(p0))(*)(HardStreak*, float);
	static auto func = wrapFunction(base::get() + 0x226960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto HardStreak::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&HardStreak::init), this);
	using FunctionType = decltype(init())(*)(HardStreak*);
	static auto func = wrapFunction(base::get() + 0x226860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto HSVLiveOverlay::create(GameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x227740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto HSVLiveOverlay::init(GameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(HSVLiveOverlay*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2277f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto HSVLiveOverlay::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("HSVLiveOverlay::keyBackClicked not implemented");
}

auto HSVLiveOverlay::show() -> decltype(show()) {
	throw std::runtime_error("HSVLiveOverlay::show not implemented");
}

auto HSVLiveOverlay::hsvChanged(ConfigureHSVWidget* p0) -> decltype(hsvChanged(p0)) {
	throw std::runtime_error("HSVLiveOverlay::hsvChanged not implemented");
}

auto HSVWidgetPopup::create(cocos2d::ccHSVValue p0, HSVWidgetDelegate* p1, gd::string p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(cocos2d::ccHSVValue, HSVWidgetDelegate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x6a970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto HSVWidgetPopup::init(cocos2d::ccHSVValue p0, HSVWidgetDelegate* p1, gd::string p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(HSVWidgetPopup*, cocos2d::ccHSVValue, HSVWidgetDelegate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x6aa50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto HSVWidgetPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("HSVWidgetPopup::keyBackClicked not implemented");
}

auto InfoAlertButton::create(gd::string p0, gd::string p1, float p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(gd::string, gd::string, float);
	static auto func = wrapFunction(base::get() + 0x228110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto InfoAlertButton::init(gd::string p0, gd::string p1, float p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(InfoAlertButton*, gd::string, gd::string, float);
	static auto func = wrapFunction(base::get() + 0x228230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto InfoAlertButton::activate() -> decltype(activate()) {
	throw std::runtime_error("InfoAlertButton::activate not implemented");
}

void LevelCommentDelegate::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) {}

void LevelCommentDelegate::loadCommentsFailed(char const* p0) {}

void LevelCommentDelegate::updateUserScoreFinished() {}

void LevelCommentDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto InfoLayer::create(GJGameLevel* p0, GJUserScore* p1, GJLevelList* p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(GJGameLevel*, GJUserScore*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x228730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

int InfoLayer::getID() {
		if(m_score) return m_score->m_userID;
		if(m_levelList) return - m_levelList->m_listID;
		if(m_level) return m_level->m_levelID;
		return 0;
	}

auto InfoLayer::getSpriteButton(char const* p0, cocos2d::SEL_MenuHandler p1, cocos2d::CCMenu* p2, float p3, cocos2d::CCPoint p4) -> decltype(getSpriteButton(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(getSpriteButton(p0, p1, p2, p3, p4))(*)(InfoLayer*, char const*, cocos2d::SEL_MenuHandler, cocos2d::CCMenu*, float, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x22a410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto InfoLayer::init(GJGameLevel* p0, GJUserScore* p1, GJLevelList* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(InfoLayer*, GJGameLevel*, GJUserScore*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x228810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto InfoLayer::loadPage(int p0, bool p1) -> decltype(loadPage(p0, p1)) {
	using FunctionType = decltype(loadPage(p0, p1))(*)(InfoLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x22b340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto InfoLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22b200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onComment(cocos2d::CCObject* sender) -> decltype(onComment(sender)) {
	using FunctionType = decltype(onComment(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22aba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onCopyLevelID(cocos2d::CCObject* sender) -> decltype(onCopyLevelID(sender)) {
	using FunctionType = decltype(onCopyLevelID(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22a8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onGetComments(cocos2d::CCObject* sender) -> decltype(onGetComments(sender)) {
	using FunctionType = decltype(onGetComments(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22ad90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onLevelInfo(cocos2d::CCObject* sender) -> decltype(onLevelInfo(sender)) {
	using FunctionType = decltype(onLevelInfo(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22ada0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onMore(cocos2d::CCObject* sender) -> decltype(onMore(sender)) {
	using FunctionType = decltype(onMore(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22aaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22bac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onOriginal(cocos2d::CCObject* sender) -> decltype(onOriginal(sender)) {
	using FunctionType = decltype(onOriginal(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22aae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22bae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onRefreshComments(cocos2d::CCObject* sender) -> decltype(onRefreshComments(sender)) {
	using FunctionType = decltype(onRefreshComments(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22a680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::reloadWindow() -> decltype(reloadWindow()) {
	using FunctionType = decltype(reloadWindow())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x22bd00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto InfoLayer::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(InfoLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x22b670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto InfoLayer::toggleSmallCommentMode(cocos2d::CCObject* p0) -> decltype(toggleSmallCommentMode(p0)) {
	using FunctionType = decltype(toggleSmallCommentMode(p0))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x22bc10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto InfoLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("InfoLayer::registerWithTouchDispatcher not implemented");
}

auto InfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("InfoLayer::keyBackClicked not implemented");
}

auto InfoLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::show), this);
	using FunctionType = decltype(show())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x8fff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadCommentsFinished(p0, p1)) {
	throw std::runtime_error("InfoLayer::loadCommentsFinished not implemented");
}

auto InfoLayer::loadCommentsFailed(char const* p0) -> decltype(loadCommentsFailed(p0)) {
	throw std::runtime_error("InfoLayer::loadCommentsFailed not implemented");
}

auto InfoLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	throw std::runtime_error("InfoLayer::setupPageInfo not implemented");
}

auto InfoLayer::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	throw std::runtime_error("InfoLayer::commentUploadFinished not implemented");
}

auto InfoLayer::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	throw std::runtime_error("InfoLayer::commentUploadFailed not implemented");
}

auto InfoLayer::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	throw std::runtime_error("InfoLayer::updateUserScoreFinished not implemented");
}

auto InfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("InfoLayer::FLAlert_Clicked not implemented");
}

auto InheritanceNode::create(int p0, InheritanceNode* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, InheritanceNode*);
	static auto func = wrapFunction(base::get() + 0x1d8b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto ItemInfoPopup::create(int p0, UnlockType p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x1f5ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto ItemInfoPopup::init(int p0, UnlockType p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(ItemInfoPopup*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x1f5b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ItemInfoPopup::nameForUnlockType(int p0, UnlockType p1) -> decltype(nameForUnlockType(p0, p1)) {
	using FunctionType = decltype(nameForUnlockType(p0, p1))(*)(ItemInfoPopup*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x1f6f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ItemInfoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ItemInfoPopup::keyBackClicked not implemented");
}

auto ItemTriggerGameObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3b5040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto ItemTriggerGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ItemTriggerGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(ItemTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x3b50e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ItemTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("ItemTriggerGameObject::triggerObject not implemented");
}

auto ItemTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("ItemTriggerGameObject::customObjectSetup not implemented");
}

auto ItemTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("ItemTriggerGameObject::getSaveString not implemented");
}

auto KeybindingsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x22c1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto KeybindingsLayer::addKeyPair(char const* p0, char const* p1) -> decltype(addKeyPair(p0, p1)) {
	using FunctionType = decltype(addKeyPair(p0, p1))(*)(KeybindingsLayer*, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x22c9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto KeybindingsLayer::countForPage(int p0) -> decltype(countForPage(p0)) {
	using FunctionType = decltype(countForPage(p0))(*)(KeybindingsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x22ccd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto KeybindingsLayer::goToPage(int p0) -> decltype(goToPage(p0)) {
	using FunctionType = decltype(goToPage(p0))(*)(KeybindingsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x22d010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto KeybindingsLayer::incrementCountForPage(int p0) -> decltype(incrementCountForPage(p0)) {
	using FunctionType = decltype(incrementCountForPage(p0))(*)(KeybindingsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x22cda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto KeybindingsLayer::layerForPage(int p0) -> decltype(layerForPage(p0)) {
	using FunctionType = decltype(layerForPage(p0))(*)(KeybindingsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x22ce80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto KeybindingsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeybindingsLayer::init), this);
	using FunctionType = decltype(init())(*)(KeybindingsLayer*);
	static auto func = wrapFunction(base::get() + 0x22c260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeybindingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("KeybindingsLayer::keyBackClicked not implemented");
}

auto KeybindingsManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(KeybindingsManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x22d570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto KeybindingsManager::init() -> decltype(init()) {
	throw std::runtime_error("KeybindingsManager::init not implemented");
}

auto KeyframeAnimTriggerObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3a6cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto KeyframeAnimTriggerObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeyframeAnimTriggerObject::init), this);
	using FunctionType = decltype(init())(*)(KeyframeAnimTriggerObject*);
	static auto func = wrapFunction(base::get() + 0x3a6d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeyframeAnimTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("KeyframeAnimTriggerObject::customObjectSetup not implemented");
}

auto KeyframeAnimTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("KeyframeAnimTriggerObject::getSaveString not implemented");
}

auto KeyframeGameObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3aaf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto KeyframeGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeyframeGameObject::init), this);
	using FunctionType = decltype(init())(*)(KeyframeGameObject*);
	static auto func = wrapFunction(base::get() + 0x3aafc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeyframeGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("KeyframeGameObject::setOpacity not implemented");
}

auto KeyframeGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("KeyframeGameObject::customObjectSetup not implemented");
}

auto KeyframeGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("KeyframeGameObject::getSaveString not implemented");
}

auto LabelGameObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3a8b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LabelGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LabelGameObject::init), this);
	using FunctionType = decltype(init())(*)(LabelGameObject*);
	static auto func = wrapFunction(base::get() + 0x3a8c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LabelGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("LabelGameObject::setOpacity not implemented");
}

auto LabelGameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string>::func(&LabelGameObject::setupCustomSprites), this);
	using FunctionType = decltype(setupCustomSprites(p0))(*)(LabelGameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x14dda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	throw std::runtime_error("LabelGameObject::addMainSpriteToParent not implemented");
}

auto LabelGameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("LabelGameObject::resetObject not implemented");
}

auto LabelGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("LabelGameObject::customObjectSetup not implemented");
}

auto LabelGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("LabelGameObject::getSaveString not implemented");
}

auto LabelGameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	throw std::runtime_error("LabelGameObject::setObjectColor not implemented");
}

auto LabelGameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	throw std::runtime_error("LabelGameObject::updateTextKerning not implemented");
}

auto LabelGameObject::getTextKerning() -> decltype(getTextKerning()) {
	throw std::runtime_error("LabelGameObject::getTextKerning not implemented");
}

void LeaderboardManagerDelegate::updateUserScoreFinished() {}

void LeaderboardManagerDelegate::updateUserScoreFailed() {}

void LeaderboardManagerDelegate::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) {}

void LeaderboardManagerDelegate::loadLeaderboardFailed(char const* p0) {}

auto LeaderboardsLayer::create(LeaderboardState p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(LeaderboardState);
	static auto func = wrapFunction(base::get() + 0x22dbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LeaderboardsLayer::init(LeaderboardState p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LeaderboardsLayer*, LeaderboardState);
	static auto func = wrapFunction(base::get() + 0x22dc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LeaderboardsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("LeaderboardsLayer::keyBackClicked not implemented");
}

auto LeaderboardsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("LeaderboardsLayer::FLAlert_Clicked not implemented");
}

auto LeaderboardsLayer::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	throw std::runtime_error("LeaderboardsLayer::updateUserScoreFinished not implemented");
}

auto LeaderboardsLayer::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	throw std::runtime_error("LeaderboardsLayer::updateUserScoreFailed not implemented");
}

auto LeaderboardsLayer::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadLeaderboardFinished(p0, p1)) {
	throw std::runtime_error("LeaderboardsLayer::loadLeaderboardFinished not implemented");
}

auto LeaderboardsLayer::loadLeaderboardFailed(char const* p0) -> decltype(loadLeaderboardFailed(p0)) {
	throw std::runtime_error("LeaderboardsLayer::loadLeaderboardFailed not implemented");
}

auto LevelAreaInnerLayer::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x231140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelAreaInnerLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelAreaInnerLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2311e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelAreaInnerLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelAreaInnerLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x232940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaInnerLayer::onDoor(cocos2d::CCObject* sender) -> decltype(onDoor(sender)) {
	using FunctionType = decltype(onDoor(sender))(*)(LevelAreaInnerLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x232720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaInnerLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelAreaInnerLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x232c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaInnerLayer::onNextFloor(cocos2d::CCObject* sender) -> decltype(onNextFloor(sender)) {
	using FunctionType = decltype(onNextFloor(sender))(*)(LevelAreaInnerLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x231ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaInnerLayer::playStep1() -> decltype(playStep1()) {
	using FunctionType = decltype(playStep1())(*)(LevelAreaInnerLayer*);
	static auto func = wrapFunction(base::get() + 0x232850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelAreaInnerLayer::showFloor1CompleteDialog() -> decltype(showFloor1CompleteDialog()) {
	using FunctionType = decltype(showFloor1CompleteDialog())(*)(LevelAreaInnerLayer*);
	static auto func = wrapFunction(base::get() + 0x231f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelAreaInnerLayer::tryResumeTowerMusic() -> decltype(tryResumeTowerMusic()) {
	using FunctionType = decltype(tryResumeTowerMusic())(*)(LevelAreaInnerLayer*);
	static auto func = wrapFunction(base::get() + 0x2326a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelAreaInnerLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaInnerLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelAreaInnerLayer*);
	static auto func = wrapFunction(base::get() + 0x2329a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaInnerLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("LevelAreaInnerLayer::dialogClosed not implemented");
}

auto LevelAreaLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x22f560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LevelAreaLayer::addGodRay(float p0, float p1, float p2, float p3, float p4, cocos2d::CCPoint p5) -> decltype(addGodRay(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(addGodRay(p0, p1, p2, p3, p4, p5))(*)(LevelAreaLayer*, float, float, float, float, float, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x230d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto LevelAreaLayer::addTorch(cocos2d::CCNode* p0, cocos2d::CCPoint p1, int p2, float p3, int p4, bool p5) -> decltype(addTorch(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(addTorch(p0, p1, p2, p3, p4, p5))(*)(LevelAreaLayer*, cocos2d::CCNode*, cocos2d::CCPoint, int, float, int, bool);
	static auto func = wrapFunction(base::get() + 0x230800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto LevelAreaLayer::fadeInsideTower() -> decltype(fadeInsideTower()) {
	using FunctionType = decltype(fadeInsideTower())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x2306c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelAreaLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelAreaLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x231080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaLayer::onClickDoor(cocos2d::CCObject* sender) -> decltype(onClickDoor(sender)) {
	using FunctionType = decltype(onClickDoor(sender))(*)(LevelAreaLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x230580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaLayer::onEnterTower() -> decltype(onEnterTower()) {
	using FunctionType = decltype(onEnterTower())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x230750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelAreaLayer::showDialog() -> decltype(showDialog()) {
	using FunctionType = decltype(showDialog())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x230300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelAreaLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaLayer::init), this);
	using FunctionType = decltype(init())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x22f610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x2310f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("LevelAreaLayer::dialogClosed not implemented");
}

void SetTextPopupDelegate::setTextPopupClosed(SetTextPopup* p0, gd::string p1) {}

auto ShareCommentDelegate::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	throw std::runtime_error("ShareCommentDelegate::shareCommentClosed not implemented");
}

LevelBrowserLayer::~LevelBrowserLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x232c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) LevelBrowserLayer(geode::CutoffConstructor, sizeof(LevelBrowserLayer));
	CCDestructor::lock(this) = true;
}

auto LevelBrowserLayer::create(GJSearchObject* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x232db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelBrowserLayer::createNewLevel(cocos2d::CCObject* p0) -> decltype(createNewLevel(p0)) {
	using FunctionType = decltype(createNewLevel(p0))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x236600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::getSearchTitle() -> decltype(getSearchTitle()) {
	using FunctionType = decltype(getSearchTitle())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x235390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelBrowserLayer::init(GJSearchObject* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelBrowserLayer*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x232e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::isCorrect(char const* p0) -> decltype(isCorrect(p0)) {
	using FunctionType = decltype(isCorrect(p0))(*)(LevelBrowserLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x2343a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::loadPage(GJSearchObject* p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(LevelBrowserLayer*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x2344e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::onClearSearch(cocos2d::CCObject* sender) -> decltype(onClearSearch(sender)) {
	using FunctionType = decltype(onClearSearch(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x236e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onDeleteAll(cocos2d::CCObject* sender) -> decltype(onDeleteAll(sender)) {
	using FunctionType = decltype(onDeleteAll(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x236c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onDeleteSelected(cocos2d::CCObject* sender) -> decltype(onDeleteSelected(sender)) {
	using FunctionType = decltype(onDeleteSelected(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x237460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onFavorites(cocos2d::CCObject* sender) -> decltype(onFavorites(sender)) {
	using FunctionType = decltype(onFavorites(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x236a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onGoToFolder(cocos2d::CCObject* sender) -> decltype(onGoToFolder(sender)) {
	using FunctionType = decltype(onGoToFolder(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x235d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onGoToLastPage(cocos2d::CCObject* sender) -> decltype(onGoToLastPage(sender)) {
	using FunctionType = decltype(onGoToLastPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x235c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onGoToPage(cocos2d::CCObject* sender) -> decltype(onGoToPage(sender)) {
	using FunctionType = decltype(onGoToPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x235c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x236140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onLocalMode(cocos2d::CCObject* sender) -> decltype(onLocalMode(sender)) {
	using FunctionType = decltype(onLocalMode(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x236500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onMyOnlineLevels(cocos2d::CCObject* sender) -> decltype(onMyOnlineLevels(sender)) {
	using FunctionType = decltype(onMyOnlineLevels(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x236860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onNew(cocos2d::CCObject* sender) -> decltype(onNew(sender)) {
	using FunctionType = decltype(onNew(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x236440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x235f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x235fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onRefresh(cocos2d::CCObject* sender) -> decltype(onRefresh(sender)) {
	using FunctionType = decltype(onRefresh(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x236dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onSavedMode(cocos2d::CCObject* sender) -> decltype(onSavedMode(sender)) {
	using FunctionType = decltype(onSavedMode(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x236470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onSearch(cocos2d::CCObject* sender) -> decltype(onSearch(sender)) {
	using FunctionType = decltype(onSearch(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x236f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onToggleAllObjects(cocos2d::CCObject* sender) -> decltype(onToggleAllObjects(sender)) {
	using FunctionType = decltype(onToggleAllObjects(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2376e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::scene(GJSearchObject* search) -> decltype(scene(search)) {
	using FunctionType = decltype(scene(search))(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x232d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(search);
}

auto LevelBrowserLayer::setupLevelBrowser(cocos2d::CCArray* p0) -> decltype(setupLevelBrowser(p0)) {
	using FunctionType = decltype(setupLevelBrowser(p0))(*)(LevelBrowserLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x235080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::show() -> decltype(show()) {
	using FunctionType = decltype(show())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x237c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelBrowserLayer::updateLevelsLabel() -> decltype(updateLevelsLabel()) {
	using FunctionType = decltype(updateLevelsLabel())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x235b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelBrowserLayer::updatePageLabel() -> decltype(updatePageLabel()) {
	using FunctionType = decltype(updatePageLabel())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x235e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelBrowserLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x237ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	throw std::runtime_error("LevelBrowserLayer::onEnterTransitionDidFinish not implemented");
}

auto LevelBrowserLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("LevelBrowserLayer::ccTouchBegan not implemented");
}

auto LevelBrowserLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("LevelBrowserLayer::ccTouchMoved not implemented");
}

auto LevelBrowserLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("LevelBrowserLayer::ccTouchEnded not implemented");
}

auto LevelBrowserLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("LevelBrowserLayer::ccTouchCancelled not implemented");
}

auto LevelBrowserLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x237c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("LevelBrowserLayer::keyBackClicked not implemented");
}

auto LevelBrowserLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	throw std::runtime_error("LevelBrowserLayer::keyDown not implemented");
}

auto LevelBrowserLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&LevelBrowserLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(LevelBrowserLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x2358a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelBrowserLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&LevelBrowserLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(LevelBrowserLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x2359a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&LevelBrowserLayer::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(LevelBrowserLayer*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x2359e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	throw std::runtime_error("LevelBrowserLayer::onBack not implemented");
}

auto LevelBrowserLayer::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	throw std::runtime_error("LevelBrowserLayer::shareCommentClosed not implemented");
}

auto LevelBrowserLayer::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	throw std::runtime_error("LevelBrowserLayer::setTextPopupClosed not implemented");
}

auto LevelBrowserLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("LevelBrowserLayer::FLAlert_Clicked not implemented");
}

auto LevelBrowserLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&LevelBrowserLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(LevelBrowserLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x235d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::updateResultArray(cocos2d::CCArray* p0) -> decltype(updateResultArray(p0)) {
	throw std::runtime_error("LevelBrowserLayer::updateResultArray not implemented");
}

auto LevelBrowserLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("LevelBrowserLayer::cellPerformedAction not implemented");
}

LevelCell::LevelCell(char const* p0, float p1, float p2) : LevelCell(geode::CutoffConstructor, sizeof(LevelCell)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	LevelCell::~LevelCell();
	using FunctionType = void(*)(LevelCell*, char const*, float, float);
	static auto func = wrapFunction(base::get() + 0x7d7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelCell::create(float p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, float);
	static auto func = wrapFunction(base::get() + 0x7d6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelCell::loadCustomLevelCell() -> decltype(loadCustomLevelCell()) {
	using FunctionType = decltype(loadCustomLevelCell())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0x7da60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelCell::loadFromLevel(GJGameLevel* p0) -> decltype(loadFromLevel(p0)) {
	using FunctionType = decltype(loadFromLevel(p0))(*)(LevelCell*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x7d8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelCell::loadLocalLevelCell() -> decltype(loadLocalLevelCell()) {
	using FunctionType = decltype(loadLocalLevelCell())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0x804d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelCell::onClick(cocos2d::CCObject* sender) -> decltype(onClick(sender)) {
	using FunctionType = decltype(onClick(sender))(*)(LevelCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x80e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelCell::onToggle(cocos2d::CCObject* sender) -> decltype(onToggle(sender)) {
	using FunctionType = decltype(onToggle(sender))(*)(LevelCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7da40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelCell::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(LevelCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x80f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelCell::updateCellMode(int p0) -> decltype(updateCellMode(p0)) {
	using FunctionType = decltype(updateCellMode(p0))(*)(LevelCell*, int);
	static auto func = wrapFunction(base::get() + 0x80d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelCell::init), this);
	using FunctionType = decltype(init())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0x7d880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelCell::draw() -> decltype(draw()) {
	throw std::runtime_error("LevelCell::draw not implemented");
}

void LevelDeleteDelegate::levelDeleteFinished(int p0) {}

void LevelDeleteDelegate::levelDeleteFailed(int p0) {}

void LevelSettingsDelegate::levelSettingsUpdated() {}

LevelEditorLayer* LevelEditorLayer::get() {
        return GameManager::sharedState()->m_levelEditorLayer;
    }

auto LevelEditorLayer::create(GJGameLevel* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2399c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelEditorLayer::addExclusionList(cocos2d::CCArray* p0, cocos2d::CCDictionary* p1) -> decltype(addExclusionList(p0, p1)) {
	using FunctionType = decltype(addExclusionList(p0, p1))(*)(LevelEditorLayer*, cocos2d::CCArray*, cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x241da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::addSpecial(GameObject* p0) -> decltype(addSpecial(p0)) {
	using FunctionType = decltype(addSpecial(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x23ec50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::addTouchPoint(cocos2d::CCPoint p0) -> decltype(addTouchPoint(p0)) {
	using FunctionType = decltype(addTouchPoint(p0))(*)(LevelEditorLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x2509d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::copyObjectState(GameObject* p0) -> decltype(copyObjectState(p0)) {
	using FunctionType = decltype(copyObjectState(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x2477f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::createObject(int p0, cocos2d::CCPoint p1, bool p2) -> decltype(createObject(p0, p1, p2)) {
	using FunctionType = decltype(createObject(p0, p1, p2))(*)(LevelEditorLayer*, int, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0x23bf10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelEditorLayer::createObjectsFromSetup(gd::string& p0) -> decltype(createObjectsFromSetup(p0)) {
	using FunctionType = decltype(createObjectsFromSetup(p0))(*)(LevelEditorLayer*, gd::string&);
	static auto func = wrapFunction(base::get() + 0x23b330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::createObjectsFromString(gd::string const& p0, bool p1, bool p2) -> decltype(createObjectsFromString(p0, p1, p2)) {
	using FunctionType = decltype(createObjectsFromString(p0, p1, p2))(*)(LevelEditorLayer*, gd::string const&, bool, bool);
	static auto func = wrapFunction(base::get() + 0x23b970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelEditorLayer::findGameObject(int p0) -> decltype(findGameObject(p0)) {
	using FunctionType = decltype(findGameObject(p0))(*)(LevelEditorLayer*, int);
	static auto func = wrapFunction(base::get() + 0x23d260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::getLevelString() -> decltype(getLevelString()) {
	using FunctionType = decltype(getLevelString())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x23db70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::getNextFreeEditorLayer(cocos2d::CCArray* p0) -> decltype(getNextFreeEditorLayer(p0)) {
	using FunctionType = decltype(getNextFreeEditorLayer(p0))(*)(LevelEditorLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x241950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::getNextFreeGroupID(cocos2d::CCArray* p0) -> decltype(getNextFreeGroupID(p0)) {
	using FunctionType = decltype(getNextFreeGroupID(p0))(*)(LevelEditorLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x241530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::getNextFreeOrderChannel(cocos2d::CCArray* p0) -> decltype(getNextFreeOrderChannel(p0)) {
	using FunctionType = decltype(getNextFreeOrderChannel(p0))(*)(LevelEditorLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x241870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::getObjectRect(GameObject* p0, bool p1, bool p2) -> decltype(getObjectRect(p0, p1, p2)) {
	using FunctionType = decltype(getObjectRect(p0, p1, p2))(*)(LevelEditorLayer*, GameObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x23cb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelEditorLayer::handleAction(bool p0, cocos2d::CCArray* p1) -> decltype(handleAction(p0, p1)) {
	using FunctionType = decltype(handleAction(p0, p1))(*)(LevelEditorLayer*, bool, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x23d670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::init(GJGameLevel* p0, bool p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(LevelEditorLayer*, GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x239a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

bool LevelEditorLayer::isLayerLocked(int layer) {
		if (layer < 10000 && m_layerLockingEnabled) {
			return m_lockedLayers.at(layer);
		}
		return false;
	}

auto LevelEditorLayer::objectAtPosition(cocos2d::CCPoint p0) -> decltype(objectAtPosition(p0)) {
	using FunctionType = decltype(objectAtPosition(p0))(*)(LevelEditorLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x23c610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::objectMoved(GameObject* p0) -> decltype(objectMoved(p0)) {
	using FunctionType = decltype(objectMoved(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x23f080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::onPausePlaytest() -> decltype(onPausePlaytest()) {
	using FunctionType = decltype(onPausePlaytest())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x246c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::onPlaytest() -> decltype(onPlaytest()) {
	using FunctionType = decltype(onPlaytest())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2463a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::onResumePlaytest() -> decltype(onResumePlaytest()) {
	using FunctionType = decltype(onResumePlaytest())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x246d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::pasteAttributeState(GameObject* p0, cocos2d::CCArray* p1) -> decltype(pasteAttributeState(p0, p1)) {
	using FunctionType = decltype(pasteAttributeState(p0, p1))(*)(LevelEditorLayer*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x247940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::pasteColorState(GameObject* p0, cocos2d::CCArray* p1) -> decltype(pasteColorState(p0, p1)) {
	using FunctionType = decltype(pasteColorState(p0, p1))(*)(LevelEditorLayer*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2478d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::removeAllObjects() -> decltype(removeAllObjects()) {
	using FunctionType = decltype(removeAllObjects())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x23d360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::removeObject(GameObject* p0, bool p1) -> decltype(removeObject(p0, p1)) {
	using FunctionType = decltype(removeObject(p0, p1))(*)(LevelEditorLayer*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x23d2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::removeSpecial(GameObject* p0) -> decltype(removeSpecial(p0)) {
	using FunctionType = decltype(removeSpecial(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x23f2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::scene(GJGameLevel* p0, bool p1) -> decltype(scene(p0, p1)) {
	using FunctionType = decltype(scene(p0, p1))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x239980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelEditorLayer::toggleLockActiveLayer() -> decltype(toggleLockActiveLayer()) {
	using FunctionType = decltype(toggleLockActiveLayer())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x23e6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::tryUpdateSpeedObject(EffectGameObject* p0, bool p1) -> decltype(tryUpdateSpeedObject(p0, p1)) {
	using FunctionType = decltype(tryUpdateSpeedObject(p0, p1))(*)(LevelEditorLayer*, EffectGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x23f600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::typeExistsAtPosition(int p0, cocos2d::CCPoint p1, bool p2, bool p3, float p4) -> decltype(typeExistsAtPosition(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(typeExistsAtPosition(p0, p1, p2, p3, p4))(*)(LevelEditorLayer*, int, cocos2d::CCPoint, bool, bool, float);
	static auto func = wrapFunction(base::get() + 0x23c100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto LevelEditorLayer::updateEditorMode() -> decltype(updateEditorMode()) {
	using FunctionType = decltype(updateEditorMode())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2423a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updateLevelFont(int p0) -> decltype(updateLevelFont(p0)) {
	using FunctionType = decltype(updateLevelFont(p0))(*)(LevelEditorLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2458c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::updateObjectLabel(GameObject* p0) -> decltype(updateObjectLabel(p0)) {
	using FunctionType = decltype(updateObjectLabel(p0))(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x23e710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelEditorLayer::updateOptions() -> decltype(updateOptions()) {
	using FunctionType = decltype(updateOptions())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x23afa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updatePreviewAnim() -> decltype(updatePreviewAnim()) {
	using FunctionType = decltype(updatePreviewAnim())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x247c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updatePreviewParticle(ParticleGameObject* p0) -> decltype(updatePreviewParticle(p0)) {
	using FunctionType = decltype(updatePreviewParticle(p0))(*)(LevelEditorLayer*, ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x247ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::updatePreviewParticles() -> decltype(updatePreviewParticles()) {
	using FunctionType = decltype(updatePreviewParticles())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x247e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("LevelEditorLayer::draw not implemented");
}

auto LevelEditorLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&LevelEditorLayer::postUpdate), this);
	using FunctionType = decltype(postUpdate(p0))(*)(LevelEditorLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2475d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&LevelEditorLayer::updateVisibility), this);
	using FunctionType = decltype(updateVisibility(p0))(*)(LevelEditorLayer*, float);
	static auto func = wrapFunction(base::get() + 0x23fa90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::playerTookDamage(PlayerObject* p0) -> decltype(playerTookDamage(p0)) {
	throw std::runtime_error("LevelEditorLayer::playerTookDamage not implemented");
}

auto LevelEditorLayer::updateColor(cocos2d::ccColor3B& p0, float p1, int p2, bool p3, float p4, cocos2d::ccHSVValue& p5, int p6, bool p7, EffectGameObject* p8, int p9, int p10) -> decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)) {
	throw std::runtime_error("LevelEditorLayer::updateColor not implemented");
}

auto LevelEditorLayer::updateDebugDraw() -> decltype(updateDebugDraw()) {
	throw std::runtime_error("LevelEditorLayer::updateDebugDraw not implemented");
}

auto LevelEditorLayer::addToGroup(GameObject* p0, int p1, bool p2) -> decltype(addToGroup(p0, p1, p2)) {
	throw std::runtime_error("LevelEditorLayer::addToGroup not implemented");
}

auto LevelEditorLayer::removeFromGroup(GameObject* p0, int p1) -> decltype(removeFromGroup(p0, p1)) {
	throw std::runtime_error("LevelEditorLayer::removeFromGroup not implemented");
}

auto LevelEditorLayer::updateObjectSection(GameObject* p0) -> decltype(updateObjectSection(p0)) {
	throw std::runtime_error("LevelEditorLayer::updateObjectSection not implemented");
}

auto LevelEditorLayer::updateDisabledObjectsLastPos(cocos2d::CCArray* p0) -> decltype(updateDisabledObjectsLastPos(p0)) {
	throw std::runtime_error("LevelEditorLayer::updateDisabledObjectsLastPos not implemented");
}

auto LevelEditorLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) -> decltype(timeForPos(p0, p1, p2, p3, p4)) {
	throw std::runtime_error("LevelEditorLayer::timeForPos not implemented");
}

auto LevelEditorLayer::posForTime(float p0) -> decltype(posForTime(p0)) {
	throw std::runtime_error("LevelEditorLayer::posForTime not implemented");
}

auto LevelEditorLayer::resetSPTriggered() -> decltype(resetSPTriggered()) {
	throw std::runtime_error("LevelEditorLayer::resetSPTriggered not implemented");
}

auto LevelEditorLayer::didRotateGameplay() -> decltype(didRotateGameplay()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelEditorLayer::didRotateGameplay), this);
	using FunctionType = decltype(didRotateGameplay())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x2460b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelEditorLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	throw std::runtime_error("LevelEditorLayer::manualUpdateObjectColors not implemented");
}

auto LevelEditorLayer::claimCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, int p3, int p4, bool p5) -> decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5)) {
	throw std::runtime_error("LevelEditorLayer::claimCustomParticle not implemented");
}

auto LevelEditorLayer::unclaimCustomParticle(gd::string const& p0, cocos2d::CCParticleSystemQuad* p1) -> decltype(unclaimCustomParticle(p0, p1)) {
	throw std::runtime_error("LevelEditorLayer::unclaimCustomParticle not implemented");
}

auto LevelEditorLayer::activatedAudioTrigger(SFXTriggerGameObject* p0) -> decltype(activatedAudioTrigger(p0)) {
	throw std::runtime_error("LevelEditorLayer::activatedAudioTrigger not implemented");
}

auto LevelEditorLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	throw std::runtime_error("LevelEditorLayer::checkpointActivated not implemented");
}

auto LevelEditorLayer::addKeyframe(KeyframeGameObject* p0) -> decltype(addKeyframe(p0)) {
	throw std::runtime_error("LevelEditorLayer::addKeyframe not implemented");
}

auto LevelEditorLayer::levelSettingsUpdated() -> decltype(levelSettingsUpdated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelEditorLayer::levelSettingsUpdated), this);
	using FunctionType = decltype(levelSettingsUpdated())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x23b2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelFeatureLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("LevelFeatureLayer::keyBackClicked not implemented");
}

void LevelUpdateDelegate::levelUpdateFinished(GJGameLevel* p0, UpdateResponse p1) {}

void LevelUpdateDelegate::levelUpdateFailed(int p0) {}

void RateLevelDelegate::rateLevelClosed() {}

void NumberInputDelegate::numberInputClosed(NumberInputLayer* p0) {}

auto LevelInfoLayer::create(GJGameLevel* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2515f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelInfoLayer::confirmClone(cocos2d::CCObject* p0) -> decltype(confirmClone(p0)) {
	using FunctionType = decltype(confirmClone(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2560f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmMoveToBottom(cocos2d::CCObject* p0) -> decltype(confirmMoveToBottom(p0)) {
	using FunctionType = decltype(confirmMoveToBottom(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x256cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmMoveToTop(cocos2d::CCObject* p0) -> decltype(confirmMoveToTop(p0)) {
	using FunctionType = decltype(confirmMoveToTop(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x256c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::downloadLevel() -> decltype(downloadLevel()) {
	using FunctionType = decltype(downloadLevel())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2539a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::init(GJGameLevel* p0, bool p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(LevelInfoLayer*, GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2516a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelInfoLayer::onAddToList(cocos2d::CCObject* sender) -> decltype(onAddToList(sender)) {
	using FunctionType = decltype(onAddToList(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x253540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x257c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onDelete(cocos2d::CCObject* sender) -> decltype(onDelete(sender)) {
	using FunctionType = decltype(onDelete(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2562c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onFavorite(cocos2d::CCObject* sender) -> decltype(onFavorite(sender)) {
	using FunctionType = decltype(onFavorite(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x253760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onGarage(cocos2d::CCObject* sender) -> decltype(onGarage(sender)) {
	using FunctionType = decltype(onGarage(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x253830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x255ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLevelInfo(cocos2d::CCObject* sender) -> decltype(onLevelInfo(sender)) {
	using FunctionType = decltype(onLevelInfo(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x256a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLevelLeaderboard(cocos2d::CCObject* sender) -> decltype(onLevelLeaderboard(sender)) {
	using FunctionType = decltype(onLevelLeaderboard(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2537d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLike(cocos2d::CCObject* sender) -> decltype(onLike(sender)) {
	using FunctionType = decltype(onLike(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x256660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onOwnerDelete(cocos2d::CCObject* sender) -> decltype(onOwnerDelete(sender)) {
	using FunctionType = decltype(onOwnerDelete(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x256370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2555b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateDemon(cocos2d::CCObject* sender) -> decltype(onRateDemon(sender)) {
	using FunctionType = decltype(onRateDemon(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x256620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateStars(cocos2d::CCObject* sender) -> decltype(onRateStars(sender)) {
	using FunctionType = decltype(onRateStars(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2564f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateStarsMod(cocos2d::CCObject* sender) -> decltype(onRateStarsMod(sender)) {
	using FunctionType = decltype(onRateStarsMod(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2565d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onSetFolder(cocos2d::CCObject* sender) -> decltype(onSetFolder(sender)) {
	using FunctionType = decltype(onSetFolder(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x253680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onUpdate(cocos2d::CCObject* sender) -> decltype(onUpdate(sender)) {
	using FunctionType = decltype(onUpdate(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2568b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x256a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::scene(GJGameLevel* p0, bool p1) -> decltype(scene(p0, p1)) {
	using FunctionType = decltype(scene(p0, p1))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2515b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelInfoLayer::setupLevelInfo() -> decltype(setupLevelInfo()) {
	using FunctionType = decltype(setupLevelInfo())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x2544a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::setupPlatformerStats() -> decltype(setupPlatformerStats()) {
	using FunctionType = decltype(setupPlatformerStats())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x253a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::setupProgressBars() -> decltype(setupProgressBars()) {
	using FunctionType = decltype(setupProgressBars())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x253e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::shouldDownloadLevel() -> decltype(shouldDownloadLevel()) {
	using FunctionType = decltype(shouldDownloadLevel())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x253890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::showSongWarning() -> decltype(showSongWarning()) {
	using FunctionType = decltype(showSongWarning())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x255510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::showUpdateAlert(UpdateResponse p0) -> decltype(showUpdateAlert(p0)) {
	using FunctionType = decltype(showUpdateAlert(p0))(*)(LevelInfoLayer*, UpdateResponse);
	static auto func = wrapFunction(base::get() + 0x255280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::tryCloneLevel(cocos2d::CCObject* p0) -> decltype(tryCloneLevel(p0)) {
	using FunctionType = decltype(tryCloneLevel(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x255f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::updateLabelValues() -> decltype(updateLabelValues()) {
	using FunctionType = decltype(updateLabelValues())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x256d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelInfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x257d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelInfoLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	throw std::runtime_error("LevelInfoLayer::keyDown not implemented");
}

auto LevelInfoLayer::numberInputClosed(NumberInputLayer* p0) -> decltype(numberInputClosed(p0)) {
	throw std::runtime_error("LevelInfoLayer::numberInputClosed not implemented");
}

auto LevelInfoLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("LevelInfoLayer::cellPerformedAction not implemented");
}

auto LevelInfoLayer::levelDownloadFinished(GJGameLevel* p0) -> decltype(levelDownloadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&LevelInfoLayer::levelDownloadFinished), this);
	using FunctionType = decltype(levelDownloadFinished(p0))(*)(LevelInfoLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x254f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDownloadFailed(int p0) -> decltype(levelDownloadFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDownloadFailed), this);
	using FunctionType = decltype(levelDownloadFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x255120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelUpdateFinished(GJGameLevel* p0, UpdateResponse p1) -> decltype(levelUpdateFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*, UpdateResponse>::func(&LevelInfoLayer::levelUpdateFinished), this);
	using FunctionType = decltype(levelUpdateFinished(p0, p1))(*)(LevelInfoLayer*, GJGameLevel*, UpdateResponse);
	static auto func = wrapFunction(base::get() + 0x255230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelInfoLayer::levelUpdateFailed(int p0) -> decltype(levelUpdateFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelUpdateFailed), this);
	using FunctionType = decltype(levelUpdateFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x255320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDeleteFinished(int p0) -> decltype(levelDeleteFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDeleteFinished), this);
	using FunctionType = decltype(levelDeleteFinished(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x255430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDeleteFailed(int p0) -> decltype(levelDeleteFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDeleteFailed), this);
	using FunctionType = decltype(levelDeleteFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2554a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::rateLevelClosed() -> decltype(rateLevelClosed()) {
	throw std::runtime_error("LevelInfoLayer::rateLevelClosed not implemented");
}

auto LevelInfoLayer::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	throw std::runtime_error("LevelInfoLayer::likedItem not implemented");
}

auto LevelInfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("LevelInfoLayer::FLAlert_Clicked not implemented");
}

auto LevelInfoLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	throw std::runtime_error("LevelInfoLayer::setIDPopupClosed not implemented");
}

auto LevelLeaderboard::create(GJGameLevel* p0, LevelLeaderboardType p1, LevelLeaderboardMode p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(GJGameLevel*, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x257fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto LevelLeaderboard::init(GJGameLevel* p0, LevelLeaderboardType p1, LevelLeaderboardMode p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(LevelLeaderboard*, GJGameLevel*, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x258060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelLeaderboard::onChangeMode(cocos2d::CCObject* sender) -> decltype(onChangeMode(sender)) {
	using FunctionType = decltype(onChangeMode(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2595f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::onChangeType(cocos2d::CCObject* sender) -> decltype(onChangeType(sender)) {
	using FunctionType = decltype(onChangeType(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2595a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x6a750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::onUpdate(cocos2d::CCObject* sender) -> decltype(onUpdate(sender)) {
	using FunctionType = decltype(onUpdate(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x259630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::reloadLeaderboard(LevelLeaderboardType p0, LevelLeaderboardMode p1) -> decltype(reloadLeaderboard(p0, p1)) {
	using FunctionType = decltype(reloadLeaderboard(p0, p1))(*)(LevelLeaderboard*, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x2594f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelLeaderboard::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("LevelLeaderboard::registerWithTouchDispatcher not implemented");
}

auto LevelLeaderboard::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("LevelLeaderboard::keyBackClicked not implemented");
}

auto LevelLeaderboard::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::show), this);
	using FunctionType = decltype(show())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x5d6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadLeaderboardFinished(p0, p1)) {
	throw std::runtime_error("LevelLeaderboard::loadLeaderboardFinished not implemented");
}

auto LevelLeaderboard::loadLeaderboardFailed(char const* p0) -> decltype(loadLeaderboardFailed(p0)) {
	throw std::runtime_error("LevelLeaderboard::loadLeaderboardFailed not implemented");
}

auto LevelLeaderboard::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("LevelLeaderboard::FLAlert_Clicked not implemented");
}

auto LevelLeaderboard::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	throw std::runtime_error("LevelLeaderboard::updateUserScoreFinished not implemented");
}

auto LevelLeaderboard::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	throw std::runtime_error("LevelLeaderboard::updateUserScoreFailed not implemented");
}

auto LevelListCell::loadFromList(GJLevelList* p0) -> decltype(loadFromList(p0)) {
	using FunctionType = decltype(loadFromList(p0))(*)(LevelListCell*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x8b570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelListCell::onClick(cocos2d::CCObject* sender) -> decltype(onClick(sender)) {
	using FunctionType = decltype(onClick(sender))(*)(LevelListCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x8c8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListCell::onListInfo(cocos2d::CCObject* sender) -> decltype(onListInfo(sender)) {
	using FunctionType = decltype(onListInfo(sender))(*)(LevelListCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x8c9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListCell::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(LevelListCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x8c9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListCell::init() -> decltype(init()) {
	throw std::runtime_error("LevelListCell::init not implemented");
}

auto LevelListCell::draw() -> decltype(draw()) {
	throw std::runtime_error("LevelListCell::draw not implemented");
}

void LevelListDeleteDelegate::levelListDeleteFinished(int p0) {}

void LevelListDeleteDelegate::levelListDeleteFailed(int p0) {}

auto SelectListIconDelegate::iconSelectClosed(SelectListIconLayer* p0) -> decltype(iconSelectClosed(p0)) {
	throw std::runtime_error("SelectListIconDelegate::iconSelectClosed not implemented");
}

auto LevelListLayer::create(GJLevelList* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x25a1e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelListLayer::init(GJLevelList* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelListLayer*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x25a280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelListLayer::updateSideButtons() -> decltype(updateSideButtons()) {
	using FunctionType = decltype(updateSideButtons())(*)(LevelListLayer*);
	static auto func = wrapFunction(base::get() + 0x25d770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelListLayer::updateStatsArt() -> decltype(updateStatsArt()) {
	using FunctionType = decltype(updateStatsArt())(*)(LevelListLayer*);
	static auto func = wrapFunction(base::get() + 0x25bab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelListLayer::onEnter() -> decltype(onEnter()) {
	throw std::runtime_error("LevelListLayer::onEnter not implemented");
}

auto LevelListLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("LevelListLayer::onExit not implemented");
}

auto LevelListLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	throw std::runtime_error("LevelListLayer::loadLevelsFinished not implemented");
}

auto LevelListLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	throw std::runtime_error("LevelListLayer::loadLevelsFailed not implemented");
}

auto LevelListLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	throw std::runtime_error("LevelListLayer::onBack not implemented");
}

auto LevelListLayer::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	throw std::runtime_error("LevelListLayer::shareCommentClosed not implemented");
}

auto LevelListLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("LevelListLayer::FLAlert_Clicked not implemented");
}

auto LevelListLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	throw std::runtime_error("LevelListLayer::setIDPopupClosed not implemented");
}

auto LevelListLayer::updateResultArray(cocos2d::CCArray* p0) -> decltype(updateResultArray(p0)) {
	throw std::runtime_error("LevelListLayer::updateResultArray not implemented");
}

auto LevelListLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("LevelListLayer::cellPerformedAction not implemented");
}

auto LevelListLayer::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	throw std::runtime_error("LevelListLayer::likedItem not implemented");
}

auto LevelListLayer::iconSelectClosed(SelectListIconLayer* p0) -> decltype(iconSelectClosed(p0)) {
	throw std::runtime_error("LevelListLayer::iconSelectClosed not implemented");
}

auto LevelListLayer::levelListDeleteFinished(int p0) -> decltype(levelListDeleteFinished(p0)) {
	throw std::runtime_error("LevelListLayer::levelListDeleteFinished not implemented");
}

auto LevelListLayer::levelListDeleteFailed(int p0) -> decltype(levelListDeleteFailed(p0)) {
	throw std::runtime_error("LevelListLayer::levelListDeleteFailed not implemented");
}

auto LevelListLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("LevelListLayer::textInputOpened not implemented");
}

auto LevelListLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("LevelListLayer::textInputClosed not implemented");
}

auto LevelListLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("LevelListLayer::textChanged not implemented");
}

auto LevelOptionsLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("LevelOptionsLayer::valueDidChange not implemented");
}

auto LevelOptionsLayer::getValue(int p0) -> decltype(getValue(p0)) {
	throw std::runtime_error("LevelOptionsLayer::getValue not implemented");
}

auto LevelOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	throw std::runtime_error("LevelOptionsLayer::setupOptions not implemented");
}

auto LevelOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	throw std::runtime_error("LevelOptionsLayer::didToggle not implemented");
}

auto LevelOptionsLayer2::create(LevelSettingsObject* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x271f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelOptionsLayer2::init(LevelSettingsObject* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelOptionsLayer2*, LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x271fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelOptionsLayer2::setupOptions() -> decltype(setupOptions()) {
	throw std::runtime_error("LevelOptionsLayer2::setupOptions not implemented");
}

auto LevelPage::create(GJGameLevel* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x268f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelPage::addSecretCoin() -> decltype(addSecretCoin()) {
	using FunctionType = decltype(addSecretCoin())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x26b3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelPage::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelPage*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x268ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelPage::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26c400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26c080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::onSecretDoor(cocos2d::CCObject* sender) -> decltype(onSecretDoor(sender)) {
	using FunctionType = decltype(onSecretDoor(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26bad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::updateDynamicPage(GJGameLevel* p0) -> decltype(updateDynamicPage(p0)) {
	using FunctionType = decltype(updateDynamicPage(p0))(*)(LevelPage*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x269a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelPage::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("LevelPage::ccTouchBegan not implemented");
}

auto LevelPage::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("LevelPage::ccTouchMoved not implemented");
}

auto LevelPage::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("LevelPage::ccTouchEnded not implemented");
}

auto LevelPage::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("LevelPage::ccTouchCancelled not implemented");
}

auto LevelPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("LevelPage::registerWithTouchDispatcher not implemented");
}

auto LevelPage::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("LevelPage::dialogClosed not implemented");
}

auto LevelSearchLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x260e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSearchLayer::getSearchObject(SearchType p0, gd::string p1) -> decltype(getSearchObject(p0, p1)) {
	using FunctionType = decltype(getSearchObject(p0, p1))(*)(LevelSearchLayer*, SearchType, gd::string);
	static auto func = wrapFunction(base::get() + 0x263ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelSearchLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelSearchLayer*, int);
	static auto func = wrapFunction(base::get() + 0x260f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2646e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onClearFreeSearch(cocos2d::CCObject* sender) -> decltype(onClearFreeSearch(sender)) {
	using FunctionType = decltype(onClearFreeSearch(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2646a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMoreOptions(cocos2d::CCObject* sender) -> decltype(onMoreOptions(sender)) {
	using FunctionType = decltype(onMoreOptions(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2629d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMostLikes(cocos2d::CCObject* sender) -> decltype(onMostLikes(sender)) {
	using FunctionType = decltype(onMostLikes(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x263e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSearch(cocos2d::CCObject* sender) -> decltype(onSearch(sender)) {
	using FunctionType = decltype(onSearch(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x264340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSearchUser(cocos2d::CCObject* sender) -> decltype(onSearchUser(sender)) {
	using FunctionType = decltype(onSearchUser(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2644f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::updateSearchLabel(char const* p0) -> decltype(updateSearchLabel(p0)) {
	using FunctionType = decltype(updateSearchLabel(p0))(*)(LevelSearchLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x2638d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("LevelSearchLayer::keyBackClicked not implemented");
}

auto LevelSearchLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("LevelSearchLayer::textInputOpened not implemented");
}

auto LevelSearchLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("LevelSearchLayer::textInputClosed not implemented");
}

auto LevelSearchLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("LevelSearchLayer::textChanged not implemented");
}

auto LevelSearchLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("LevelSearchLayer::FLAlert_Clicked not implemented");
}

auto LevelSearchLayer::demonFilterSelectClosed(int p0) -> decltype(demonFilterSelectClosed(p0)) {
	throw std::runtime_error("LevelSearchLayer::demonFilterSelectClosed not implemented");
}

LevelSelectLayer::~LevelSelectLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(LevelSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x267bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) LevelSelectLayer(geode::CutoffConstructor, sizeof(LevelSelectLayer));
	CCDestructor::lock(this) = true;
}

auto LevelSelectLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x267c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSelectLayer::colorForPage(int page) -> decltype(colorForPage(page)) {
	using FunctionType = decltype(colorForPage(page))(*)(LevelSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x268ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, page);
}

auto LevelSelectLayer::getColorValue(int p0, int p1, float p2) -> decltype(getColorValue(p0, p1, p2)) {
	using FunctionType = decltype(getColorValue(p0, p1, p2))(*)(LevelSelectLayer*, int, int, float);
	static auto func = wrapFunction(base::get() + 0x268980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelSelectLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x267d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSelectLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x268d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onDownload(cocos2d::CCObject* sender) -> decltype(onDownload(sender)) {
	using FunctionType = decltype(onDownload(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x268750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x268e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onNext(cocos2d::CCObject* sender) -> decltype(onNext(sender)) {
	using FunctionType = decltype(onNext(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x268c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onPrev(cocos2d::CCObject* sender) -> decltype(onPrev(sender)) {
	using FunctionType = decltype(onPrev(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x268ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::scene(int p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(LevelSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x267c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x268d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSelectLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&LevelSelectLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(LevelSelectLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x268d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSelectLayer::updatePageWithObject(cocos2d::CCObject* p0, cocos2d::CCObject* p1) -> decltype(updatePageWithObject(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*, cocos2d::CCObject*>::func(&LevelSelectLayer::updatePageWithObject), this);
	using FunctionType = decltype(updatePageWithObject(p0, p1))(*)(LevelSelectLayer*, cocos2d::CCObject*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x268790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelSelectLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&LevelSelectLayer::scrollLayerMoved), this);
	using FunctionType = decltype(scrollLayerMoved(p0))(*)(LevelSelectLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x2687f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SelectArtDelegate::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	throw std::runtime_error("SelectArtDelegate::selectArtClosed not implemented");
}

auto SelectSettingDelegate::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	throw std::runtime_error("SelectSettingDelegate::selectSettingClosed not implemented");
}

auto LevelSettingsLayer::create(LevelSettingsObject* p0, LevelEditorLayer* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(LevelSettingsObject*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x26cd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelSettingsLayer::init(LevelSettingsObject* p0, LevelEditorLayer* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(LevelSettingsLayer*, LevelSettingsObject*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x26ce20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelSettingsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26f640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onCol(cocos2d::CCObject* sender) -> decltype(onCol(sender)) {
	using FunctionType = decltype(onCol(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26f7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onFGArt(cocos2d::CCObject* sender) -> decltype(onFGArt(sender)) {
	using FunctionType = decltype(onFGArt(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26f990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onGameplayMode(cocos2d::CCObject* sender) -> decltype(onGameplayMode(sender)) {
	using FunctionType = decltype(onGameplayMode(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26eff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onGArt(cocos2d::CCObject* sender) -> decltype(onGArt(sender)) {
	using FunctionType = decltype(onGArt(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26f930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onLiveEdit(cocos2d::CCObject* sender) -> decltype(onLiveEdit(sender)) {
	using FunctionType = decltype(onLiveEdit(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26f760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onSelectFont(cocos2d::CCObject* sender) -> decltype(onSelectFont(sender)) {
	using FunctionType = decltype(onSelectFont(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26f9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::onShowPicker(cocos2d::CCObject* sender) -> decltype(onShowPicker(sender)) {
	using FunctionType = decltype(onShowPicker(sender))(*)(LevelSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26f790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSettingsLayer::updateColorSprite(ColorChannelSprite* p0) -> decltype(updateColorSprite(p0)) {
	using FunctionType = decltype(updateColorSprite(p0))(*)(LevelSettingsLayer*, ColorChannelSprite*);
	static auto func = wrapFunction(base::get() + 0x26f870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSettingsLayer::updateColorSprites() -> decltype(updateColorSprites()) {
	using FunctionType = decltype(updateColorSprites())(*)(LevelSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x26f810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelSettingsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("LevelSettingsLayer::registerWithTouchDispatcher not implemented");
}

auto LevelSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("LevelSettingsLayer::keyBackClicked not implemented");
}

auto LevelSettingsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("LevelSettingsLayer::FLAlert_Clicked not implemented");
}

auto LevelSettingsLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	throw std::runtime_error("LevelSettingsLayer::colorSelectClosed not implemented");
}

auto LevelSettingsLayer::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectArtLayer*>::func(&LevelSettingsLayer::selectArtClosed), this);
	using FunctionType = decltype(selectArtClosed(p0))(*)(LevelSettingsLayer*, SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x26f9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	throw std::runtime_error("LevelSettingsLayer::selectSettingClosed not implemented");
}

auto LevelSettingsLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("LevelSettingsLayer::textInputClosed not implemented");
}

auto LevelSettingsLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("LevelSettingsLayer::textChanged not implemented");
}

auto LevelSettingsObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x24d2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LevelSettingsObject::getSaveString() -> decltype(getSaveString()) {
	using FunctionType = decltype(getSaveString())(*)(LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x24d7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelSettingsObject::objectFromDict(cocos2d::CCDictionary* p0) -> decltype(objectFromDict(p0)) {
	using FunctionType = decltype(objectFromDict(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x24eb70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

LevelSettingsObject* LevelSettingsObject::objectFromString(gd::string const& str) {
		return objectFromDict(GameToolbox::stringSetupToDict(str, ","));
	}

auto LevelSettingsObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSettingsObject::init), this);
	using FunctionType = decltype(init())(*)(LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x24d390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelTools::artistForAudio(int p0) -> decltype(artistForAudio(p0)) {
	using FunctionType = decltype(artistForAudio(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2737c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::base64DecodeString(gd::string p0) -> decltype(base64DecodeString(p0)) {
	using FunctionType = decltype(base64DecodeString(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x2753e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::base64EncodeString(gd::string p0) -> decltype(base64EncodeString(p0)) {
	using FunctionType = decltype(base64EncodeString(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x275360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::fbURLForArtist(int p0) -> decltype(fbURLForArtist(p0)) {
	using FunctionType = decltype(fbURLForArtist(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x274010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::getAudioFileName(int p0) -> decltype(getAudioFileName(p0)) {
	using FunctionType = decltype(getAudioFileName(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x273430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::getAudioString(int p0) -> decltype(getAudioString(p0)) {
	using FunctionType = decltype(getAudioString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x274140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::getAudioTitle(int p0) -> decltype(getAudioTitle(p0)) {
	using FunctionType = decltype(getAudioTitle(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x273090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::getLevel(int p0, bool p1) -> decltype(getLevel(p0, p1)) {
	using FunctionType = decltype(getLevel(p0, p1))(*)(int, bool);
	static auto func = wrapFunction(base::get() + 0x2725d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelTools::getSongObject(int p0) -> decltype(getSongObject(p0)) {
	using FunctionType = decltype(getSongObject(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x275040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::nameForArtist(int p0) -> decltype(nameForArtist(p0)) {
	using FunctionType = decltype(nameForArtist(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2738c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::ngURLForArtist(int p0) -> decltype(ngURLForArtist(p0)) {
	using FunctionType = decltype(ngURLForArtist(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x273d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::posForTimeInternal(float p0, cocos2d::CCArray* p1, int p2, bool p3, bool p4, bool p5, int& p6, int p7) -> decltype(posForTimeInternal(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(posForTimeInternal(p0, p1, p2, p3, p4, p5, p6, p7))(*)(float, cocos2d::CCArray*, int, bool, bool, bool, int&, int);
	static auto func = wrapFunction(base::get() + 0x274a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7);
}

auto LevelTools::sortChannelOrderObjects(cocos2d::CCArray* p0, cocos2d::CCDictionary* p1, bool p2) -> decltype(sortChannelOrderObjects(p0, p1, p2)) {
	using FunctionType = decltype(sortChannelOrderObjects(p0, p1, p2))(*)(cocos2d::CCArray*, cocos2d::CCDictionary*, bool);
	static auto func = wrapFunction(base::get() + 0x275600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto LevelTools::sortSpeedObjects(cocos2d::CCArray* p0, GJBaseGameLayer* p1) -> decltype(sortSpeedObjects(p0, p1)) {
	using FunctionType = decltype(sortSpeedObjects(p0, p1))(*)(cocos2d::CCArray*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x275820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelTools::timeForPos(cocos2d::CCPoint p0, cocos2d::CCArray* p1, int p2, int p3, int p4, bool p5, bool p6, bool p7, bool p8, int p9) -> decltype(timeForPos(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(timeForPos(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(cocos2d::CCPoint, cocos2d::CCArray*, int, int, int, bool, bool, bool, bool, int);
	static auto func = wrapFunction(base::get() + 0x2743d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto LevelTools::urlForAudio(int p0) -> decltype(urlForAudio(p0)) {
	using FunctionType = decltype(urlForAudio(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x273a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::valueForSpeedMod(int p0) -> decltype(valueForSpeedMod(p0)) {
	using FunctionType = decltype(valueForSpeedMod(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x274380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::verifyLevelIntegrity(gd::string p0, int p1) -> decltype(verifyLevelIntegrity(p0, p1)) {
	using FunctionType = decltype(verifyLevelIntegrity(p0, p1))(*)(gd::string, int);
	static auto func = wrapFunction(base::get() + 0x2751d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelTools::ytURLForArtist(int p0) -> decltype(ytURLForArtist(p0)) {
	using FunctionType = decltype(ytURLForArtist(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x273ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

void LevelUploadDelegate::levelUploadFinished(GJGameLevel* p0) {}

void LevelUploadDelegate::levelUploadFailed(GJGameLevel* p0) {}

auto LikeItemLayer::create(LikeItemType p0, int p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(LikeItemType, int, int);
	static auto func = wrapFunction(base::get() + 0x275d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto LikeItemLayer::init(LikeItemType p0, int p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(LikeItemLayer*, LikeItemType, int, int);
	static auto func = wrapFunction(base::get() + 0x275dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LikeItemLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("LikeItemLayer::keyBackClicked not implemented");
}

auto ListCell::init() -> decltype(init()) {
	throw std::runtime_error("ListCell::init not implemented");
}

auto ListCell::draw() -> decltype(draw()) {
	throw std::runtime_error("ListCell::draw not implemented");
}

auto ListUploadDelegate::listUploadFinished(GJLevelList* p0) -> decltype(listUploadFinished(p0)) {
	throw std::runtime_error("ListUploadDelegate::listUploadFinished not implemented");
}

auto ListUploadDelegate::listUploadFailed(GJLevelList* p0, int p1) -> decltype(listUploadFailed(p0, p1)) {
	throw std::runtime_error("ListUploadDelegate::listUploadFailed not implemented");
}

auto LoadingCircle::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x483d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LoadingCircle::fadeAndRemove() -> decltype(fadeAndRemove()) {
	using FunctionType = decltype(fadeAndRemove())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x48670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LoadingCircle::show() -> decltype(show()) {
	using FunctionType = decltype(show())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x48590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void LoadingCircle::setFade(bool fade) {
		m_fade = fade;
	}

auto LoadingCircle::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircle::init), this);
	using FunctionType = decltype(init())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x484d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LoadingCircle::draw() -> decltype(draw()) {
	throw std::runtime_error("LoadingCircle::draw not implemented");
}

auto LoadingCircle::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("LoadingCircle::ccTouchBegan not implemented");
}

auto LoadingCircle::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("LoadingCircle::ccTouchMoved not implemented");
}

auto LoadingCircle::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("LoadingCircle::ccTouchEnded not implemented");
}

auto LoadingCircle::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("LoadingCircle::ccTouchCancelled not implemented");
}

auto LoadingCircle::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("LoadingCircle::registerWithTouchDispatcher not implemented");
}

auto LoadingCircleSprite::init() -> decltype(init()) {
	throw std::runtime_error("LoadingCircleSprite::init not implemented");
}

auto LoadingLayer::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x2762d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LoadingLayer::getLoadingString() -> decltype(getLoadingString()) {
	using FunctionType = decltype(getLoadingString())(*)(LoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x277280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LoadingLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LoadingLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x276370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LoadingLayer::loadAssets() -> decltype(loadAssets()) {
	using FunctionType = decltype(loadAssets())(*)(LoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x276bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LoadingLayer::loadingFinished() -> decltype(loadingFinished()) {
	using FunctionType = decltype(loadingFinished())(*)(LoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x276ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LocalLevelManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x277760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LocalLevelManager::getAllLevelsInDict() -> decltype(getAllLevelsInDict()) {
	using FunctionType = decltype(getAllLevelsInDict())(*)(LocalLevelManager*);
	static auto func = wrapFunction(base::get() + 0x277cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LocalLevelManager::getAllLevelsWithName(gd::string p0) -> decltype(getAllLevelsWithName(p0)) {
	using FunctionType = decltype(getAllLevelsWithName(p0))(*)(LocalLevelManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x277e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LocalLevelManager::getCreatedLists(int p0) -> decltype(getCreatedLists(p0)) {
	using FunctionType = decltype(getCreatedLists(p0))(*)(LocalLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x2784f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LocalLevelManager::getMainLevelString(int p0) -> decltype(getMainLevelString(p0)) {
	using FunctionType = decltype(getMainLevelString(p0))(*)(LocalLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x277a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LocalLevelManager::tryLoadMainLevelString(int p0) -> decltype(tryLoadMainLevelString(p0)) {
	using FunctionType = decltype(tryLoadMainLevelString(p0))(*)(LocalLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x277900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LocalLevelManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LocalLevelManager::init), this);
	using FunctionType = decltype(init())(*)(LocalLevelManager*);
	static auto func = wrapFunction(base::get() + 0x2778d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LocalLevelManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	throw std::runtime_error("LocalLevelManager::encodeDataTo not implemented");
}

auto LocalLevelManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	throw std::runtime_error("LocalLevelManager::dataLoaded not implemented");
}

auto LocalLevelManager::firstLoad() -> decltype(firstLoad()) {
	throw std::runtime_error("LocalLevelManager::firstLoad not implemented");
}

auto MapPackCell::loadFromMapPack(GJMapPack* p0) -> decltype(loadFromMapPack(p0)) {
	using FunctionType = decltype(loadFromMapPack(p0))(*)(MapPackCell*, GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x812a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MapPackCell::onClick(cocos2d::CCObject* sender) -> decltype(onClick(sender)) {
	using FunctionType = decltype(onClick(sender))(*)(MapPackCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x81cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MapPackCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapPackCell::init), this);
	using FunctionType = decltype(init())(*)(MapPackCell*);
	static auto func = wrapFunction(base::get() + 0x81250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapPackCell::draw() -> decltype(draw()) {
	throw std::runtime_error("MapPackCell::draw not implemented");
}

auto MapSelectLayer::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("MapSelectLayer::update not implemented");
}

auto MapSelectLayer::init() -> decltype(init()) {
	throw std::runtime_error("MapSelectLayer::init not implemented");
}

auto MapSelectLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("MapSelectLayer::onExit not implemented");
}

auto MapSelectLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("MapSelectLayer::ccTouchBegan not implemented");
}

auto MapSelectLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("MapSelectLayer::ccTouchMoved not implemented");
}

auto MapSelectLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("MapSelectLayer::ccTouchEnded not implemented");
}

auto MapSelectLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("MapSelectLayer::ccTouchCancelled not implemented");
}

auto MapSelectLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("MapSelectLayer::registerWithTouchDispatcher not implemented");
}

auto MapSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("MapSelectLayer::keyBackClicked not implemented");
}

auto MapSelectLayer::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	throw std::runtime_error("MapSelectLayer::scrollWheel not implemented");
}

auto MenuGameLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2791a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto MenuGameLayer::destroyPlayer() -> decltype(destroyPlayer()) {
	using FunctionType = decltype(destroyPlayer())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x27ae40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuGameLayer::resetPlayer() -> decltype(resetPlayer()) {
	using FunctionType = decltype(resetPlayer())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x279fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuGameLayer::updateColor(float p0) -> decltype(updateColor(p0)) {
	using FunctionType = decltype(updateColor(p0))(*)(MenuGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2796d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MenuGameLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&MenuGameLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(MenuGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x279c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MenuGameLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuGameLayer::init), this);
	using FunctionType = decltype(init())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x279240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuGameLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("MenuGameLayer::ccTouchBegan not implemented");
}

auto MenuGameLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("MenuGameLayer::ccTouchMoved not implemented");
}

auto MenuGameLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("MenuGameLayer::ccTouchEnded not implemented");
}

auto MenuGameLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("MenuGameLayer::ccTouchCancelled not implemented");
}

auto MenuGameLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("MenuGameLayer::registerWithTouchDispatcher not implemented");
}

auto MenuLayer::scene(bool p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x27b3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto MenuLayer::onAchievements(cocos2d::CCObject* sender) -> decltype(onAchievements(sender)) {
	using FunctionType = decltype(onAchievements(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onCreator(cocos2d::CCObject* sender) -> decltype(onCreator(sender)) {
	using FunctionType = decltype(onCreator(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onDaily(cocos2d::CCObject* sender) -> decltype(onDaily(sender)) {
	using FunctionType = decltype(onDaily(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onDiscord(cocos2d::CCObject* sender) -> decltype(onDiscord(sender)) {
	using FunctionType = decltype(onDiscord(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onFacebook(cocos2d::CCObject* sender) -> decltype(onFacebook(sender)) {
	using FunctionType = decltype(onFacebook(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onGarage(cocos2d::CCObject* sender) -> decltype(onGarage(sender)) {
	using FunctionType = decltype(onGarage(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27ca40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onMoreGames(cocos2d::CCObject* sender) -> decltype(onMoreGames(sender)) {
	using FunctionType = decltype(onMoreGames(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onMyProfile(cocos2d::CCObject* sender) -> decltype(onMyProfile(sender)) {
	using FunctionType = decltype(onMyProfile(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onNewgrounds(cocos2d::CCObject* sender) -> decltype(onNewgrounds(sender)) {
	using FunctionType = decltype(onNewgrounds(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27cae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onOptions(cocos2d::CCObject* sender) -> decltype(onOptions(sender)) {
	using FunctionType = decltype(onOptions(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onQuit(cocos2d::CCObject* sender) -> decltype(onQuit(sender)) {
	using FunctionType = decltype(onQuit(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27cb70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onRobTop(cocos2d::CCObject* sender) -> decltype(onRobTop(sender)) {
	using FunctionType = decltype(onRobTop(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onStats(cocos2d::CCObject* sender) -> decltype(onStats(sender)) {
	using FunctionType = decltype(onStats(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onTwitch(cocos2d::CCObject* sender) -> decltype(onTwitch(sender)) {
	using FunctionType = decltype(onTwitch(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onTwitter(cocos2d::CCObject* sender) -> decltype(onTwitter(sender)) {
	using FunctionType = decltype(onTwitter(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onYouTube(cocos2d::CCObject* sender) -> decltype(onYouTube(sender)) {
	using FunctionType = decltype(onYouTube(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::showTOS() -> decltype(showTOS()) {
	using FunctionType = decltype(showTOS())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x27c660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuLayer::updateUserProfileButton() -> decltype(updateUserProfileButton()) {
	using FunctionType = decltype(updateUserProfileButton())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x27c520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::init), this);
	using FunctionType = decltype(init())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x27b450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x27cb60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&MenuLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(MenuLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x27cd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MenuLayer::googlePlaySignedIn() -> decltype(googlePlaySignedIn()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::googlePlaySignedIn), this);
	using FunctionType = decltype(googlePlaySignedIn())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x27c860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MenuLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MenuLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x27cbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void MessageListDelegate::loadMessagesFinished(cocos2d::CCArray* p0, char const* p1) {}

void MessageListDelegate::loadMessagesFailed(char const* p0, GJErrorCode p1) {}

void MessageListDelegate::forceReloadMessages(bool p0) {}

void MessageListDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto MessagesProfilePage::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x27d110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto MessagesProfilePage::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(MessagesProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0x27d1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MessagesProfilePage::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(MessagesProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x27e140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MessagesProfilePage::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(MessagesProfilePage*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x27e390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MessagesProfilePage::untoggleAll() -> decltype(untoggleAll()) {
	using FunctionType = decltype(untoggleAll())(*)(MessagesProfilePage*);
	static auto func = wrapFunction(base::get() + 0x27e0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MessagesProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("MessagesProfilePage::registerWithTouchDispatcher not implemented");
}

auto MessagesProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("MessagesProfilePage::keyBackClicked not implemented");
}

auto MessagesProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("MessagesProfilePage::FLAlert_Clicked not implemented");
}

auto MessagesProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("MessagesProfilePage::onClosePopup not implemented");
}

auto MessagesProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("MessagesProfilePage::uploadActionFinished not implemented");
}

auto MessagesProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("MessagesProfilePage::uploadActionFailed not implemented");
}

auto MessagesProfilePage::loadMessagesFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadMessagesFinished(p0, p1)) {
	throw std::runtime_error("MessagesProfilePage::loadMessagesFinished not implemented");
}

auto MessagesProfilePage::loadMessagesFailed(char const* p0, GJErrorCode p1) -> decltype(loadMessagesFailed(p0, p1)) {
	throw std::runtime_error("MessagesProfilePage::loadMessagesFailed not implemented");
}

auto MessagesProfilePage::forceReloadMessages(bool p0) -> decltype(forceReloadMessages(p0)) {
	throw std::runtime_error("MessagesProfilePage::forceReloadMessages not implemented");
}

auto MessagesProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	throw std::runtime_error("MessagesProfilePage::setupPageInfo not implemented");
}

auto MoreOptionsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2b1590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto MoreOptionsLayer::addToggle(char const* p0, char const* p1, char const* p2) -> decltype(addToggle(p0, p1, p2)) {
	using FunctionType = decltype(addToggle(p0, p1, p2))(*)(MoreOptionsLayer*, char const*, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x2b25f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto MoreOptionsLayer::countForPage(int p0) -> decltype(countForPage(p0)) {
	using FunctionType = decltype(countForPage(p0))(*)(MoreOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b2b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MoreOptionsLayer::goToPage(int p0) -> decltype(goToPage(p0)) {
	using FunctionType = decltype(goToPage(p0))(*)(MoreOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b2fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MoreOptionsLayer::incrementCountForPage(int p0) -> decltype(incrementCountForPage(p0)) {
	using FunctionType = decltype(incrementCountForPage(p0))(*)(MoreOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b2c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MoreOptionsLayer::layerForPage(int p0) -> decltype(layerForPage(p0)) {
	using FunctionType = decltype(layerForPage(p0))(*)(MoreOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b2e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MoreOptionsLayer::nextPosition(int p0) -> decltype(nextPosition(p0)) {
	using FunctionType = decltype(nextPosition(p0))(*)(MoreOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b2a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MoreOptionsLayer::objectsForPage(int p0) -> decltype(objectsForPage(p0)) {
	using FunctionType = decltype(objectsForPage(p0))(*)(MoreOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b2d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MoreOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(MoreOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b3c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreOptionsLayer::onKeybindings(cocos2d::CCObject* sender) -> decltype(onKeybindings(sender)) {
	using FunctionType = decltype(onKeybindings(sender))(*)(MoreOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa21a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreOptionsLayer::onSongBrowser(cocos2d::CCObject* sender) -> decltype(onSongBrowser(sender)) {
	using FunctionType = decltype(onSongBrowser(sender))(*)(MoreOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b3890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2b1630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("MoreOptionsLayer::keyBackClicked not implemented");
}

auto MoreOptionsLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("MoreOptionsLayer::textInputShouldOffset not implemented");
}

auto MoreOptionsLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("MoreOptionsLayer::textInputReturn not implemented");
}

auto MoreOptionsLayer::googlePlaySignedIn() -> decltype(googlePlaySignedIn()) {
	throw std::runtime_error("MoreOptionsLayer::googlePlaySignedIn not implemented");
}

auto MoreOptionsLayer::dropDownLayerWillClose(GJDropDownLayer* p0) -> decltype(dropDownLayerWillClose(p0)) {
	throw std::runtime_error("MoreOptionsLayer::dropDownLayerWillClose not implemented");
}

auto MoreSearchLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x265610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto MoreSearchLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2671b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onSongFilter(cocos2d::CCObject* sender) -> decltype(onSongFilter(sender)) {
	using FunctionType = decltype(onSongFilter(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2669e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onSongMode(cocos2d::CCObject* sender) -> decltype(onSongMode(sender)) {
	using FunctionType = decltype(onSongMode(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x266c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreSearchLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x2656b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreSearchLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("MoreSearchLayer::keyBackClicked not implemented");
}

auto MoreSearchLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	throw std::runtime_error("MoreSearchLayer::textInputShouldOffset not implemented");
}

auto MoreSearchLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	throw std::runtime_error("MoreSearchLayer::textInputReturn not implemented");
}

auto MoreVideoOptionsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2b5630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto MoreVideoOptionsLayer::updateFPSButtons() -> decltype(updateFPSButtons()) {
	using FunctionType = decltype(updateFPSButtons())(*)(MoreVideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2b72e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MoreVideoOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreVideoOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreVideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2b56d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreVideoOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("MoreVideoOptionsLayer::keyBackClicked not implemented");
}

auto MPLobbyLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("MPLobbyLayer::keyBackClicked not implemented");
}

auto MPLobbyLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	throw std::runtime_error("MPLobbyLayer::keyDown not implemented");
}

auto MPLobbyLayer::joinLobbyFinished(int p0) -> decltype(joinLobbyFinished(p0)) {
	throw std::runtime_error("MPLobbyLayer::joinLobbyFinished not implemented");
}

auto MPLobbyLayer::joinLobbyFailed(int p0, GJMPErrorCode p1) -> decltype(joinLobbyFailed(p0, p1)) {
	throw std::runtime_error("MPLobbyLayer::joinLobbyFailed not implemented");
}

auto MPLobbyLayer::updateComments() -> decltype(updateComments()) {
	throw std::runtime_error("MPLobbyLayer::updateComments not implemented");
}

auto MPLobbyLayer::didUploadMPComment(int p0) -> decltype(didUploadMPComment(p0)) {
	throw std::runtime_error("MPLobbyLayer::didUploadMPComment not implemented");
}

auto MPLobbyLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("MPLobbyLayer::textInputOpened not implemented");
}

auto MPLobbyLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("MPLobbyLayer::textInputClosed not implemented");
}

auto MPLobbyLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("MPLobbyLayer::textChanged not implemented");
}

auto MPLobbyLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	throw std::runtime_error("MPLobbyLayer::keyUp not implemented");
}

auto MPLobbyLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("MPLobbyLayer::FLAlert_Clicked not implemented");
}

auto MPLobbyLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("MPLobbyLayer::uploadActionFinished not implemented");
}

auto MPLobbyLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("MPLobbyLayer::uploadActionFailed not implemented");
}

auto MPLobbyLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("MPLobbyLayer::onClosePopup not implemented");
}

auto MultilineBitmapFont::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("MultilineBitmapFont::setOpacity not implemented");
}

auto MultiplayerLayer::init() -> decltype(init()) {
	throw std::runtime_error("MultiplayerLayer::init not implemented");
}

auto MultiplayerLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("MultiplayerLayer::keyBackClicked not implemented");
}

auto MultiTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x366f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto MultiTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(MultiTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x366fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicArtistObject::create(int p0, gd::string p1, gd::string p2, gd::string p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(int, gd::string, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x289cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto MusicArtistObject::init(int p0, gd::string p1, gd::string p2, gd::string p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(MusicArtistObject*, int, gd::string, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x289e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto MusicBrowser::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x27eb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto MusicBrowser::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(MusicBrowser*, int);
	static auto func = wrapFunction(base::get() + 0x27eba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicBrowser::setupList(MusicSearchResult* p0) -> decltype(setupList(p0)) {
	using FunctionType = decltype(setupList(p0))(*)(MusicBrowser*, MusicSearchResult*);
	static auto func = wrapFunction(base::get() + 0x27fd00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicBrowser::setupSongControls() -> decltype(setupSongControls()) {
	using FunctionType = decltype(setupSongControls())(*)(MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x27f760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicBrowser::trySetupMusicBrowser() -> decltype(trySetupMusicBrowser()) {
	using FunctionType = decltype(trySetupMusicBrowser())(*)(MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x27fad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicBrowser::updatePageLabel() -> decltype(updatePageLabel()) {
	using FunctionType = decltype(updatePageLabel())(*)(MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x280340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicBrowser::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("MusicBrowser::update not implemented");
}

auto MusicBrowser::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("MusicBrowser::registerWithTouchDispatcher not implemented");
}

auto MusicBrowser::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("MusicBrowser::keyBackClicked not implemented");
}

auto MusicBrowser::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	throw std::runtime_error("MusicBrowser::musicActionFinished not implemented");
}

auto MusicBrowser::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	throw std::runtime_error("MusicBrowser::musicActionFailed not implemented");
}

auto MusicBrowser::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	throw std::runtime_error("MusicBrowser::sliderEnded not implemented");
}

auto MusicBrowser::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	throw std::runtime_error("MusicBrowser::setTextPopupClosed not implemented");
}

auto MusicBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("MusicBrowser::cellPerformedAction not implemented");
}

auto MusicBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	throw std::runtime_error("MusicBrowser::getSelectedCellIdx not implemented");
}

auto MusicBrowser::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("MusicBrowser::FLAlert_Clicked not implemented");
}

auto PlatformDownloadDelegate::downloadFinished(char const* p0) -> decltype(downloadFinished(p0)) {
	throw std::runtime_error("PlatformDownloadDelegate::downloadFinished not implemented");
}

auto PlatformDownloadDelegate::downloadFailed(char const* p0) -> decltype(downloadFailed(p0)) {
	throw std::runtime_error("PlatformDownloadDelegate::downloadFailed not implemented");
}

auto MusicDownloadManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x2821e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto MusicDownloadManager::addDLToActive(char const* tag, cocos2d::CCObject* obj) -> decltype(addDLToActive(tag, obj)) {
	using FunctionType = decltype(addDLToActive(tag, obj))(*)(MusicDownloadManager*, char const*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x283b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, tag, obj);
}

auto MusicDownloadManager::addMusicDownloadDelegate(MusicDownloadDelegate* p0) -> decltype(addMusicDownloadDelegate(p0)) {
	using FunctionType = decltype(addMusicDownloadDelegate(p0))(*)(MusicDownloadManager*, MusicDownloadDelegate*);
	static auto func = wrapFunction(base::get() + 0x2828d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::addSongObjectFromString(gd::string p0) -> decltype(addSongObjectFromString(p0)) {
	using FunctionType = decltype(addSongObjectFromString(p0))(*)(MusicDownloadManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x282f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::createSongsInfo(gd::string p0) -> decltype(createSongsInfo(p0)) {
	using FunctionType = decltype(createSongsInfo(p0))(*)(MusicDownloadManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x283080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::downloadCustomSong(int p0) -> decltype(downloadCustomSong(p0)) {
	using FunctionType = decltype(downloadCustomSong(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x284bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::downloadMusicLibrary() -> decltype(downloadMusicLibrary()) {
	using FunctionType = decltype(downloadMusicLibrary())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x284fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::downloadSFX(int p0) -> decltype(downloadSFX(p0)) {
	using FunctionType = decltype(downloadSFX(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x2863f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::downloadSFXLibrary() -> decltype(downloadSFXLibrary()) {
	using FunctionType = decltype(downloadSFXLibrary())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x286940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::downloadSong(int p0) -> decltype(downloadSong(p0)) {
	using FunctionType = decltype(downloadSong(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x283780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::downloadSongFailed(int p0, GJSongError p1) -> decltype(downloadSongFailed(p0, p1)) {
	using FunctionType = decltype(downloadSongFailed(p0, p1))(*)(MusicDownloadManager*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0x287be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::downloadSongFinished(int p0) -> decltype(downloadSongFinished(p0)) {
	using FunctionType = decltype(downloadSongFinished(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x287b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::generateCustomContentURL(gd::string p0) -> decltype(generateCustomContentURL(p0)) {
	using FunctionType = decltype(generateCustomContentURL(p0))(*)(MusicDownloadManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x287540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::generateResourceAssetList() -> decltype(generateResourceAssetList()) {
	using FunctionType = decltype(generateResourceAssetList())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x28a5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::getCustomContentURL() -> decltype(getCustomContentURL()) {
	using FunctionType = decltype(getCustomContentURL())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x2849c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::getSFXFolderObjectForID(int p0) -> decltype(getSFXFolderObjectForID(p0)) {
	using FunctionType = decltype(getSFXFolderObjectForID(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x2872b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::getSongInfo(int p0, bool p1) -> decltype(getSongInfo(p0, p1)) {
	using FunctionType = decltype(getSongInfo(p0, p1))(*)(MusicDownloadManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x282ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::getSongInfoObject(int p0) -> decltype(getSongInfoObject(p0)) {
	using FunctionType = decltype(getSongInfoObject(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x283cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::handleIt(bool p0, gd::string p1, gd::string p2, GJHttpType p3) -> decltype(handleIt(p0, p1, p2, p3)) {
	using FunctionType = decltype(handleIt(p0, p1, p2, p3))(*)(MusicDownloadManager*, bool, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0x282600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto MusicDownloadManager::isRunningActionForSongID(int p0) -> decltype(isRunningActionForSongID(p0)) {
	using FunctionType = decltype(isRunningActionForSongID(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x282a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::isSFXDownloaded(int p0) -> decltype(isSFXDownloaded(p0)) {
	using FunctionType = decltype(isSFXDownloaded(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x284140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::isSongDownloaded(int p0) -> decltype(isSongDownloaded(p0)) {
	using FunctionType = decltype(isSongDownloaded(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x283dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::limitDownloadedSongs() -> decltype(limitDownloadedSongs()) {
	using FunctionType = decltype(limitDownloadedSongs())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x283550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::loadSongInfoFailed(int p0, GJSongError p1) -> decltype(loadSongInfoFailed(p0, p1)) {
	using FunctionType = decltype(loadSongInfoFailed(p0, p1))(*)(MusicDownloadManager*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0x287b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::loadSongInfoFinished(SongInfoObject* p0) -> decltype(loadSongInfoFinished(p0)) {
	using FunctionType = decltype(loadSongInfoFinished(p0))(*)(MusicDownloadManager*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x287ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	using FunctionType = decltype(musicActionFailed(p0))(*)(MusicDownloadManager*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x287d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	using FunctionType = decltype(musicActionFinished(p0))(*)(MusicDownloadManager*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x287cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::onDownloadSongCompleted(cocos2d::extension::CCHttpClient* p0, cocos2d::extension::CCHttpResponse* p1) -> decltype(onDownloadSongCompleted(p0, p1)) {
	using FunctionType = decltype(onDownloadSongCompleted(p0, p1))(*)(MusicDownloadManager*, cocos2d::extension::CCHttpClient*, cocos2d::extension::CCHttpResponse*);
	static auto func = wrapFunction(base::get() + 0x2839b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::onGetCustomContentURLCompleted(gd::string p0, gd::string p1) -> decltype(onGetCustomContentURLCompleted(p0, p1)) {
	using FunctionType = decltype(onGetCustomContentURLCompleted(p0, p1))(*)(MusicDownloadManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x284a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::onGetSongInfoCompleted(gd::string p0, gd::string p1) -> decltype(onGetSongInfoCompleted(p0, p1)) {
	using FunctionType = decltype(onGetSongInfoCompleted(p0, p1))(*)(MusicDownloadManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x282d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* p0, cocos2d::extension::CCHttpResponse* p1) -> decltype(onProcessHttpRequestCompleted(p0, p1)) {
	using FunctionType = decltype(onProcessHttpRequestCompleted(p0, p1))(*)(MusicDownloadManager*, cocos2d::extension::CCHttpClient*, cocos2d::extension::CCHttpResponse*);
	static auto func = wrapFunction(base::get() + 0x2824e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::parseMusicLibrary() -> decltype(parseMusicLibrary()) {
	using FunctionType = decltype(parseMusicLibrary())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x285270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::parseSFXLibrary() -> decltype(parseSFXLibrary()) {
	using FunctionType = decltype(parseSFXLibrary())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x286bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::pathForSFX(int p0) -> decltype(pathForSFX(p0)) {
	using FunctionType = decltype(pathForSFX(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x2843e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::pathForSFXFolder(int p0) -> decltype(pathForSFXFolder(p0)) {
	using FunctionType = decltype(pathForSFXFolder(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x284240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::pathForSong(int p0) -> decltype(pathForSong(p0)) {
	using FunctionType = decltype(pathForSong(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x284070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::pathForSongFolder(int p0) -> decltype(pathForSongFolder(p0)) {
	using FunctionType = decltype(pathForSongFolder(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x283ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::ProcessHttpGetRequest(gd::string p0, gd::string p1, cocos2d::extension::SEL_HttpResponse p2, int p3, int p4) -> decltype(ProcessHttpGetRequest(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(ProcessHttpGetRequest(p0, p1, p2, p3, p4))(*)(MusicDownloadManager*, gd::string, gd::string, cocos2d::extension::SEL_HttpResponse, int, int);
	static auto func = wrapFunction(base::get() + 0x2823c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto MusicDownloadManager::ProcessHttpRequest(gd::string p0, gd::string p1, gd::string p2, GJHttpType p3) -> decltype(ProcessHttpRequest(p0, p1, p2, p3)) {
	using FunctionType = decltype(ProcessHttpRequest(p0, p1, p2, p3))(*)(MusicDownloadManager*, gd::string, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0x282260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto MusicDownloadManager::removeDLFromActive(char const* p0) -> decltype(removeDLFromActive(p0)) {
	using FunctionType = decltype(removeDLFromActive(p0))(*)(MusicDownloadManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x283c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::removeMusicDownloadDelegate(MusicDownloadDelegate* p0) -> decltype(removeMusicDownloadDelegate(p0)) {
	using FunctionType = decltype(removeMusicDownloadDelegate(p0))(*)(MusicDownloadManager*, MusicDownloadDelegate*);
	static auto func = wrapFunction(base::get() + 0x2829d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::responseToDict(gd::string p0, char const* p1) -> decltype(responseToDict(p0, p1)) {
	using FunctionType = decltype(responseToDict(p0, p1))(*)(MusicDownloadManager*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x283260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::showTOS(FLAlertLayerProtocol* p0) -> decltype(showTOS(p0)) {
	using FunctionType = decltype(showTOS(p0))(*)(MusicDownloadManager*, FLAlertLayerProtocol*);
	static auto func = wrapFunction(base::get() + 0x2844b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::songStateChanged() -> decltype(songStateChanged()) {
	using FunctionType = decltype(songStateChanged())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x282a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::tryLoadLibraries() -> decltype(tryLoadLibraries()) {
	using FunctionType = decltype(tryLoadLibraries())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x287210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::tryUpdateSFXLibrary() -> decltype(tryUpdateSFXLibrary()) {
	using FunctionType = decltype(tryUpdateSFXLibrary())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x2866f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MusicDownloadManager::init), this);
	using FunctionType = decltype(init())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x282880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsObjectDelegate::stateChanged(OptionsObject* p0) -> decltype(stateChanged(p0)) {
	throw std::runtime_error("OptionsObjectDelegate::stateChanged not implemented");
}

auto MusicSearchResult::updateObjects() -> decltype(updateObjects()) {
	using FunctionType = decltype(updateObjects())(*)(MusicSearchResult*);
	static auto func = wrapFunction(base::get() + 0x2898e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicSearchResult::updateObjects(AudioSortType p0) -> decltype(updateObjects(p0)) {
	throw std::runtime_error("MusicSearchResult::updateObjects not implemented");
}

auto MusicSearchResult::stateChanged(OptionsObject* p0) -> decltype(stateChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<OptionsObject*>::func(&MusicSearchResult::stateChanged), this);
	using FunctionType = decltype(stateChanged(p0))(*)(MusicSearchResult*, OptionsObject*);
	static auto func = wrapFunction(base::get() + 0x2898d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto NewgroundsInfoLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x90e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto NewgroundsInfoLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NewgroundsInfoLayer::init), this);
	using FunctionType = decltype(init())(*)(NewgroundsInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x90f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NewgroundsInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("NewgroundsInfoLayer::keyBackClicked not implemented");
}

auto NewgroundsInfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("NewgroundsInfoLayer::FLAlert_Clicked not implemented");
}

auto NumberInputLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x28ab70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto NumberInputLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NumberInputLayer::init), this);
	using FunctionType = decltype(init())(*)(NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x28ac10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NumberInputLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("NumberInputLayer::registerWithTouchDispatcher not implemented");
}

auto NumberInputLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("NumberInputLayer::keyBackClicked not implemented");
}

auto OBB2D::create(cocos2d::CCPoint p0, float p1, float p2, float p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::CCPoint, float, float, float);
	static auto func = wrapFunction(base::get() + 0x49fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto OBB2D::calculateWithCenter(cocos2d::CCPoint p0, float p1, float p2, float p3) -> decltype(calculateWithCenter(p0, p1, p2, p3)) {
	using FunctionType = decltype(calculateWithCenter(p0, p1, p2, p3))(*)(OBB2D*, cocos2d::CCPoint, float, float, float);
	static auto func = wrapFunction(base::get() + 0x4a140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto OBB2D::computeAxes() -> decltype(computeAxes()) {
	using FunctionType = decltype(computeAxes())(*)(OBB2D*);
	static auto func = wrapFunction(base::get() + 0x4a310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto OBB2D::getBoundingRect() -> decltype(getBoundingRect()) {
	using FunctionType = decltype(getBoundingRect())(*)(OBB2D*);
	static auto func = wrapFunction(base::get() + 0x4a670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto OBB2D::orderCorners() -> decltype(orderCorners()) {
	using FunctionType = decltype(orderCorners())(*)(OBB2D*);
	static auto func = wrapFunction(base::get() + 0x4a3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ObjectControlGameObject::init() -> decltype(init()) {
	throw std::runtime_error("ObjectControlGameObject::init not implemented");
}

auto ObjectControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("ObjectControlGameObject::customObjectSetup not implemented");
}

auto ObjectControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("ObjectControlGameObject::getSaveString not implemented");
}

auto ObjectDecoder::init() -> decltype(init()) {
	throw std::runtime_error("ObjectDecoder::init not implemented");
}

auto ObjectManager::getDefinition(char const* p0) -> decltype(getDefinition(p0)) {
	using FunctionType = decltype(getDefinition(p0))(*)(ObjectManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x4bae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ObjectManager::instance() -> decltype(instance()) {
	using FunctionType = decltype(instance())(*)(ObjectManager*);
	static auto func = wrapFunction(base::get() + 0x4a7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ObjectManager::init() -> decltype(init()) {
	throw std::runtime_error("ObjectManager::init not implemented");
}

auto ObjectToolbox::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x28b340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ObjectToolbox::gridNodeSizeForKey(int p0) -> decltype(gridNodeSizeForKey(p0)) {
	using FunctionType = decltype(gridNodeSizeForKey(p0))(*)(ObjectToolbox*, int);
	static auto func = wrapFunction(base::get() + 0x2af310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

const char* ObjectToolbox::intKeyToFrame(int key) {
		return m_allKeys[key].c_str();
	}

auto ObjectToolbox::init() -> decltype(init()) {
	throw std::runtime_error("ObjectToolbox::init not implemented");
}

void OnlineListDelegate::loadListFinished(cocos2d::CCArray* p0, char const* p1) {}

void OnlineListDelegate::loadListFailed(char const* p0) {}

void OnlineListDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto OptionsCell::loadFromObject(OptionsObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(OptionsCell*, OptionsObject*);
	static auto func = wrapFunction(base::get() + 0x83a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto OptionsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2b01c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto OptionsLayer::musicSliderChanged(cocos2d::CCObject* p0) -> decltype(musicSliderChanged(p0)) {
	using FunctionType = decltype(musicSliderChanged(p0))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b0d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto OptionsLayer::onAccount(cocos2d::CCObject* sender) -> decltype(onAccount(sender)) {
	using FunctionType = decltype(onAccount(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b1380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onHelp(cocos2d::CCObject* sender) -> decltype(onHelp(sender)) {
	using FunctionType = decltype(onHelp(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b1400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onMenuMusic(cocos2d::CCObject* sender) -> decltype(onMenuMusic(sender)) {
	using FunctionType = decltype(onMenuMusic(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b0ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onOptions(cocos2d::CCObject* sender) -> decltype(onOptions(sender)) {
	using FunctionType = decltype(onOptions(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b0f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onRate(cocos2d::CCObject* sender) -> decltype(onRate(sender)) {
	using FunctionType = decltype(onRate(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b13c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onSecretVault(cocos2d::CCObject* sender) -> decltype(onSecretVault(sender)) {
	using FunctionType = decltype(onSecretVault(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b0f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onSoundtracks(cocos2d::CCObject* sender) -> decltype(onSoundtracks(sender)) {
	using FunctionType = decltype(onSoundtracks(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b0f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onSupport(cocos2d::CCObject* sender) -> decltype(onSupport(sender)) {
	using FunctionType = decltype(onSupport(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b1340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::onVideo(cocos2d::CCObject* sender) -> decltype(onVideo(sender)) {
	using FunctionType = decltype(onVideo(sender))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b1320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto OptionsLayer::sfxSliderChanged(cocos2d::CCObject* p0) -> decltype(sfxSliderChanged(p0)) {
	using FunctionType = decltype(sfxSliderChanged(p0))(*)(OptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b0e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto OptionsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(OptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2b02d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(OptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2b1420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("OptionsLayer::FLAlert_Clicked not implemented");
}

auto OptionsScrollLayer::create(cocos2d::CCArray* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x280890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto OptionsScrollLayer::init(cocos2d::CCArray* p0, bool p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(OptionsScrollLayer*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x280940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto OptionsScrollLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("OptionsScrollLayer::registerWithTouchDispatcher not implemented");
}

auto OptionsScrollLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("OptionsScrollLayer::keyBackClicked not implemented");
}

auto OptionsScrollLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("OptionsScrollLayer::cellPerformedAction not implemented");
}

auto ParentalOptionsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2b78f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ParentalOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParentalOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(ParentalOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2b7990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParentalOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ParentalOptionsLayer::keyBackClicked not implemented");
}

auto ParticleGameObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x398080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ParticleGameObject::setParticleString(gd::string p0) -> decltype(setParticleString(p0)) {
	using FunctionType = decltype(setParticleString(p0))(*)(ParticleGameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x398c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ParticleGameObject::updateParticle() -> decltype(updateParticle()) {
	using FunctionType = decltype(updateParticle())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x398cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ParticleGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::init), this);
	using FunctionType = decltype(init())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x398120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	throw std::runtime_error("ParticleGameObject::setScaleX not implemented");
}

auto ParticleGameObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	throw std::runtime_error("ParticleGameObject::setScaleY not implemented");
}

auto ParticleGameObject::setScale(float p0) -> decltype(setScale(p0)) {
	throw std::runtime_error("ParticleGameObject::setScale not implemented");
}

auto ParticleGameObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	throw std::runtime_error("ParticleGameObject::setRotation not implemented");
}

auto ParticleGameObject::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	throw std::runtime_error("ParticleGameObject::setRotationX not implemented");
}

auto ParticleGameObject::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	throw std::runtime_error("ParticleGameObject::setRotationY not implemented");
}

auto ParticleGameObject::setChildColor(cocos2d::ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	throw std::runtime_error("ParticleGameObject::setChildColor not implemented");
}

auto ParticleGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x3983f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	throw std::runtime_error("ParticleGameObject::addMainSpriteToParent not implemented");
}

auto ParticleGameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("ParticleGameObject::resetObject not implemented");
}

auto ParticleGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	throw std::runtime_error("ParticleGameObject::deactivateObject not implemented");
}

auto ParticleGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&ParticleGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ParticleGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x398170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ParticleGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ParticleGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ParticleGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x399880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::claimParticle() -> decltype(claimParticle()) {
	throw std::runtime_error("ParticleGameObject::claimParticle not implemented");
}

auto ParticleGameObject::unclaimParticle() -> decltype(unclaimParticle()) {
	throw std::runtime_error("ParticleGameObject::unclaimParticle not implemented");
}

auto ParticleGameObject::particleWasActivated() -> decltype(particleWasActivated()) {
	throw std::runtime_error("ParticleGameObject::particleWasActivated not implemented");
}

auto ParticleGameObject::setObjectColor(cocos2d::ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	throw std::runtime_error("ParticleGameObject::setObjectColor not implemented");
}

auto ParticleGameObject::blendModeChanged() -> decltype(blendModeChanged()) {
	throw std::runtime_error("ParticleGameObject::blendModeChanged not implemented");
}

auto ParticleGameObject::updateParticleColor(cocos2d::ccColor3B const& p0) -> decltype(updateParticleColor(p0)) {
	throw std::runtime_error("ParticleGameObject::updateParticleColor not implemented");
}

auto ParticleGameObject::updateParticleOpacity(unsigned char p0) -> decltype(updateParticleOpacity(p0)) {
	throw std::runtime_error("ParticleGameObject::updateParticleOpacity not implemented");
}

auto ParticleGameObject::updateMainParticleOpacity(unsigned char p0) -> decltype(updateMainParticleOpacity(p0)) {
	throw std::runtime_error("ParticleGameObject::updateMainParticleOpacity not implemented");
}

auto ParticleGameObject::updateSecondaryParticleOpacity(unsigned char p0) -> decltype(updateSecondaryParticleOpacity(p0)) {
	throw std::runtime_error("ParticleGameObject::updateSecondaryParticleOpacity not implemented");
}

auto ParticleGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	throw std::runtime_error("ParticleGameObject::updateSyncedAnimation not implemented");
}

auto ParticleGameObject::updateAnimateOnTrigger(bool p0) -> decltype(updateAnimateOnTrigger(p0)) {
	throw std::runtime_error("ParticleGameObject::updateAnimateOnTrigger not implemented");
}

auto ParticlePreviewLayer::create(cocos2d::CCParticleSystemQuad* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCParticleSystemQuad*);
	static auto func = wrapFunction(base::get() + 0x33fc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto ParticlePreviewLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("ParticlePreviewLayer::draw not implemented");
}

auto ParticlePreviewLayer::visit() -> decltype(visit()) {
	throw std::runtime_error("ParticlePreviewLayer::visit not implemented");
}

auto PauseLayer::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x2b8940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto PauseLayer::goEdit() -> decltype(goEdit()) {
	using FunctionType = decltype(goEdit())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x2ba0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PauseLayer::musicSliderChanged(cocos2d::CCObject* p0) -> decltype(musicSliderChanged(p0)) {
	using FunctionType = decltype(musicSliderChanged(p0))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b9da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PauseLayer::onEdit(cocos2d::CCObject* sender) -> decltype(onEdit(sender)) {
	using FunctionType = decltype(onEdit(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ba020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onNormalMode(cocos2d::CCObject* sender) -> decltype(onNormalMode(sender)) {
	using FunctionType = decltype(onNormalMode(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b9ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onPracticeMode(cocos2d::CCObject* sender) -> decltype(onPracticeMode(sender)) {
	using FunctionType = decltype(onPracticeMode(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b9e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onQuit(cocos2d::CCObject* sender) -> decltype(onQuit(sender)) {
	using FunctionType = decltype(onQuit(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ba240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onRestart(cocos2d::CCObject* sender) -> decltype(onRestart(sender)) {
	using FunctionType = decltype(onRestart(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b9f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onRestartFull(cocos2d::CCObject* sender) -> decltype(onRestartFull(sender)) {
	using FunctionType = decltype(onRestartFull(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b9fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onResume(cocos2d::CCObject* sender) -> decltype(onResume(sender)) {
	using FunctionType = decltype(onResume(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b9f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b94d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::setupProgressBars() -> decltype(setupProgressBars()) {
	using FunctionType = decltype(setupProgressBars())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x2b94f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PauseLayer::sfxSliderChanged(cocos2d::CCObject* p0) -> decltype(sfxSliderChanged(p0)) {
	using FunctionType = decltype(sfxSliderChanged(p0))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b0e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PauseLayer::tryQuit(cocos2d::CCObject* sender) -> decltype(tryQuit(sender)) {
	using FunctionType = decltype(tryQuit(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ba170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PauseLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x2ba3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PauseLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&PauseLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(PauseLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x2ba310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PauseLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PauseLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x2b89f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PauseLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	throw std::runtime_error("PauseLayer::keyUp not implemented");
}

bool PlatformToolbox::isControllerConnected() {
		//todo: mac
		#ifdef GEODE_IS_WINDOWS
			return cocos2d::CCApplication::sharedApplication()->getControllerConnected();
		#else
			return false;
		#endif
	}

auto PlayerCheckpoint::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2eb770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlayerCheckpoint::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerCheckpoint::init), this);
	using FunctionType = decltype(init())(*)(PlayerCheckpoint*);
	static auto func = wrapFunction(base::get() + 0x52e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerControlGameObject::init() -> decltype(init()) {
	throw std::runtime_error("PlayerControlGameObject::init not implemented");
}

auto PlayerControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("PlayerControlGameObject::customObjectSetup not implemented");
}

auto PlayerControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("PlayerControlGameObject::getSaveString not implemented");
}

auto PlayerFireBoostSprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2dab20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlayerFireBoostSprite::animateFireIn() -> decltype(animateFireIn()) {
	using FunctionType = decltype(animateFireIn())(*)(PlayerFireBoostSprite*);
	static auto func = wrapFunction(base::get() + 0x2dac30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void PlayerFireBoostSprite::animateFireOut() {
		this->stopAllActions();
		auto action = cocos2d::CCScaleTo::create(0.4f, 0.01f, 0.01f);
		this->runAction(action);
	}

auto PlayerFireBoostSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerFireBoostSprite::init), this);
	using FunctionType = decltype(init())(*)(PlayerFireBoostSprite*);
	static auto func = wrapFunction(base::get() + 0x2dabe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::create(int p0, int p1, GJBaseGameLayer* p2, cocos2d::CCLayer* p3, bool p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(int, int, GJBaseGameLayer*, cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2c2410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto PlayerObject::activateStreak() -> decltype(activateStreak()) {
	using FunctionType = decltype(activateStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d89c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::addAllParticles() -> decltype(addAllParticles()) {
	using FunctionType = decltype(addAllParticles())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2c3b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::animatePlatformerJump(float p0) -> decltype(animatePlatformerJump(p0)) {
	using FunctionType = decltype(animatePlatformerJump(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2c7820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::boostPlayer(float p0) -> decltype(boostPlayer(p0)) {
	using FunctionType = decltype(boostPlayer(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2d8820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::bumpPlayer(float p0, int p1, bool p2, GameObject* p3) -> decltype(bumpPlayer(p0, p1, p2, p3)) {
	using FunctionType = decltype(bumpPlayer(p0, p1, p2, p3))(*)(PlayerObject*, float, int, bool, GameObject*);
	static auto func = wrapFunction(base::get() + 0x2d80b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto PlayerObject::createFadeOutDartStreak() -> decltype(createFadeOutDartStreak()) {
	using FunctionType = decltype(createFadeOutDartStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d2320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::createRobot(int p0) -> decltype(createRobot(p0)) {
	using FunctionType = decltype(createRobot(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x2c35e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::createSpider(int p0) -> decltype(createSpider(p0)) {
	using FunctionType = decltype(createSpider(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x2c3870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::disableCustomGlowColor() {
		m_hasCustomGlowColor = false;
	}

auto PlayerObject::disableSwingFire() -> decltype(disableSwingFire()) {
	using FunctionType = decltype(disableSwingFire())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d4280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::doReversePlayer(bool p0) -> decltype(doReversePlayer(p0)) {
	using FunctionType = decltype(doReversePlayer(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x2d2210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::enableCustomGlowColor(cocos2d::_ccColor3B const& color) {
		m_hasCustomGlowColor = true;
		m_glowColor = color;
	}

auto PlayerObject::fadeOutStreak2(float p0) -> decltype(fadeOutStreak2(p0)) {
	using FunctionType = decltype(fadeOutStreak2(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2d8ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::flashPlayer(float p0, float p1, cocos2d::ccColor3B mainColor, cocos2d::ccColor3B secondColor) -> decltype(flashPlayer(p0, p1, mainColor, secondColor)) {
	using FunctionType = decltype(flashPlayer(p0, p1, mainColor, secondColor))(*)(PlayerObject*, float, float, cocos2d::ccColor3B, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x2d1080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, mainColor, secondColor);
}

auto PlayerObject::flipGravity(bool p0, bool p1) -> decltype(flipGravity(p0, p1)) {
	using FunctionType = decltype(flipGravity(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2d36e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::getActiveMode() -> decltype(getActiveMode()) {
	using FunctionType = decltype(getActiveMode())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d3a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::getModifiedSlopeYVel() -> decltype(getModifiedSlopeYVel()) {
	using FunctionType = decltype(getModifiedSlopeYVel())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2c9d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::getSecondColor() -> decltype(getSecondColor()) {
	using FunctionType = decltype(getSecondColor())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d90e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::incrementJumps() -> decltype(incrementJumps()) {
	using FunctionType = decltype(incrementJumps())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2c77f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::init(int p0, int p1, GJBaseGameLayer* p2, cocos2d::CCLayer* p3, bool p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(PlayerObject*, int, int, GJBaseGameLayer*, cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2c24c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto PlayerObject::isBoostValid(float p0) -> decltype(isBoostValid(p0)) {
	using FunctionType = decltype(isBoostValid(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2c9cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::isFlying() -> decltype(isFlying()) {
	using FunctionType = decltype(isFlying())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d3a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::isInNormalMode() -> decltype(isInNormalMode()) {
	using FunctionType = decltype(isInNormalMode())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d5780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::levelFlipping() -> decltype(levelFlipping()) {
	using FunctionType = decltype(levelFlipping())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d4880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::loadFromCheckpoint(PlayerCheckpoint* p0) -> decltype(loadFromCheckpoint(p0)) {
	using FunctionType = decltype(loadFromCheckpoint(p0))(*)(PlayerObject*, PlayerCheckpoint*);
	static auto func = wrapFunction(base::get() + 0x2d9e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::lockPlayer() -> decltype(lockPlayer()) {
	using FunctionType = decltype(lockPlayer())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d7d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::placeStreakPoint() -> decltype(placeStreakPoint()) {
	using FunctionType = decltype(placeStreakPoint())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d9110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playBumpEffect(int p0, GameObject* p1) -> decltype(playBumpEffect(p0, p1)) {
	using FunctionType = decltype(playBumpEffect(p0, p1))(*)(PlayerObject*, int, GameObject*);
	static auto func = wrapFunction(base::get() + 0x2d8380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::playCompleteEffect(bool p0, bool p1) -> decltype(playCompleteEffect(p0, p1)) {
	using FunctionType = decltype(playCompleteEffect(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2bfd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::playDeathEffect() -> decltype(playDeathEffect()) {
	using FunctionType = decltype(playDeathEffect())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2ba470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playDynamicSpiderRun() -> decltype(playDynamicSpiderRun()) {
	using FunctionType = decltype(playDynamicSpiderRun())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d9ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playerDestroyed(bool p0) -> decltype(playerDestroyed(p0)) {
	using FunctionType = decltype(playerDestroyed(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x2d1b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::playerIsFalling(float p0) -> decltype(playerIsFalling(p0)) {
	using FunctionType = decltype(playerIsFalling(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2d39b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::playSpiderDashEffect(cocos2d::CCPoint from, cocos2d::CCPoint to) -> decltype(playSpiderDashEffect(from, to)) {
	using FunctionType = decltype(playSpiderDashEffect(from, to))(*)(PlayerObject*, cocos2d::CCPoint, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x2cf5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, from, to);
}

auto PlayerObject::postCollision(float p0) -> decltype(postCollision(p0)) {
	using FunctionType = decltype(postCollision(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2c82f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::preCollision() -> decltype(preCollision()) {
	using FunctionType = decltype(preCollision())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2c81b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::propellPlayer(float p0, bool p1, int p2) -> decltype(propellPlayer(p0, p1, p2)) {
	using FunctionType = decltype(propellPlayer(p0, p1, p2))(*)(PlayerObject*, float, bool, int);
	static auto func = wrapFunction(base::get() + 0x2d81b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto PlayerObject::pushButton(PlayerButton p0) -> decltype(pushButton(p0)) {
	using FunctionType = decltype(pushButton(p0))(*)(PlayerObject*, PlayerButton);
	static auto func = wrapFunction(base::get() + 0x2d1d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::redirectDash(float p0) -> decltype(redirectDash(p0)) {
	using FunctionType = decltype(redirectDash(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2cfbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::releaseButton(PlayerButton p0) -> decltype(releaseButton(p0)) {
	using FunctionType = decltype(releaseButton(p0))(*)(PlayerObject*, PlayerButton);
	static auto func = wrapFunction(base::get() + 0x2d1f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::removePendingCheckpoint() -> decltype(removePendingCheckpoint()) {
	using FunctionType = decltype(removePendingCheckpoint())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2da1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::resetPlayerIcon() -> decltype(resetPlayerIcon()) {
	using FunctionType = decltype(resetPlayerIcon())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d45b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::resetStreak() -> decltype(resetStreak()) {
	using FunctionType = decltype(resetStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2c6540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::reversePlayer(EffectGameObject* p0) -> decltype(reversePlayer(p0)) {
	using FunctionType = decltype(reversePlayer(p0))(*)(PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x2d2130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::ringJump(RingObject* p0, bool p1) -> decltype(ringJump(p0, p1)) {
	using FunctionType = decltype(ringJump(p0, p1))(*)(PlayerObject*, RingObject*, bool);
	static auto func = wrapFunction(base::get() + 0x2d27c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::rotateGameplay(int p0, int p1, bool p2, float p3, float p4, bool p5, bool p6) -> decltype(rotateGameplay(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(rotateGameplay(p0, p1, p2, p3, p4, p5, p6))(*)(PlayerObject*, int, int, bool, float, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2d3340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto PlayerObject::runBallRotation(float p0) -> decltype(runBallRotation(p0)) {
	using FunctionType = decltype(runBallRotation(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2c7e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::runBallRotation2() -> decltype(runBallRotation2()) {
	using FunctionType = decltype(runBallRotation2())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2c7f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void PlayerObject::runNormalRotation() {
		this->runNormalRotation(false, 1.0f);
	}

auto PlayerObject::runNormalRotation(bool p0, float p1) -> decltype(runNormalRotation(p0, p1)) {
	using FunctionType = decltype(runNormalRotation(p0, p1))(*)(PlayerObject*, bool, float);
	static auto func = wrapFunction(base::get() + 0x2c7cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::runRotateAction(bool p0, int p1) -> decltype(runRotateAction(p0, p1)) {
	using FunctionType = decltype(runRotateAction(p0, p1))(*)(PlayerObject*, bool, int);
	static auto func = wrapFunction(base::get() + 0x2c7c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::saveToCheckpoint(PlayerCheckpoint* p0) -> decltype(saveToCheckpoint(p0)) {
	using FunctionType = decltype(saveToCheckpoint(p0))(*)(PlayerObject*, PlayerCheckpoint*);
	static auto func = wrapFunction(base::get() + 0x2d9c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::setSecondColor(cocos2d::ccColor3B const& p0) -> decltype(setSecondColor(p0)) {
	using FunctionType = decltype(setSecondColor(p0))(*)(PlayerObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x2d65a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::setupStreak() -> decltype(setupStreak()) {
	using FunctionType = decltype(setupStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2c3c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::setYVelocity(double p0, int p1) -> decltype(setYVelocity(p0, p1)) {
	using FunctionType = decltype(setYVelocity(p0, p1))(*)(PlayerObject*, double, int);
	static auto func = wrapFunction(base::get() + 0x2c40c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::spawnDualCircle() -> decltype(spawnDualCircle()) {
	using FunctionType = decltype(spawnDualCircle())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d1a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::spawnFromPlayer(PlayerObject* p0, bool p1) -> decltype(spawnFromPlayer(p0, p1)) {
	using FunctionType = decltype(spawnFromPlayer(p0, p1))(*)(PlayerObject*, PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x2d8f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::spawnPortalCircle(cocos2d::ccColor3B p0, float p1) -> decltype(spawnPortalCircle(p0, p1)) {
	using FunctionType = decltype(spawnPortalCircle(p0, p1))(*)(PlayerObject*, cocos2d::ccColor3B, float);
	static auto func = wrapFunction(base::get() + 0x2d1810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::spawnScaleCircle() -> decltype(spawnScaleCircle()) {
	using FunctionType = decltype(spawnScaleCircle())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d1920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::startDashing(DashRingObject* p0) -> decltype(startDashing(p0)) {
	using FunctionType = decltype(startDashing(p0))(*)(PlayerObject*, DashRingObject*);
	static auto func = wrapFunction(base::get() + 0x2cfdb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::stopDashing() -> decltype(stopDashing()) {
	using FunctionType = decltype(stopDashing())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d0940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::stopPlatformerJumpAnimation() -> decltype(stopPlatformerJumpAnimation()) {
	using FunctionType = decltype(stopPlatformerJumpAnimation())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2c7b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::stopStreak2() -> decltype(stopStreak2()) {
	using FunctionType = decltype(stopStreak2())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d8b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::switchedDirTo(PlayerButton p0) -> decltype(switchedDirTo(p0)) {
	using FunctionType = decltype(switchedDirTo(p0))(*)(PlayerObject*, PlayerButton);
	static auto func = wrapFunction(base::get() + 0x2d1c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::switchedToMode(GameObjectType p0) -> decltype(switchedToMode(p0)) {
	using FunctionType = decltype(switchedToMode(p0))(*)(PlayerObject*, GameObjectType);
	static auto func = wrapFunction(base::get() + 0x2d4fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::toggleBirdMode(bool p0, bool p1) -> decltype(toggleBirdMode(p0, p1)) {
	using FunctionType = decltype(toggleBirdMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2d3d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleDartMode(bool p0, bool p1) -> decltype(toggleDartMode(p0, p1)) {
	using FunctionType = decltype(toggleDartMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2d42f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleFlyMode(bool p0, bool p1) -> decltype(toggleFlyMode(p0, p1)) {
	using FunctionType = decltype(toggleFlyMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2d3aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleGhostEffect(GhostType p0) -> decltype(toggleGhostEffect(p0)) {
	using FunctionType = decltype(toggleGhostEffect(p0))(*)(PlayerObject*, GhostType);
	static auto func = wrapFunction(base::get() + 0x2d7a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::togglePlatformerMode(bool val) {
        m_isPlatformer = val;
    }

auto PlayerObject::togglePlayerScale(bool p0, bool p1) -> decltype(togglePlayerScale(p0, p1)) {
	using FunctionType = decltype(togglePlayerScale(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2d9170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleRobotMode(bool p0, bool p1) -> decltype(toggleRobotMode(p0, p1)) {
	using FunctionType = decltype(toggleRobotMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2d49f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleRollMode(bool p0, bool p1) -> decltype(toggleRollMode(p0, p1)) {
	using FunctionType = decltype(toggleRollMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2d48c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleSpiderMode(bool p0, bool p1) -> decltype(toggleSpiderMode(p0, p1)) {
	using FunctionType = decltype(toggleSpiderMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2d4ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleSwingMode(bool p0, bool p1) -> decltype(toggleSwingMode(p0, p1)) {
	using FunctionType = decltype(toggleSwingMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2d3fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleVisibility(bool p0) -> decltype(toggleVisibility(p0)) {
	using FunctionType = decltype(toggleVisibility(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x2c63f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::tryPlaceCheckpoint() -> decltype(tryPlaceCheckpoint()) {
	using FunctionType = decltype(tryPlaceCheckpoint())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2da220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updateCheckpointTest() -> decltype(updateCheckpointTest()) {
	using FunctionType = decltype(updateCheckpointTest())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2c6310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updateDashAnimation() -> decltype(updateDashAnimation()) {
	using FunctionType = decltype(updateDashAnimation())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d0ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updateDashArt() -> decltype(updateDashArt()) {
	using FunctionType = decltype(updateDashArt())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d0530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updateGlowColor() -> decltype(updateGlowColor()) {
	using FunctionType = decltype(updateGlowColor())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d6610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updateJump(float p0) -> decltype(updateJump(p0)) {
	using FunctionType = decltype(updateJump(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2c67b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerArt() -> decltype(updatePlayerArt()) {
	using FunctionType = decltype(updatePlayerArt())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d23e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updatePlayerBirdFrame(int p0) -> decltype(updatePlayerBirdFrame(p0)) {
	using FunctionType = decltype(updatePlayerBirdFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x2d70e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerDartFrame(int p0) -> decltype(updatePlayerDartFrame(p0)) {
	using FunctionType = decltype(updatePlayerDartFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x2d7680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerFrame(int p0) -> decltype(updatePlayerFrame(p0)) {
	using FunctionType = decltype(updatePlayerFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x2d6b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerGlow() -> decltype(updatePlayerGlow()) {
	using FunctionType = decltype(updatePlayerGlow())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d8c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updatePlayerJetpackFrame(int p0) -> decltype(updatePlayerJetpackFrame(p0)) {
	using FunctionType = decltype(updatePlayerJetpackFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x2d6f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::updatePlayerRobotFrame(int id) {
        if (id < 1) id = 1;
        else if (id > 0x43) id = 0x44;

        createRobot(id);
    }

auto PlayerObject::updatePlayerRollFrame(int p0) -> decltype(updatePlayerRollFrame(p0)) {
	using FunctionType = decltype(updatePlayerRollFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x2d7300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerScale() -> decltype(updatePlayerScale()) {
	using FunctionType = decltype(updatePlayerScale())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d8bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updatePlayerShipFrame(int p0) -> decltype(updatePlayerShipFrame(p0)) {
	using FunctionType = decltype(updatePlayerShipFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x2d6d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::updatePlayerSpiderFrame(int id) {
        if (id < 1) id = 1;
        else if (id > 0x44) id = 0x45;

        createSpider(id);
    }

auto PlayerObject::updatePlayerSpriteExtra(gd::string p0) -> decltype(updatePlayerSpriteExtra(p0)) {
	using FunctionType = decltype(updatePlayerSpriteExtra(p0))(*)(PlayerObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x2d7840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerSwingFrame(int p0) -> decltype(updatePlayerSwingFrame(p0)) {
	using FunctionType = decltype(updatePlayerSwingFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x2d74c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateRotation(float p0) -> decltype(updateRotation(p0)) {
	using FunctionType = decltype(updateRotation(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2cbd20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateShipSpriteExtra(gd::string p0) -> decltype(updateShipSpriteExtra(p0)) {
	using FunctionType = decltype(updateShipSpriteExtra(p0))(*)(PlayerObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x2d7940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateSpecial(float p0) -> decltype(updateSpecial(p0)) {
	using FunctionType = decltype(updateSpecial(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2c62c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateStreakBlend(bool p0) -> decltype(updateStreakBlend(p0)) {
	using FunctionType = decltype(updateStreakBlend(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x2c4050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateSwingFire() -> decltype(updateSwingFire()) {
	using FunctionType = decltype(updateSwingFire())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d41e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updateTimeMod(float p0, bool p1) -> decltype(updateTimeMod(p0, p1)) {
	using FunctionType = decltype(updateTimeMod(p0, p1))(*)(PlayerObject*, float, bool);
	static auto func = wrapFunction(base::get() + 0x2d95e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::update), this);
	using FunctionType = decltype(update(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2c41b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2da740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2da760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2da780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&PlayerObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(PlayerObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x2d5860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayerObject::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x2da7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x2da690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&PlayerObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(PlayerObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x2d6a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&PlayerObject::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(PlayerObject*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x2d6520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayerObject::setFlipX), this);
	using FunctionType = decltype(setFlipX(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x2da6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	throw std::runtime_error("PlayerObject::setFlipY not implemented");
}

auto PlayerObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d1100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::getRealPosition() -> decltype(getRealPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerObject::getRealPosition), this);
	using FunctionType = decltype(getRealPosition())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x2d6b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::getOrientedBox() -> decltype(getOrientedBox()) {
	throw std::runtime_error("PlayerObject::getOrientedBox not implemented");
}

auto PlayerObject::getObjectRotation() -> decltype(getObjectRotation()) {
	throw std::runtime_error("PlayerObject::getObjectRotation not implemented");
}

auto PlayerObject::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	throw std::runtime_error("PlayerObject::animationFinished not implemented");
}

PlayLayer::~PlayLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2dc080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) PlayLayer(geode::CutoffConstructor, sizeof(PlayLayer));
	CCDestructor::lock(this) = true;
}

auto PlayLayer::create(GJGameLevel* level, bool useReplay, bool dontCreateObjects) -> decltype(create(level, useReplay, dontCreateObjects)) {
	using FunctionType = decltype(create(level, useReplay, dontCreateObjects))(*)(GJGameLevel*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2dc3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(level, useReplay, dontCreateObjects);
}

PlayLayer* PlayLayer::get() {
		return GameManager::get()->m_playLayer;
	}

void PlayLayer::addCircle(CCCircleWave* cw) {
		m_circleWaveArray->addObject(cw);
	}

auto PlayLayer::addObject(GameObject* p0) -> decltype(addObject(p0)) {
	using FunctionType = decltype(addObject(p0))(*)(PlayLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x2e19b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::canPauseGame() -> decltype(canPauseGame()) {
	using FunctionType = decltype(canPauseGame())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2eae60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::createCheckpoint() -> decltype(createCheckpoint()) {
	using FunctionType = decltype(createCheckpoint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e76e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::createObjectsFromSetupFinished() -> decltype(createObjectsFromSetupFinished()) {
	using FunctionType = decltype(createObjectsFromSetupFinished())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e1730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::delayedFullReset() -> decltype(delayedFullReset()) {
	using FunctionType = decltype(delayedFullReset())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e9f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::delayedResetLevel() -> decltype(delayedResetLevel()) {
	using FunctionType = decltype(delayedResetLevel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2ea080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::fullReset() -> decltype(fullReset()) {
	using FunctionType = decltype(fullReset())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e9f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

float PlayLayer::getCurrentPercent() {
		float percent;

		if (m_level->m_timestamp > 0) {
			percent = static_cast<float>(m_gameState.m_unk1f8) / m_level->m_timestamp * 100.f;
		} else {
			percent = m_player1->getPosition().x / m_levelLength * 100.f;
		}

		if (percent >= 100.f) {
			return 100.f;
		} else if (percent <= 0.f) {
			return 0.f;
		} else {
			return percent;
		}
	}

auto PlayLayer::getCurrentPercentInt() -> decltype(getCurrentPercentInt()) {
	using FunctionType = decltype(getCurrentPercentInt())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e6680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::getLastCheckpoint() -> decltype(getLastCheckpoint()) {
	using FunctionType = decltype(getLastCheckpoint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e8d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::incrementJumps() -> decltype(incrementJumps()) {
	using FunctionType = decltype(incrementJumps())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2eacd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::init(GJGameLevel* level, bool useReplay, bool dontCreateObjects) -> decltype(init(level, useReplay, dontCreateObjects)) {
	using FunctionType = decltype(init(level, useReplay, dontCreateObjects))(*)(PlayLayer*, GJGameLevel*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2dc4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, level, useReplay, dontCreateObjects);
}

auto PlayLayer::levelComplete() -> decltype(levelComplete()) {
	using FunctionType = decltype(levelComplete())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2ddb60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::loadDefaultColors() -> decltype(loadDefaultColors()) {
	using FunctionType = decltype(loadDefaultColors())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e4e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::loadFromCheckpoint(CheckpointObject* p0) -> decltype(loadFromCheckpoint(p0)) {
	using FunctionType = decltype(loadFromCheckpoint(p0))(*)(PlayLayer*, CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0x2e85e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::markCheckpoint() -> decltype(markCheckpoint()) {
	using FunctionType = decltype(markCheckpoint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e8550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::onQuit() -> decltype(onQuit()) {
	using FunctionType = decltype(onQuit())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2eb480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::optimizeColorGroups() -> decltype(optimizeColorGroups()) {
	using FunctionType = decltype(optimizeColorGroups())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e2530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::optimizeOpacityGroups() -> decltype(optimizeOpacityGroups()) {
	using FunctionType = decltype(optimizeOpacityGroups())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e2790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::pauseGame(bool p0) -> decltype(pauseGame(p0)) {
	using FunctionType = decltype(pauseGame(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2eae80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::playEndAnimationToPos(cocos2d::CCPoint p0) -> decltype(playEndAnimationToPos(p0)) {
	using FunctionType = decltype(playEndAnimationToPos(p0))(*)(PlayLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x2dfe00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::playPlatformerEndAnimationToPos(cocos2d::CCPoint p0, bool p1) -> decltype(playPlatformerEndAnimationToPos(p0, p1)) {
	using FunctionType = decltype(playPlatformerEndAnimationToPos(p0, p1))(*)(PlayLayer*, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0x2e05e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayLayer::prepareCreateObjectsFromSetup(gd::string& p0) -> decltype(prepareCreateObjectsFromSetup(p0)) {
	using FunctionType = decltype(prepareCreateObjectsFromSetup(p0))(*)(PlayLayer*, gd::string&);
	static auto func = wrapFunction(base::get() + 0x2e0c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::prepareMusic(bool p0) -> decltype(prepareMusic(p0)) {
	using FunctionType = decltype(prepareMusic(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2eb2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::processCreateObjectsFromSetup() -> decltype(processCreateObjectsFromSetup()) {
	using FunctionType = decltype(processCreateObjectsFromSetup())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e0ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::removeAllObjects() -> decltype(removeAllObjects()) {
	using FunctionType = decltype(removeAllObjects())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2eb570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::removeCheckpoint(bool p0) -> decltype(removeCheckpoint(p0)) {
	using FunctionType = decltype(removeCheckpoint(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2e8d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::resetLevel() -> decltype(resetLevel()) {
	using FunctionType = decltype(resetLevel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2ea130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::resetLevelFromStart() -> decltype(resetLevelFromStart()) {
	using FunctionType = decltype(resetLevelFromStart())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2ea090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::resume() -> decltype(resume()) {
	using FunctionType = decltype(resume())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2eb100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::resumeAndRestart(bool p0) -> decltype(resumeAndRestart(p0)) {
	using FunctionType = decltype(resumeAndRestart(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2eafe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::saveActiveSaveObjects(gd::vector<SavedActiveObjectState>& p0, gd::vector<SavedSpecialObjectState>& p1) -> decltype(saveActiveSaveObjects(p0, p1)) {
	using FunctionType = decltype(saveActiveSaveObjects(p0, p1))(*)(PlayLayer*, gd::vector<SavedActiveObjectState>&, gd::vector<SavedSpecialObjectState>&);
	static auto func = wrapFunction(base::get() + 0x2e9c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayLayer::saveDynamicSaveObjects(gd::vector<SavedObjectStateRef>& p0) -> decltype(saveDynamicSaveObjects(p0)) {
	using FunctionType = decltype(saveDynamicSaveObjects(p0))(*)(PlayLayer*, gd::vector<SavedObjectStateRef>&);
	static auto func = wrapFunction(base::get() + 0x2e9780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::scanActiveSaveObjects() -> decltype(scanActiveSaveObjects()) {
	using FunctionType = decltype(scanActiveSaveObjects())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e9b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::scanDynamicSaveObjects() -> decltype(scanDynamicSaveObjects()) {
	using FunctionType = decltype(scanDynamicSaveObjects())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e8f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::scene(GJGameLevel* level, bool useReplay, bool dontCreateObjects) -> decltype(scene(level, useReplay, dontCreateObjects)) {
	using FunctionType = decltype(scene(level, useReplay, dontCreateObjects))(*)(GJGameLevel*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2dc3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(level, useReplay, dontCreateObjects);
}

auto PlayLayer::setDamageVerifiedIdx(int p0) -> decltype(setDamageVerifiedIdx(p0)) {
	using FunctionType = decltype(setDamageVerifiedIdx(p0))(*)(PlayLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2db7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::setupHasCompleted() -> decltype(setupHasCompleted()) {
	using FunctionType = decltype(setupHasCompleted())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2dce40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showCompleteEffect() -> decltype(showCompleteEffect()) {
	using FunctionType = decltype(showCompleteEffect())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2de940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showCompleteText() -> decltype(showCompleteText()) {
	using FunctionType = decltype(showCompleteText())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2de410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showHint() -> decltype(showHint()) {
	using FunctionType = decltype(showHint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e6f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showNewBest(bool p0, int p1, int p2, bool p3, bool p4, bool p5) -> decltype(showNewBest(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(showNewBest(p0, p1, p2, p3, p4, p5))(*)(PlayLayer*, bool, int, int, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2dedc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto PlayLayer::startGame() -> decltype(startGame()) {
	using FunctionType = decltype(startGame())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2ddab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::startGameDelayed() -> decltype(startGameDelayed()) {
	using FunctionType = decltype(startGameDelayed())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2ddaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::startMusic() -> decltype(startMusic()) {
	using FunctionType = decltype(startMusic())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2eb3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::storeCheckpoint(CheckpointObject* p0) -> decltype(storeCheckpoint(p0)) {
	using FunctionType = decltype(storeCheckpoint(p0))(*)(PlayLayer*, CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0x2e84a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::togglePracticeMode(bool p0) -> decltype(togglePracticeMode(p0)) {
	using FunctionType = decltype(togglePracticeMode(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2ead30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::updateAttempts() -> decltype(updateAttempts()) {
	using FunctionType = decltype(updateAttempts())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2eab40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateEffectPositions() -> decltype(updateEffectPositions()) {
	using FunctionType = decltype(updateEffectPositions())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e7130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateInfoLabel() -> decltype(updateInfoLabel()) {
	using FunctionType = decltype(updateInfoLabel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e5ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateProgressbar() -> decltype(updateProgressbar()) {
	using FunctionType = decltype(updateProgressbar())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e5440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateTimeWarp(EffectGameObject* p0, float p1) -> decltype(updateTimeWarp(p0, p1)) {
	using FunctionType = decltype(updateTimeWarp(p0, p1))(*)(PlayLayer*, EffectGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1b9700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2eb700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2eb730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::postUpdate), this);
	using FunctionType = decltype(postUpdate(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2e7220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::checkForEnd() -> decltype(checkForEnd()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::checkForEnd), this);
	using FunctionType = decltype(checkForEnd())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e74d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::testTime() -> decltype(testTime()) {
	throw std::runtime_error("PlayLayer::testTime not implemented");
}

auto PlayLayer::updateVerifyDamage() -> decltype(updateVerifyDamage()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::updateVerifyDamage), this);
	using FunctionType = decltype(updateVerifyDamage())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e75b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::updateAttemptTime(float p0) -> decltype(updateAttemptTime(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::updateAttemptTime), this);
	using FunctionType = decltype(updateAttemptTime(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2e7630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::updateVisibility), this);
	using FunctionType = decltype(updateVisibility(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2e2bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::opacityForObject(GameObject* p0) -> decltype(opacityForObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&PlayLayer::opacityForObject), this);
	using FunctionType = decltype(opacityForObject(p0))(*)(PlayLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x2e3920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::updateColor(cocos2d::ccColor3B& p0, float p1, int p2, bool p3, float p4, cocos2d::ccHSVValue& p5, int p6, bool p7, EffectGameObject* p8, int p9, int p10) -> decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int>::func(&PlayLayer::updateColor), this);
	using FunctionType = decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10))(*)(PlayLayer*, cocos2d::ccColor3B&, float, int, bool, float, cocos2d::ccHSVValue&, int, bool, EffectGameObject*, int, int);
	static auto func = wrapFunction(base::get() + 0x2e50e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);
}

auto PlayLayer::activateEndTrigger(int p0, bool p1, bool p2) -> decltype(activateEndTrigger(p0, p1, p2)) {
	throw std::runtime_error("PlayLayer::activateEndTrigger not implemented");
}

auto PlayLayer::activatePlatformerEndTrigger(EndTriggerGameObject* p0, gd::vector<int> const& p1) -> decltype(activatePlatformerEndTrigger(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<EndTriggerGameObject*, gd::vector<int> const&>::func(&PlayLayer::activatePlatformerEndTrigger), this);
	using FunctionType = decltype(activatePlatformerEndTrigger(p0, p1))(*)(PlayLayer*, EndTriggerGameObject*, gd::vector<int> const&);
	static auto func = wrapFunction(base::get() + 0x2e04d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PlayLayer::toggleGlitter(bool p0) -> decltype(toggleGlitter(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleGlitter), this);
	using FunctionType = decltype(toggleGlitter(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2e6630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::destroyPlayer(PlayerObject* p0, GameObject* p1) -> decltype(destroyPlayer(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*, GameObject*>::func(&PlayLayer::destroyPlayer), this);
	using FunctionType = decltype(destroyPlayer(p0, p1))(*)(PlayLayer*, PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x2e6730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PlayLayer::toggleGroundVisibility(bool p0) -> decltype(toggleGroundVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleGroundVisibility), this);
	using FunctionType = decltype(toggleGroundVisibility(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2e64e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::toggleMGVisibility(bool p0) -> decltype(toggleMGVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleMGVisibility), this);
	using FunctionType = decltype(toggleMGVisibility(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2e6560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::toggleHideAttempts(bool p0) -> decltype(toggleHideAttempts(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleHideAttempts), this);
	using FunctionType = decltype(toggleHideAttempts(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2e65b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) -> decltype(timeForPos(p0, p1, p2, p3, p4)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint, int, int, bool, int>::func(&PlayLayer::timeForPos), this);
	using FunctionType = decltype(timeForPos(p0, p1, p2, p3, p4))(*)(PlayLayer*, cocos2d::CCPoint, int, int, bool, int);
	static auto func = wrapFunction(base::get() + 0x2e63e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3, p4);
}

auto PlayLayer::posForTime(float p0) -> decltype(posForTime(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::posForTime), this);
	using FunctionType = decltype(posForTime(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0x2e6450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::resetSPTriggered() -> decltype(resetSPTriggered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::resetSPTriggered), this);
	using FunctionType = decltype(resetSPTriggered())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0x2e64a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::updateTimeWarp(float p0) -> decltype(updateTimeWarp(p0)) {
	throw std::runtime_error("PlayLayer::updateTimeWarp not implemented");
}

auto PlayLayer::playGravityEffect(bool p0) -> decltype(playGravityEffect(p0)) {
	throw std::runtime_error("PlayLayer::playGravityEffect not implemented");
}

auto PlayLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&PlayLayer::manualUpdateObjectColors), this);
	using FunctionType = decltype(manualUpdateObjectColors(p0))(*)(PlayLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x2e3940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CheckpointGameObject*>::func(&PlayLayer::checkpointActivated), this);
	using FunctionType = decltype(checkpointActivated(p0))(*)(PlayLayer*, CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x2e76c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::flipArt(bool p0) -> decltype(flipArt(p0)) {
	throw std::runtime_error("PlayLayer::flipArt not implemented");
}

auto PlayLayer::updateTimeLabel(int p0, int p1, bool p2) -> decltype(updateTimeLabel(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<int, int, bool>::func(&PlayLayer::updateTimeLabel), this);
	using FunctionType = decltype(updateTimeLabel(p0, p1, p2))(*)(PlayLayer*, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x2e5670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto PlayLayer::checkSnapshot() -> decltype(checkSnapshot()) {
	throw std::runtime_error("PlayLayer::checkSnapshot not implemented");
}

auto PlayLayer::toggleProgressbar() -> decltype(toggleProgressbar()) {
	throw std::runtime_error("PlayLayer::toggleProgressbar not implemented");
}

auto PlayLayer::toggleInfoLabel() -> decltype(toggleInfoLabel()) {
	throw std::runtime_error("PlayLayer::toggleInfoLabel not implemented");
}

auto PlayLayer::removeAllCheckpoints() -> decltype(removeAllCheckpoints()) {
	throw std::runtime_error("PlayLayer::removeAllCheckpoints not implemented");
}

auto PlayLayer::toggleMusicInPractice() -> decltype(toggleMusicInPractice()) {
	throw std::runtime_error("PlayLayer::toggleMusicInPractice not implemented");
}

auto PlayLayer::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	throw std::runtime_error("PlayLayer::currencyWillExit not implemented");
}

auto PlayLayer::circleWaveWillBeRemoved(CCCircleWave* p0) -> decltype(circleWaveWillBeRemoved(p0)) {
	throw std::runtime_error("PlayLayer::circleWaveWillBeRemoved not implemented");
}

auto PlayLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&PlayLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(PlayLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x2e6f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PointNode::create(cocos2d::CCPoint p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x2274c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto UserInfoDelegate::getUserInfoFinished(GJUserScore* p0) -> decltype(getUserInfoFinished(p0)) {
	throw std::runtime_error("UserInfoDelegate::getUserInfoFinished not implemented");
}

auto UserInfoDelegate::getUserInfoFailed(int p0) -> decltype(getUserInfoFailed(p0)) {
	throw std::runtime_error("UserInfoDelegate::getUserInfoFailed not implemented");
}

auto UserInfoDelegate::userInfoChanged(GJUserScore* p0) -> decltype(userInfoChanged(p0)) {
	throw std::runtime_error("UserInfoDelegate::userInfoChanged not implemented");
}

auto ProfilePage::create(int accountID, bool ownProfile) -> decltype(create(accountID, ownProfile)) {
	using FunctionType = decltype(create(accountID, ownProfile))(*)(int, bool);
	static auto func = wrapFunction(base::get() + 0x2ecfd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(accountID, ownProfile);
}

auto ProfilePage::init(int accountID, bool ownProfile) -> decltype(init(accountID, ownProfile)) {
	using FunctionType = decltype(init(accountID, ownProfile))(*)(ProfilePage*, int, bool);
	static auto func = wrapFunction(base::get() + 0x2ed080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, accountID, ownProfile);
}

auto ProfilePage::isCorrect(char const* key) -> decltype(isCorrect(key)) {
	using FunctionType = decltype(isCorrect(key))(*)(ProfilePage*, char const*);
	static auto func = wrapFunction(base::get() + 0x2f1ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, key);
}

auto ProfilePage::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(ProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x2f1fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::loadPageFromUserInfo(GJUserScore* p0) -> decltype(loadPageFromUserInfo(p0)) {
	using FunctionType = decltype(loadPageFromUserInfo(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x2edda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::onBlockUser(cocos2d::CCObject* sender) -> decltype(onBlockUser(sender)) {
	using FunctionType = decltype(onBlockUser(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f0c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f15e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onComment(cocos2d::CCObject* sender) -> decltype(onComment(sender)) {
	using FunctionType = decltype(onComment(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f09a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onCommentHistory(cocos2d::CCObject* sender) -> decltype(onCommentHistory(sender)) {
	using FunctionType = decltype(onCommentHistory(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f0930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onFollow(cocos2d::CCObject* sender) -> decltype(onFollow(sender)) {
	using FunctionType = decltype(onFollow(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f0e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onFriend(cocos2d::CCObject* sender) -> decltype(onFriend(sender)) {
	using FunctionType = decltype(onFriend(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f0ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onFriends(cocos2d::CCObject* sender) -> decltype(onFriends(sender)) {
	using FunctionType = decltype(onFriends(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f1d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onMessages(cocos2d::CCObject* sender) -> decltype(onMessages(sender)) {
	using FunctionType = decltype(onMessages(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f1d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onMyLevels(cocos2d::CCObject* sender) -> decltype(onMyLevels(sender)) {
	using FunctionType = decltype(onMyLevels(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f0680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onMyLists(cocos2d::CCObject* sender) -> decltype(onMyLists(sender)) {
	using FunctionType = decltype(onMyLists(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f07e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f24c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f24d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onRequests(cocos2d::CCObject* sender) -> decltype(onRequests(sender)) {
	using FunctionType = decltype(onRequests(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f1d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onSendMessage(cocos2d::CCObject* sender) -> decltype(onSendMessage(sender)) {
	using FunctionType = decltype(onSendMessage(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f0960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f1d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onTwitch(cocos2d::CCObject* sender) -> decltype(onTwitch(sender)) {
	using FunctionType = decltype(onTwitch(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f1bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onTwitter(cocos2d::CCObject* sender) -> decltype(onTwitter(sender)) {
	using FunctionType = decltype(onTwitter(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f1a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onUpdate(cocos2d::CCObject* sender) -> decltype(onUpdate(sender)) {
	using FunctionType = decltype(onUpdate(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2edb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onYouTube(cocos2d::CCObject* sender) -> decltype(onYouTube(sender)) {
	using FunctionType = decltype(onYouTube(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f1910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::setupComments() -> decltype(setupComments()) {
	using FunctionType = decltype(setupComments())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x2f1170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ProfilePage::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(ProfilePage*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2f2160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::showNoAccountError() -> decltype(showNoAccountError()) {
	using FunctionType = decltype(showNoAccountError())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x2f1650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x22fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x2f1640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::show), this);
	using FunctionType = decltype(show())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x2f17f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&ProfilePage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(ProfilePage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2f1340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x2f1740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::updateUserScoreFailed), this);
	using FunctionType = decltype(updateUserScoreFailed())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x2f17b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::getUserInfoFinished(GJUserScore* p0) -> decltype(getUserInfoFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJUserScore*>::func(&ProfilePage::getUserInfoFinished), this);
	using FunctionType = decltype(getUserInfoFinished(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x2f1db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::getUserInfoFailed(int p0) -> decltype(getUserInfoFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&ProfilePage::getUserInfoFailed), this);
	using FunctionType = decltype(getUserInfoFailed(p0))(*)(ProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x2f1e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::userInfoChanged(GJUserScore* p0) -> decltype(userInfoChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJUserScore*>::func(&ProfilePage::userInfoChanged), this);
	using FunctionType = decltype(userInfoChanged(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x2f1e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadCommentsFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&ProfilePage::loadCommentsFinished), this);
	using FunctionType = decltype(loadCommentsFinished(p0, p1))(*)(ProfilePage*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x2f2290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::loadCommentsFailed(char const* p0) -> decltype(loadCommentsFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&ProfilePage::loadCommentsFailed), this);
	using FunctionType = decltype(loadCommentsFailed(p0))(*)(ProfilePage*, char const*);
	static auto func = wrapFunction(base::get() + 0x2f22f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&ProfilePage::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(ProfilePage*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x2f2350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	throw std::runtime_error("ProfilePage::commentUploadFinished not implemented");
}

auto ProfilePage::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	throw std::runtime_error("ProfilePage::commentUploadFailed not implemented");
}

auto ProfilePage::commentDeleteFailed(int p0, int p1) -> decltype(commentDeleteFailed(p0, p1)) {
	throw std::runtime_error("ProfilePage::commentDeleteFailed not implemented");
}

auto ProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&ProfilePage::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(ProfilePage*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x2f1480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("ProfilePage::uploadActionFinished not implemented");
}

auto ProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("ProfilePage::uploadActionFailed not implemented");
}

auto PromoInterstitial::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("PromoInterstitial::ccTouchBegan not implemented");
}

auto PromoInterstitial::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("PromoInterstitial::ccTouchMoved not implemented");
}

auto PromoInterstitial::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("PromoInterstitial::ccTouchEnded not implemented");
}

auto PromoInterstitial::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("PromoInterstitial::ccTouchCancelled not implemented");
}

auto PromoInterstitial::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("PromoInterstitial::keyBackClicked not implemented");
}

auto PromoInterstitial::show() -> decltype(show()) {
	throw std::runtime_error("PromoInterstitial::show not implemented");
}

auto PurchaseItemPopup::create(GJStoreItem* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x21cd00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto PurchaseItemPopup::init(GJStoreItem* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(PurchaseItemPopup*, GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x21cda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PurchaseItemPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(PurchaseItemPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x6a750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PurchaseItemPopup::onPurchase(cocos2d::CCObject* sender) -> decltype(onPurchase(sender)) {
	using FunctionType = decltype(onPurchase(sender))(*)(PurchaseItemPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x21d820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PurchaseItemPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("PurchaseItemPopup::keyBackClicked not implemented");
}

auto RandTriggerGameObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3a9860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto RandTriggerGameObject::getRandomGroupID() -> decltype(getRandomGroupID()) {
	using FunctionType = decltype(getRandomGroupID())(*)(RandTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x3a9950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto RandTriggerGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RandTriggerGameObject::init), this);
	using FunctionType = decltype(init())(*)(RandTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x3a9940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RandTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&RandTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(RandTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x3a9a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto RandTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&RandTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(RandTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x3a9b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RandTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&RandTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(RandTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x3a9d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RateDemonLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2f3510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto RateDemonLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(RateDemonLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2f35b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RateDemonLayer::onRate(cocos2d::CCObject* sender) -> decltype(onRate(sender)) {
	using FunctionType = decltype(onRate(sender))(*)(RateDemonLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f3c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateDemonLayer::selectRating(cocos2d::CCObject* p0) -> decltype(selectRating(p0)) {
	using FunctionType = decltype(selectRating(p0))(*)(RateDemonLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f3ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RateDemonLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("RateDemonLayer::keyBackClicked not implemented");
}

auto RateDemonLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("RateDemonLayer::uploadActionFinished not implemented");
}

auto RateDemonLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("RateDemonLayer::uploadActionFailed not implemented");
}

auto RateDemonLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("RateDemonLayer::onClosePopup not implemented");
}

auto RateLevelLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2f3fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto RateLevelLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(RateLevelLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2f4070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RateLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("RateLevelLayer::keyBackClicked not implemented");
}

auto RateStarsLayer::create(int p0, bool p1, bool p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2f4870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto RateStarsLayer::init(int p0, bool p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(RateStarsLayer*, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2f4920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto RateStarsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f53b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateStarsLayer::onFeature(cocos2d::CCObject* sender) -> decltype(onFeature(sender)) {
	using FunctionType = decltype(onFeature(sender))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f4f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateStarsLayer::onRate(cocos2d::CCObject* sender) -> decltype(onRate(sender)) {
	using FunctionType = decltype(onRate(sender))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f51c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateStarsLayer::selectRating(cocos2d::CCObject* p0) -> decltype(selectRating(p0)) {
	using FunctionType = decltype(selectRating(p0))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f5070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RateStarsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("RateStarsLayer::keyBackClicked not implemented");
}

auto RateStarsLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("RateStarsLayer::uploadActionFinished not implemented");
}

auto RateStarsLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("RateStarsLayer::uploadActionFailed not implemented");
}

auto RateStarsLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("RateStarsLayer::onClosePopup not implemented");
}

auto RetryLevelLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2f54d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto RetryLevelLayer::onMenu(cocos2d::CCObject* sender) -> decltype(onMenu(sender)) {
	using FunctionType = decltype(onMenu(sender))(*)(RetryLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f6230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RetryLevelLayer::onReplay(cocos2d::CCObject* sender) -> decltype(onReplay(sender)) {
	using FunctionType = decltype(onReplay(sender))(*)(RetryLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f6140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RetryLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("RetryLevelLayer::keyBackClicked not implemented");
}

auto RetryLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	throw std::runtime_error("RetryLevelLayer::keyDown not implemented");
}

auto RetryLevelLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x2f5650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	throw std::runtime_error("RetryLevelLayer::showLayer not implemented");
}

auto RetryLevelLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	throw std::runtime_error("RetryLevelLayer::enterAnimFinished not implemented");
}

auto RetryLevelLayer::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	throw std::runtime_error("RetryLevelLayer::rewardedVideoFinished not implemented");
}

auto RetryLevelLayer::shouldOffsetRewardCurrency() -> decltype(shouldOffsetRewardCurrency()) {
	throw std::runtime_error("RetryLevelLayer::shouldOffsetRewardCurrency not implemented");
}

auto RetryLevelLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	throw std::runtime_error("RetryLevelLayer::keyUp not implemented");
}

auto RewardsPage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2f6750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto RewardsPage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(RewardsPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x6a750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RewardsPage::onFreeStuff(cocos2d::CCObject* sender) -> decltype(onFreeStuff(sender)) {
	using FunctionType = decltype(onFreeStuff(sender))(*)(RewardsPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f7a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RewardsPage::onReward(cocos2d::CCObject* sender) -> decltype(onReward(sender)) {
	using FunctionType = decltype(onReward(sender))(*)(RewardsPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f74a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RewardsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::init), this);
	using FunctionType = decltype(init())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x2f67f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("RewardsPage::registerWithTouchDispatcher not implemented");
}

auto RewardsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("RewardsPage::keyBackClicked not implemented");
}

auto RewardsPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::show), this);
	using FunctionType = decltype(show())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x2f17f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("RewardsPage::FLAlert_Clicked not implemented");
}

auto RewardsPage::rewardsStatusFinished(int p0) -> decltype(rewardsStatusFinished(p0)) {
	throw std::runtime_error("RewardsPage::rewardsStatusFinished not implemented");
}

auto RewardsPage::rewardsStatusFailed() -> decltype(rewardsStatusFailed()) {
	throw std::runtime_error("RewardsPage::rewardsStatusFailed not implemented");
}

auto RewardUnlockLayer::create(int p0, RewardsPage* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x2f7af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto RewardUnlockLayer::init(int p0, RewardsPage* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(RewardUnlockLayer*, int, RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x2f7ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto RewardUnlockLayer::showCollectReward(GJRewardItem* p0) -> decltype(showCollectReward(p0)) {
	using FunctionType = decltype(showCollectReward(p0))(*)(RewardUnlockLayer*, GJRewardItem*);
	static auto func = wrapFunction(base::get() + 0x2f8860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RewardUnlockLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("RewardUnlockLayer::keyBackClicked not implemented");
}

auto RewardUnlockLayer::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	throw std::runtime_error("RewardUnlockLayer::currencyWillExit not implemented");
}

auto RotateGameplayGameObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3b9090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto RotateGameplayGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RotateGameplayGameObject::init), this);
	using FunctionType = decltype(init())(*)(RotateGameplayGameObject*);
	static auto func = wrapFunction(base::get() + 0x3b9130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RotateGameplayGameObject::updateStartValues() -> decltype(updateStartValues()) {
	throw std::runtime_error("RotateGameplayGameObject::updateStartValues not implemented");
}

auto RotateGameplayGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("RotateGameplayGameObject::customObjectSetup not implemented");
}

auto RotateGameplayGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("RotateGameplayGameObject::getSaveString not implemented");
}

auto ScrollingLayer::create(cocos2d::CCSize p0, cocos2d::CCPoint p1, float p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(cocos2d::CCSize, cocos2d::CCPoint, float);
	static auto func = wrapFunction(base::get() + 0x4c290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto ScrollingLayer::init(cocos2d::CCSize p0, cocos2d::CCPoint p1, float p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(ScrollingLayer*, cocos2d::CCSize, cocos2d::CCPoint, float);
	static auto func = wrapFunction(base::get() + 0x4c360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ScrollingLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("ScrollingLayer::draw not implemented");
}

auto ScrollingLayer::visit() -> decltype(visit()) {
	throw std::runtime_error("ScrollingLayer::visit not implemented");
}

auto ScrollingLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("ScrollingLayer::ccTouchBegan not implemented");
}

auto ScrollingLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("ScrollingLayer::ccTouchMoved not implemented");
}

auto ScrollingLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("ScrollingLayer::ccTouchEnded not implemented");
}

auto ScrollingLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("ScrollingLayer::ccTouchCancelled not implemented");
}

auto SearchButton::create(char const* p0, char const* p1, float p2, char const* p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(char const*, char const*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x265230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto SearchButton::init(char const* p0, char const* p1, float p2, char const* p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(SearchButton*, char const*, char const*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x265320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto SetTextPopup::create(gd::string value, gd::string placeholder, int maxLength, gd::string title, gd::string okBtnText, bool showResetBtn, float p6) -> decltype(create(value, placeholder, maxLength, title, okBtnText, showResetBtn, p6)) {
	using FunctionType = decltype(create(value, placeholder, maxLength, title, okBtnText, showResetBtn, p6))(*)(gd::string, gd::string, int, gd::string, gd::string, bool, float);
	static auto func = wrapFunction(base::get() + 0x211180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(value, placeholder, maxLength, title, okBtnText, showResetBtn, p6);
}

auto SetTextPopup::init(gd::string p0, gd::string p1, int p2, gd::string p3, gd::string p4, bool p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(SetTextPopup*, gd::string, gd::string, int, gd::string, gd::string, bool, float);
	static auto func = wrapFunction(base::get() + 0x211340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto SetTextPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetTextPopup::keyBackClicked not implemented");
}

auto SetTextPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetTextPopup::show), this);
	using FunctionType = decltype(show())(*)(SetTextPopup*);
	static auto func = wrapFunction(base::get() + 0x61860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetTextPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetTextPopup::textInputClosed not implemented");
}

auto SetTextPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetTextPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetTextPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x211b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SearchSFXPopup::create(gd::string p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x37a130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SearchSFXPopup::init(gd::string p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SearchSFXPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x37a1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SearchSFXPopup::onSearchFolders(cocos2d::CCObject* sender) -> decltype(onSearchFolders(sender)) {
	using FunctionType = decltype(onSearchFolders(sender))(*)(SearchSFXPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x37a3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer*);
	static auto func = wrapFunction(base::get() + 0x3017d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SecretLayer::keyBackClicked not implemented");
}

auto SecretLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("SecretLayer::textInputOpened not implemented");
}

auto SecretLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SecretLayer::textInputClosed not implemented");
}

auto SecretLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SecretLayer::textChanged not implemented");
}

auto SecretLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("SecretLayer::FLAlert_Clicked not implemented");
}

auto SecretLayer2::getBasicMessage() -> decltype(getBasicMessage()) {
	using FunctionType = decltype(getBasicMessage())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x309030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer2::onSecretLevel(cocos2d::CCObject* sender) -> decltype(onSecretLevel(sender)) {
	using FunctionType = decltype(onSecretLevel(sender))(*)(SecretLayer2*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x306c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer2::onSubmit(cocos2d::CCObject* sender) -> decltype(onSubmit(sender)) {
	using FunctionType = decltype(onSubmit(sender))(*)(SecretLayer2*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3071c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer2::updateMessageLabel(gd::string p0) -> decltype(updateMessageLabel(p0)) {
	using FunctionType = decltype(updateMessageLabel(p0))(*)(SecretLayer2*, gd::string);
	static auto func = wrapFunction(base::get() + 0x308770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretLayer2::updateSearchLabel(char const* p0) -> decltype(updateSearchLabel(p0)) {
	using FunctionType = decltype(updateSearchLabel(p0))(*)(SecretLayer2*, char const*);
	static auto func = wrapFunction(base::get() + 0x3084b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretLayer2::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer2::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x3056d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer2::onExit() -> decltype(onExit()) {
	throw std::runtime_error("SecretLayer2::onExit not implemented");
}

auto SecretLayer2::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SecretLayer2::keyBackClicked not implemented");
}

auto SecretLayer2::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("SecretLayer2::textInputOpened not implemented");
}

auto SecretLayer2::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SecretLayer2::textInputClosed not implemented");
}

auto SecretLayer2::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SecretLayer2::textChanged not implemented");
}

auto SecretLayer2::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("SecretLayer2::FLAlert_Clicked not implemented");
}

auto SecretLayer2::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("SecretLayer2::dialogClosed not implemented");
}

auto SecretLayer3::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer3::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer3*);
	static auto func = wrapFunction(base::get() + 0x30a320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer3::onExit() -> decltype(onExit()) {
	throw std::runtime_error("SecretLayer3::onExit not implemented");
}

auto SecretLayer3::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SecretLayer3::keyBackClicked not implemented");
}

auto SecretLayer3::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("SecretLayer3::dialogClosed not implemented");
}

auto SecretLayer4::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x30e500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto SecretLayer4::getBasicMessage() -> decltype(getBasicMessage()) {
	using FunctionType = decltype(getBasicMessage())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x310480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer4::getMessage() -> decltype(getMessage()) {
	using FunctionType = decltype(getMessage())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x30fd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer4::getThreadMessage() -> decltype(getThreadMessage()) {
	using FunctionType = decltype(getThreadMessage())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x30fdb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer4::selectAThread() -> decltype(selectAThread()) {
	using FunctionType = decltype(selectAThread())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x3088b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer4::updateMessageLabel(gd::string p0) -> decltype(updateMessageLabel(p0)) {
	using FunctionType = decltype(updateMessageLabel(p0))(*)(SecretLayer4*, gd::string);
	static auto func = wrapFunction(base::get() + 0x308770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretLayer4::updateSearchLabel(char const* p0) -> decltype(updateSearchLabel(p0)) {
	using FunctionType = decltype(updateSearchLabel(p0))(*)(SecretLayer4*, char const*);
	static auto func = wrapFunction(base::get() + 0x3084b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretLayer4::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer4::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x30e5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer4::onExit() -> decltype(onExit()) {
	throw std::runtime_error("SecretLayer4::onExit not implemented");
}

auto SecretLayer4::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SecretLayer4::keyBackClicked not implemented");
}

auto SecretLayer4::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("SecretLayer4::textInputOpened not implemented");
}

auto SecretLayer4::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SecretLayer4::textInputClosed not implemented");
}

auto SecretLayer4::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SecretLayer4::textChanged not implemented");
}

auto SecretLayer4::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("SecretLayer4::FLAlert_Clicked not implemented");
}

auto SecretLayer4::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("SecretLayer4::dialogClosed not implemented");
}

auto SecretNumberLayer::init() -> decltype(init()) {
	throw std::runtime_error("SecretNumberLayer::init not implemented");
}

auto SecretRewardsLayer::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x2fb610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SecretRewardsLayer::createSecondaryLayer(int p0) -> decltype(createSecondaryLayer(p0)) {
	using FunctionType = decltype(createSecondaryLayer(p0))(*)(SecretRewardsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2fd430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretRewardsLayer::generateChestItems(int p0) -> decltype(generateChestItems(p0)) {
	using FunctionType = decltype(generateChestItems(p0))(*)(SecretRewardsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2fd8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretRewardsLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SecretRewardsLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2fb6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretRewardsLayer::onSelectItem(cocos2d::CCObject* sender) -> decltype(onSelectItem(sender)) {
	using FunctionType = decltype(onSelectItem(sender))(*)(SecretRewardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fe220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretRewardsLayer::onShop(cocos2d::CCObject* sender) -> decltype(onShop(sender)) {
	using FunctionType = decltype(onShop(sender))(*)(SecretRewardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fe580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretRewardsLayer::onSpecialItem(cocos2d::CCObject* sender) -> decltype(onSpecialItem(sender)) {
	using FunctionType = decltype(onSpecialItem(sender))(*)(SecretRewardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fe830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretRewardsLayer::showDialog01() -> decltype(showDialog01()) {
	using FunctionType = decltype(showDialog01())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x2fee50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretRewardsLayer::showDialog03() -> decltype(showDialog03()) {
	using FunctionType = decltype(showDialog03())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x2ffb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretRewardsLayer::showDialogDiamond() -> decltype(showDialogDiamond()) {
	using FunctionType = decltype(showDialogDiamond())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x300f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretRewardsLayer::showDialogMechanic() -> decltype(showDialogMechanic()) {
	using FunctionType = decltype(showDialogMechanic())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x300560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretRewardsLayer::switchToOpenedState(CCMenuItemSpriteExtra* p0) -> decltype(switchToOpenedState(p0)) {
	using FunctionType = decltype(switchToOpenedState(p0))(*)(SecretRewardsLayer*, CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x2feb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretRewardsLayer::updateUnlockedLabel() -> decltype(updateUnlockedLabel()) {
	using FunctionType = decltype(updateUnlockedLabel())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x2febb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretRewardsLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("SecretRewardsLayer::onExit not implemented");
}

auto SecretRewardsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SecretRewardsLayer::keyBackClicked not implemented");
}

auto SecretRewardsLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("SecretRewardsLayer::dialogClosed not implemented");
}

auto SecretRewardsLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	throw std::runtime_error("SecretRewardsLayer::scrollLayerMoved not implemented");
}

auto SelectArtLayer::create(SelectArtType p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(SelectArtType, int);
	static auto func = wrapFunction(base::get() + 0x26fcb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SelectArtLayer::init(SelectArtType p0, int p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SelectArtLayer*, SelectArtType, int);
	static auto func = wrapFunction(base::get() + 0x26fd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SelectArtLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SelectArtLayer::keyBackClicked not implemented");
}

auto SelectEventLayer::create(SetupEventLinkPopup* p0, gd::set<int>& p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(SetupEventLinkPopup*, gd::set<int>&);
	static auto func = wrapFunction(base::get() + 0x364ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SelectEventLayer::init(SetupEventLinkPopup* p0, gd::set<int>& p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SelectEventLayer*, SetupEventLinkPopup*, gd::set<int>&);
	static auto func = wrapFunction(base::get() + 0x364f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SelectEventLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SelectEventLayer::keyBackClicked not implemented");
}

auto SelectEventLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SelectEventLayer::onClose not implemented");
}

auto SelectEventLayer::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SelectEventLayer::onCustomToggleTriggerValue not implemented");
}

auto SelectFontLayer::create(LevelEditorLayer* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x204d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SelectFontLayer::init(LevelEditorLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SelectFontLayer*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x204dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SelectFontLayer::onChangeFont(cocos2d::CCObject* sender) -> decltype(onChangeFont(sender)) {
	using FunctionType = decltype(onChangeFont(sender))(*)(SelectFontLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x205460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectFontLayer::updateFontLabel() -> decltype(updateFontLabel()) {
	using FunctionType = decltype(updateFontLabel())(*)(SelectFontLayer*);
	static auto func = wrapFunction(base::get() + 0x205320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SelectFontLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SelectFontLayer::keyBackClicked not implemented");
}

auto SelectListIconLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x25e6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SelectListIconLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SelectListIconLayer*, int);
	static auto func = wrapFunction(base::get() + 0x25e760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SelectListIconLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SelectListIconLayer::keyBackClicked not implemented");
}

auto SelectPremadeDelegate::selectPremadeClosed(SelectPremadeLayer* p0, int p1) -> decltype(selectPremadeClosed(p0, p1)) {
	throw std::runtime_error("SelectPremadeDelegate::selectPremadeClosed not implemented");
}

auto SelectPremadeLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x31af90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto SelectPremadeLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectPremadeLayer::init), this);
	using FunctionType = decltype(init())(*)(SelectPremadeLayer*);
	static auto func = wrapFunction(base::get() + 0x31b030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectPremadeLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SelectPremadeLayer::keyBackClicked not implemented");
}

auto SelectSettingLayer::create(SelectSettingType p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(SelectSettingType, int);
	static auto func = wrapFunction(base::get() + 0x270c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SelectSettingLayer::frameForItem(SelectSettingType p0, int p1) -> decltype(frameForItem(p0, p1)) {
	using FunctionType = decltype(frameForItem(p0, p1))(*)(SelectSettingLayer*, SelectSettingType, int);
	static auto func = wrapFunction(base::get() + 0x271380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SelectSettingLayer::init(SelectSettingType p0, int p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SelectSettingLayer*, SelectSettingType, int);
	static auto func = wrapFunction(base::get() + 0x270cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SelectSettingLayer::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(SelectSettingLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2715d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectSettingLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SelectSettingLayer::keyBackClicked not implemented");
}

auto SelectSFXSortDelegate::sortSelectClosed(SelectSFXSortLayer* p0) -> decltype(sortSelectClosed(p0)) {
	throw std::runtime_error("SelectSFXSortDelegate::sortSelectClosed not implemented");
}

auto SelectSFXSortLayer::create(AudioSortType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(AudioSortType);
	static auto func = wrapFunction(base::get() + 0x37a410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SelectSFXSortLayer::init(AudioSortType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SelectSFXSortLayer*, AudioSortType);
	static auto func = wrapFunction(base::get() + 0x37a4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SelectSFXSortLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SelectSFXSortLayer::keyBackClicked not implemented");
}

auto SequenceTriggerGameObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3a9fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto SequenceTriggerGameObject::addCount(int p0, int p1) -> decltype(addCount(p0, p1)) {
	using FunctionType = decltype(addCount(p0, p1))(*)(SequenceTriggerGameObject*, int, int);
	static auto func = wrapFunction(base::get() + 0x3aae20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SequenceTriggerGameObject::addTarget(int p0, int p1) -> decltype(addTarget(p0, p1)) {
	using FunctionType = decltype(addTarget(p0, p1))(*)(SequenceTriggerGameObject*, int, int);
	static auto func = wrapFunction(base::get() + 0x3aad40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SequenceTriggerGameObject::reorderTarget(int p0, bool p1) -> decltype(reorderTarget(p0, p1)) {
	using FunctionType = decltype(reorderTarget(p0, p1))(*)(SequenceTriggerGameObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x3aada0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SequenceTriggerGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SequenceTriggerGameObject::init), this);
	using FunctionType = decltype(init())(*)(SequenceTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x3aa070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SequenceTriggerGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SequenceTriggerGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(SequenceTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x3aa080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SequenceTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&SequenceTriggerGameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(SequenceTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x3aa0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto SequenceTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&SequenceTriggerGameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SequenceTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x3aa5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SequenceTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SequenceTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SequenceTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x3aa900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetColorIDPopup::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x210540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SetColorIDPopup::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SetColorIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x2105e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetColorIDPopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	throw std::runtime_error("SetColorIDPopup::colorSelectClosed not implemented");
}

auto SetFolderPopup::create(int p0, bool p1, gd::string p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(int, bool, gd::string);
	static auto func = wrapFunction(base::get() + 0x210a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetFolderPopup::init(int p0, bool p1, gd::string p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetFolderPopup*, int, bool, gd::string);
	static auto func = wrapFunction(base::get() + 0x210b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetFolderPopup::valueChanged() -> decltype(valueChanged()) {
	throw std::runtime_error("SetFolderPopup::valueChanged not implemented");
}

auto SetFolderPopup::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	throw std::runtime_error("SetFolderPopup::setTextPopupClosed not implemented");
}

auto SetGroupIDLayer::create(GameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x310cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetGroupIDLayer::addGroupID(int p0) -> decltype(addGroupID(p0)) {
	using FunctionType = decltype(addGroupID(p0))(*)(SetGroupIDLayer*, int);
	static auto func = wrapFunction(base::get() + 0x314320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetGroupIDLayer::callRemoveFromGroup(float p0) -> decltype(callRemoveFromGroup(p0)) {
	using FunctionType = decltype(callRemoveFromGroup(p0))(*)(SetGroupIDLayer*, float);
	static auto func = wrapFunction(base::get() + 0x313ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetGroupIDLayer::createTextInput(cocos2d::CCPoint p0, int p1, int p2, gd::string p3, float p4, int p5) -> decltype(createTextInput(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(createTextInput(p0, p1, p2, p3, p4, p5))(*)(SetGroupIDLayer*, cocos2d::CCPoint, int, int, gd::string, float, int);
	static auto func = wrapFunction(base::get() + 0x312b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto SetGroupIDLayer::determineStartValues() -> decltype(determineStartValues()) {
	using FunctionType = decltype(determineStartValues())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x313130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::init(GameObject* obj, cocos2d::CCArray* objs) -> decltype(init(obj, objs)) {
	using FunctionType = decltype(init(obj, objs))(*)(SetGroupIDLayer*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x310d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, obj, objs);
}

auto SetGroupIDLayer::onAddGroup(cocos2d::CCObject* sender) -> decltype(onAddGroup(sender)) {
	using FunctionType = decltype(onAddGroup(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x313fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onAddGroupParent(cocos2d::CCObject* sender) -> decltype(onAddGroupParent(sender)) {
	using FunctionType = decltype(onAddGroupParent(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x313fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onAnim(cocos2d::CCObject* sender) -> decltype(onAnim(sender)) {
	using FunctionType = decltype(onAnim(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x313580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onArrow(int p0, int p1) -> decltype(onArrow(p0, p1)) {
	using FunctionType = decltype(onArrow(p0, p1))(*)(SetGroupIDLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x312fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetGroupIDLayer::onArrowLeft(cocos2d::CCObject* sender) -> decltype(onArrowLeft(sender)) {
	using FunctionType = decltype(onArrowLeft(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x312f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onArrowRight(cocos2d::CCObject* sender) -> decltype(onArrowRight(sender)) {
	using FunctionType = decltype(onArrowRight(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x312fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x314bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onCopy(cocos2d::CCObject* sender) -> decltype(onCopy(sender)) {
	using FunctionType = decltype(onCopy(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3134a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onExtra(cocos2d::CCObject* sender) -> decltype(onExtra(sender)) {
	using FunctionType = decltype(onExtra(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x313530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onExtra2(cocos2d::CCObject* sender) -> decltype(onExtra2(sender)) {
	using FunctionType = decltype(onExtra2(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x313560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onNextFreeEditorLayer1(cocos2d::CCObject* sender) -> decltype(onNextFreeEditorLayer1(sender)) {
	using FunctionType = decltype(onNextFreeEditorLayer1(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3142c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onNextFreeEditorLayer2(cocos2d::CCObject* sender) -> decltype(onNextFreeEditorLayer2(sender)) {
	using FunctionType = decltype(onNextFreeEditorLayer2(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3142f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onNextFreeOrderChannel(cocos2d::CCObject* sender) -> decltype(onNextFreeOrderChannel(sender)) {
	using FunctionType = decltype(onNextFreeOrderChannel(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x314910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onNextGroupID1(cocos2d::CCObject* sender) -> decltype(onNextGroupID1(sender)) {
	using FunctionType = decltype(onNextGroupID1(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3137e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onPaste(cocos2d::CCObject* sender) -> decltype(onPaste(sender)) {
	using FunctionType = decltype(onPaste(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3134c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onRemoveFromGroup(cocos2d::CCObject* sender) -> decltype(onRemoveFromGroup(sender)) {
	using FunctionType = decltype(onRemoveFromGroup(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x313f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onToggleGuide(cocos2d::CCObject* sender) -> decltype(onToggleGuide(sender)) {
	using FunctionType = decltype(onToggleGuide(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x312aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onToggleSelectedOrder(cocos2d::CCObject* sender) -> decltype(onToggleSelectedOrder(sender)) {
	using FunctionType = decltype(onToggleSelectedOrder(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x312af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onZLayer(cocos2d::CCObject* sender) -> decltype(onZLayer(sender)) {
	using FunctionType = decltype(onZLayer(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x314050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::onZLayerShift(cocos2d::CCObject* sender) -> decltype(onZLayerShift(sender)) {
	using FunctionType = decltype(onZLayerShift(sender))(*)(SetGroupIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x314150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetGroupIDLayer::removeGroupID(int p0) -> decltype(removeGroupID(p0)) {
	using FunctionType = decltype(removeGroupID(p0))(*)(SetGroupIDLayer*, int);
	static auto func = wrapFunction(base::get() + 0x314460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetGroupIDLayer::updateEditorLabel() -> decltype(updateEditorLabel()) {
	using FunctionType = decltype(updateEditorLabel())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x314610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateEditorLabel2() -> decltype(updateEditorLabel2()) {
	using FunctionType = decltype(updateEditorLabel2())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x3146a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateEditorLayerID() -> decltype(updateEditorLayerID()) {
	using FunctionType = decltype(updateEditorLayerID())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x314200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateEditorLayerID2() -> decltype(updateEditorLayerID2()) {
	using FunctionType = decltype(updateEditorLayerID2())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x314260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateEditorOrder() -> decltype(updateEditorOrder()) {
	using FunctionType = decltype(updateEditorOrder())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x314b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateEditorOrderLabel() -> decltype(updateEditorOrderLabel()) {
	using FunctionType = decltype(updateEditorOrderLabel())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x314850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateGroupIDButtons() -> decltype(updateGroupIDButtons()) {
	using FunctionType = decltype(updateGroupIDButtons())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x313810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateGroupIDLabel() -> decltype(updateGroupIDLabel()) {
	using FunctionType = decltype(updateGroupIDLabel())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x3147c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateOrderChannel() -> decltype(updateOrderChannel()) {
	using FunctionType = decltype(updateOrderChannel())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x314ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateOrderChannelLabel() -> decltype(updateOrderChannelLabel()) {
	using FunctionType = decltype(updateOrderChannelLabel())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x3148b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateZOrder() -> decltype(updateZOrder()) {
	using FunctionType = decltype(updateZOrder())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x314590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::updateZOrderLabel() -> decltype(updateZOrderLabel()) {
	using FunctionType = decltype(updateZOrderLabel())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x314730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetGroupIDLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetGroupIDLayer::keyBackClicked not implemented");
}

auto SetGroupIDLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetGroupIDLayer::textInputClosed not implemented");
}

auto SetGroupIDLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetGroupIDLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetGroupIDLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3135b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetItemIDLayer::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x317520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetItemIDLayer::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetItemIDLayer*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3175d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetItemIDLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetItemIDLayer::onClose not implemented");
}

auto SetItemIDLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetItemIDLayer::valueDidChange not implemented");
}

auto SetItemIDLayer::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetItemIDLayer::onCustomToggleTriggerValue not implemented");
}

auto SetLevelOrderPopup::create(int p0, int p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(int, int, int);
	static auto func = wrapFunction(base::get() + 0x25e270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetLevelOrderPopup::init(int p0, int p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetLevelOrderPopup*, int, int, int);
	static auto func = wrapFunction(base::get() + 0x25e320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetTargetIDLayer::create(EffectGameObject* p0, cocos2d::CCArray* p1, gd::string p2, gd::string p3, int p4, int p5, int p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(EffectGameObject*, cocos2d::CCArray*, gd::string, gd::string, int, int, int);
	static auto func = wrapFunction(base::get() + 0x317e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

auto SetTargetIDLayer::init(EffectGameObject* p0, cocos2d::CCArray* p1, gd::string p2, gd::string p3, int p4, int p5, int p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(SetTargetIDLayer*, EffectGameObject*, cocos2d::CCArray*, gd::string, gd::string, int, int, int);
	static auto func = wrapFunction(base::get() + 0x317fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto SetTargetIDLayer::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetTargetIDLayer::determineStartValues not implemented");
}

auto SetTargetIDLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetTargetIDLayer::valueDidChange not implemented");
}

auto SetupAdvFollowEditPhysicsPopup::create(AdvancedFollowEditObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(AdvancedFollowEditObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x31b580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAdvFollowEditPhysicsPopup::init(AdvancedFollowEditObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAdvFollowEditPhysicsPopup*, AdvancedFollowEditObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x31b630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupAdvFollowEditPhysicsPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAdvFollowEditPhysicsPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAdvFollowEditPhysicsPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x31bda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAdvFollowPopup::create(AdvancedFollowTriggerObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(AdvancedFollowTriggerObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3184c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAdvFollowPopup::init(AdvancedFollowTriggerObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAdvFollowPopup*, AdvancedFollowTriggerObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x318570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupAdvFollowPopup::onMode(cocos2d::CCObject* sender) -> decltype(onMode(sender)) {
	using FunctionType = decltype(onMode(sender))(*)(SetupAdvFollowPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x31aa70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupAdvFollowPopup::onPremade(cocos2d::CCObject* sender) -> decltype(onPremade(sender)) {
	using FunctionType = decltype(onPremade(sender))(*)(SetupAdvFollowPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x31ab60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupAdvFollowPopup::updateMode(int p0) -> decltype(updateMode(p0)) {
	using FunctionType = decltype(updateMode(p0))(*)(SetupAdvFollowPopup*, int);
	static auto func = wrapFunction(base::get() + 0x31aaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupAdvFollowPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupAdvFollowPopup::onClose not implemented");
}

auto SetupAdvFollowPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAdvFollowPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupAdvFollowPopup*);
	static auto func = wrapFunction(base::get() + 0x31a670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAdvFollowPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAdvFollowPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAdvFollowPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x31a760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAdvFollowPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SetupAdvFollowPopup::onCustomToggleTriggerValue), this);
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupAdvFollowPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x31a9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, sender);
}

auto SetupAdvFollowPopup::selectPremadeClosed(SelectPremadeLayer* p0, int p1) -> decltype(selectPremadeClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SelectPremadeLayer*, int>::func(&SetupAdvFollowPopup::selectPremadeClosed), this);
	using FunctionType = decltype(selectPremadeClosed(p0, p1))(*)(SetupAdvFollowPopup*, SelectPremadeLayer*, int);
	static auto func = wrapFunction(base::get() + 0x31aba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAdvFollowRetargetPopup::create(AdvancedFollowEditObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(AdvancedFollowEditObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x31bdf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAdvFollowRetargetPopup::init(AdvancedFollowEditObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAdvFollowRetargetPopup*, AdvancedFollowEditObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x31bea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupAdvFollowRetargetPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAdvFollowRetargetPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupAdvFollowRetargetPopup*);
	static auto func = wrapFunction(base::get() + 0x31a670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAdvFollowRetargetPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAdvFollowRetargetPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAdvFollowRetargetPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x31c220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAnimationPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x31c510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAnimationPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAnimationPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x31c5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupAnimationPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupAnimationPopup::determineStartValues not implemented");
}

auto SetupAnimationPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupAnimationPopup::onClose not implemented");
}

auto SetupAnimationPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupAnimationPopup::textChanged not implemented");
}

auto SetupAnimSettingsPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x31d690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAnimSettingsPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAnimSettingsPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x31d740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupAnimSettingsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupAnimSettingsPopup::onClose not implemented");
}

auto SetupAreaMoveTriggerPopup::create(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x31e580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAreaMoveTriggerPopup::init(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAreaMoveTriggerPopup*, EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x31e630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupAreaMoveTriggerPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	throw std::runtime_error("SetupAreaMoveTriggerPopup::updateInputValue not implemented");
}

auto SetupAreaMoveTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	throw std::runtime_error("SetupAreaMoveTriggerPopup::updateDefaultTriggerValues not implemented");
}

auto SetupAreaMoveTriggerPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	throw std::runtime_error("SetupAreaMoveTriggerPopup::updateInputNode not implemented");
}

auto SetupAreaMoveTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupAreaMoveTriggerPopup::valueDidChange not implemented");
}

auto SetupAreaMoveTriggerPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	throw std::runtime_error("SetupAreaMoveTriggerPopup::triggerValueFromSliderValue not implemented");
}

auto SetupAreaMoveTriggerPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	throw std::runtime_error("SetupAreaMoveTriggerPopup::triggerSliderValueFromValue not implemented");
}

auto SetupAreaTintTriggerPopup::create(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x321690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAreaTintTriggerPopup::init(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAreaTintTriggerPopup*, EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x321740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupAreaTintTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupAreaTintTriggerPopup::determineStartValues not implemented");
}

auto SetupAreaTintTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupAreaTintTriggerPopup::onClose not implemented");
}

auto SetupAreaTintTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupAreaTintTriggerPopup::valueDidChange not implemented");
}

auto SetupAreaTintTriggerPopup::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	throw std::runtime_error("SetupAreaTintTriggerPopup::hsvPopupClosed not implemented");
}

auto SetupAreaAnimTriggerPopup::create(EnterEffectObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(EnterEffectObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x322760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetupAreaAnimTriggerPopup::createValueControlAdvancedAnim(int p0, gd::string p1, cocos2d::CCPoint p2, float p3, bool p4, InputValueType p5, int p6, bool p7, float min, float max, int p10, int p11, GJInputStyle p12) -> decltype(createValueControlAdvancedAnim(p0, p1, p2, p3, p4, p5, p6, p7, min, max, p10, p11, p12)) {
	using FunctionType = decltype(createValueControlAdvancedAnim(p0, p1, p2, p3, p4, p5, p6, p7, min, max, p10, p11, p12))(*)(SetupAreaAnimTriggerPopup*, int, gd::string, cocos2d::CCPoint, float, bool, InputValueType, int, bool, float, float, int, int, GJInputStyle);
	static auto func = wrapFunction(base::get() + 0x370030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, min, max, p10, p11, p12);
}

auto SetupAreaAnimTriggerPopup::init(EnterEffectObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetupAreaAnimTriggerPopup*, EnterEffectObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x322810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetupAreaAnimTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	throw std::runtime_error("SetupAreaAnimTriggerPopup::updateDefaultTriggerValues not implemented");
}

auto SetupAreaAnimTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupAreaAnimTriggerPopup::valueDidChange not implemented");
}

auto SetupAreaFadeTriggerPopup::create(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x321140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAreaFadeTriggerPopup::init(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAreaFadeTriggerPopup*, EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3211f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupAreaRotateTriggerPopup::create(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x320c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAreaRotateTriggerPopup::init(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAreaRotateTriggerPopup*, EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x320cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupAreaTransformTriggerPopup::create(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3205e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAreaTransformTriggerPopup::init(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAreaTransformTriggerPopup*, EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x320690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupAreaTriggerPopup::create(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3222e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAreaTriggerPopup::init(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAreaTriggerPopup*, EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x322390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupArtSwitchPopup::create(ArtTriggerGameObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(ArtTriggerGameObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x36caa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetupArtSwitchPopup::init(ArtTriggerGameObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetupArtSwitchPopup*, ArtTriggerGameObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x36cbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetupArtSwitchPopup::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	throw std::runtime_error("SetupArtSwitchPopup::selectArtClosed not implemented");
}

auto SetupAudioLineGuidePopup::create(AudioLineGuideGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(AudioLineGuideGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36ba20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupAudioLineGuidePopup::init(AudioLineGuideGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupAudioLineGuidePopup*, AudioLineGuideGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36bad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupAudioLineGuidePopup::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	throw std::runtime_error("SetupAudioLineGuidePopup::selectSettingClosed not implemented");
}

auto SetupAudioTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupAudioTriggerPopup::valueDidChange not implemented");
}

auto SetupBGSpeedTrigger::create(EffectGameObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(EffectGameObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x335630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetupBGSpeedTrigger::init(EffectGameObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetupBGSpeedTrigger*, EffectGameObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x3356e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetupCameraEdgePopup::create(CameraTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(CameraTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x323e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupCameraEdgePopup::init(CameraTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupCameraEdgePopup*, CameraTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x323eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupCameraEdgePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCameraEdgePopup::determineStartValues not implemented");
}

auto SetupCameraEdgePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCameraEdgePopup::onClose not implemented");
}

auto SetupCameraEdgePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupCameraEdgePopup::textChanged not implemented");
}

auto SetupCameraGuidePopup::create(CameraTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(CameraTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36c0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupCameraGuidePopup::init(CameraTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupCameraGuidePopup*, CameraTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36c180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupCameraModePopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x324f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupCameraModePopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupCameraModePopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x324fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupCameraModePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCameraModePopup::determineStartValues not implemented");
}

auto SetupCameraModePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCameraModePopup::onClose not implemented");
}

auto SetupCameraOffsetTrigger::create(CameraTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(CameraTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x325f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupCameraOffsetTrigger::init(CameraTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupCameraOffsetTrigger*, CameraTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x326010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupCameraOffsetTrigger::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCameraOffsetTrigger::determineStartValues not implemented");
}

auto SetupCameraOffsetTrigger::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCameraOffsetTrigger::onClose not implemented");
}

auto SetupCameraOffsetTrigger::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupCameraOffsetTrigger::textChanged not implemented");
}

auto SetupCameraOffsetTrigger::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("SetupCameraOffsetTrigger::valuePopupClosed not implemented");
}

auto SetupCameraRotatePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCameraRotatePopup::determineStartValues not implemented");
}

auto SetupCameraRotatePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCameraRotatePopup::onClose not implemented");
}

auto SetupCameraRotatePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupCameraRotatePopup::textChanged not implemented");
}

auto SetupCameraRotatePopup::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("SetupCameraRotatePopup::valuePopupClosed not implemented");
}

auto SetupCameraRotatePopup2::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x328470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupCameraRotatePopup2::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupCameraRotatePopup2*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x328520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupCheckpointPopup::create(CheckpointGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(CheckpointGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x366b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupCheckpointPopup::init(CheckpointGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupCheckpointPopup*, CheckpointGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x366c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupCoinLayer::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36b340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupCoinLayer::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupCoinLayer*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36b3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupInstantCollisionTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32a2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupInstantCollisionTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupInstantCollisionTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32a350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupInstantCollisionTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	throw std::runtime_error("SetupInstantCollisionTriggerPopup::updateDefaultTriggerValues not implemented");
}

auto SetupInstantCollisionTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupInstantCollisionTriggerPopup::valueDidChange not implemented");
}

auto SetupCollisionStateTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32a940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupCollisionStateTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupCollisionStateTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32a9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupCollisionTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x328a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupCollisionTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupCollisionTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x328b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupCollisionTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCollisionTriggerPopup::determineStartValues not implemented");
}

auto SetupCollisionTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCollisionTriggerPopup::onClose not implemented");
}

auto SetupCollisionTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupCollisionTriggerPopup::textChanged not implemented");
}

auto SetupCountTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32ad80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupCountTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupCountTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32ae30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupCountTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupCountTriggerPopup::determineStartValues not implemented");
}

auto SetupCountTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupCountTriggerPopup::onClose not implemented");
}

auto SetupCountTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupCountTriggerPopup::textChanged not implemented");
}

auto SetupDashRingPopup::create(DashRingObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(DashRingObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36da50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupDashRingPopup::init(DashRingObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupDashRingPopup*, DashRingObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36db00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupEndPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32c300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupEndPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupEndPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32c3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupEndPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupEndPopup::determineStartValues not implemented");
}

auto SetupEndPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupEndPopup::onClose not implemented");
}

auto SetupEndPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetupEndPopup::textInputClosed not implemented");
}

auto SetupEndPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupEndPopup::textChanged not implemented");
}

auto SetupEnterEffectPopup::create(EnterEffectObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(EnterEffectObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x32d400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetupEnterEffectPopup::init(EnterEffectObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetupEnterEffectPopup*, EnterEffectObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x32d4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetupEnterEffectPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupEnterEffectPopup::determineStartValues not implemented");
}

auto SetupEnterEffectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupEnterEffectPopup::onClose not implemented");
}

auto SetupEnterEffectPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	throw std::runtime_error("SetupEnterEffectPopup::updateInputValue not implemented");
}

auto SetupEnterEffectPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	throw std::runtime_error("SetupEnterEffectPopup::updateInputNode not implemented");
}

auto SetupEnterEffectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupEnterEffectPopup::valueDidChange not implemented");
}

auto SetupEnterEffectPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	throw std::runtime_error("SetupEnterEffectPopup::triggerValueFromSliderValue not implemented");
}

auto SetupEnterEffectPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	throw std::runtime_error("SetupEnterEffectPopup::triggerSliderValueFromValue not implemented");
}

auto SetupEnterEffectPopup::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	throw std::runtime_error("SetupEnterEffectPopup::hsvPopupClosed not implemented");
}

auto SetupEnterTriggerPopup::create(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x205930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupEnterTriggerPopup::init(EnterEffectObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupEnterTriggerPopup*, EnterEffectObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2059e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupEnterTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupEnterTriggerPopup::determineStartValues not implemented");
}

auto SetupEventLinkPopup::create(EventLinkTrigger* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EventLinkTrigger*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3647c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupEventLinkPopup::init(EventLinkTrigger* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupEventLinkPopup*, EventLinkTrigger*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x364870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupForceBlockPopup::create(ForceBlockGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(ForceBlockGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36c4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupForceBlockPopup::init(ForceBlockGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupForceBlockPopup*, ForceBlockGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36c580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupForceBlockPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupForceBlockPopup::valueDidChange not implemented");
}

auto SetupGameplayOffsetPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x34a410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupGameplayOffsetPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupGameplayOffsetPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x34a4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupGameplayOffsetPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	throw std::runtime_error("SetupGameplayOffsetPopup::updateInputValue not implemented");
}

auto SetupGameplayOffsetPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	throw std::runtime_error("SetupGameplayOffsetPopup::updateInputNode not implemented");
}

auto SetupGameplayOffsetPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	throw std::runtime_error("SetupGameplayOffsetPopup::triggerValueFromSliderValue not implemented");
}

auto SetupGameplayOffsetPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	throw std::runtime_error("SetupGameplayOffsetPopup::triggerSliderValueFromValue not implemented");
}

auto SetupGameplayOffsetPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupGameplayOffsetPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupGradientPopup::create(GradientTriggerObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GradientTriggerObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32f140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupGradientPopup::init(GradientTriggerObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupGradientPopup*, GradientTriggerObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32f1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupGradientPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupGradientPopup::determineStartValues not implemented");
}

auto SetupGradientPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	throw std::runtime_error("SetupGradientPopup::onPlusButton not implemented");
}

auto SetupGradientPopup::updateToggleItem(int p0, bool p1) -> decltype(updateToggleItem(p0, p1)) {
	throw std::runtime_error("SetupGradientPopup::updateToggleItem not implemented");
}

auto SetupGradientPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupGradientPopup::valueDidChange not implemented");
}

auto SetupGravityModPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetupGravityModPopup::keyBackClicked not implemented");
}

auto SetupGravityModPopup::show() -> decltype(show()) {
	throw std::runtime_error("SetupGravityModPopup::show not implemented");
}

auto SetupGravityModPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetupGravityModPopup::textInputClosed not implemented");
}

auto SetupGravityModPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupGravityModPopup::textChanged not implemented");
}

auto SetupGravityTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x335b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupGravityTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupGravityTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x335bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupGravityTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupGravityTriggerPopup::valueDidChange not implemented");
}

auto SetupInstantCountPopup::create(CountTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(CountTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x330620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupInstantCountPopup::init(CountTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupInstantCountPopup*, CountTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3306d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupInstantCountPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupInstantCountPopup::determineStartValues not implemented");
}

auto SetupInstantCountPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupInstantCountPopup::onClose not implemented");
}

auto SetupInstantCountPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupInstantCountPopup::textChanged not implemented");
}

auto SetupInteractObjectPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3317b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupInteractObjectPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupInteractObjectPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x331860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupInteractObjectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupInteractObjectPopup::onClose not implemented");
}

auto SetupInteractObjectPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	throw std::runtime_error("SetupInteractObjectPopup::onPlusButton not implemented");
}

auto SetupInteractObjectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupInteractObjectPopup::valueDidChange not implemented");
}

auto SetupItemCompareTriggerPopup::create(ItemTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(ItemTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x369a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupItemCompareTriggerPopup::init(ItemTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupItemCompareTriggerPopup*, ItemTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x369b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupItemCompareTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupItemCompareTriggerPopup::valueDidChange not implemented");
}

auto SetupItemCompareTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupItemCompareTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupItemEditTriggerPopup::create(ItemTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(ItemTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x367c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupItemEditTriggerPopup::init(ItemTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupItemEditTriggerPopup*, ItemTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x367d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupItemEditTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupItemEditTriggerPopup::valueDidChange not implemented");
}

auto SetupItemEditTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupItemEditTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupKeyframeAnimPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x332110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupKeyframeAnimPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupKeyframeAnimPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3321c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupKeyframePopup::create(KeyframeGameObject* p0, cocos2d::CCArray* p1, LevelEditorLayer* p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(KeyframeGameObject*, cocos2d::CCArray*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x332830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetupKeyframePopup::init(KeyframeGameObject* p0, cocos2d::CCArray* p1, LevelEditorLayer* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetupKeyframePopup*, KeyframeGameObject*, cocos2d::CCArray*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x3328e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetupKeyframePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupKeyframePopup::onClose not implemented");
}

auto SetupKeyframePopup::onCustomButton(cocos2d::CCObject* sender) -> decltype(onCustomButton(sender)) {
	throw std::runtime_error("SetupKeyframePopup::onCustomButton not implemented");
}

auto SetupKeyframePopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupKeyframePopup::valueDidChange not implemented");
}

auto SetupKeyframePopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupKeyframePopup::onCustomToggleTriggerValue not implemented");
}

auto SetupMGTrigger::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x333f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupMGTrigger::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupMGTrigger*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x333fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupMGTrigger::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupMGTrigger::determineStartValues not implemented");
}

auto SetupMGTrigger::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupMGTrigger::onClose not implemented");
}

auto SetupMGTrigger::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupMGTrigger::textChanged not implemented");
}

auto SetupMGTrigger::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("SetupMGTrigger::valuePopupClosed not implemented");
}

auto SetupMoveCommandPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1f9810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupMoveCommandPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupMoveCommandPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1f98c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupMoveCommandPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	throw std::runtime_error("SetupMoveCommandPopup::updateInputValue not implemented");
}

auto SetupMoveCommandPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	throw std::runtime_error("SetupMoveCommandPopup::updateInputNode not implemented");
}

auto SetupMoveCommandPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupMoveCommandPopup::valueDidChange not implemented");
}

auto SetupMoveCommandPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	throw std::runtime_error("SetupMoveCommandPopup::triggerValueFromSliderValue not implemented");
}

auto SetupMoveCommandPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	throw std::runtime_error("SetupMoveCommandPopup::triggerSliderValueFromValue not implemented");
}

auto SetupMoveCommandPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupMoveCommandPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupObjectControlPopup::create(ObjectControlGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(ObjectControlGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36d7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupObjectControlPopup::init(ObjectControlGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupObjectControlPopup*, ObjectControlGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36d860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupObjectOptions2Popup::create(GameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x316fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupObjectOptions2Popup::init(GameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupObjectOptions2Popup*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x317090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupObjectOptions2Popup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	throw std::runtime_error("SetupObjectOptions2Popup::onPlusButton not implemented");
}

auto SetupObjectOptionsPopup::create(GameObject* p0, cocos2d::CCArray* p1, SetGroupIDLayer* p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(GameObject*, cocos2d::CCArray*, SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x314f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetupObjectOptionsPopup::init(GameObject* p0, cocos2d::CCArray* p1, SetGroupIDLayer* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetupObjectOptionsPopup*, GameObject*, cocos2d::CCArray*, SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x314fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetupObjectOptionsPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetupObjectOptionsPopup::keyBackClicked not implemented");
}

auto SetupObjectOptionsPopup::show() -> decltype(show()) {
	throw std::runtime_error("SetupObjectOptionsPopup::show not implemented");
}

auto SetupObjectOptionsPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupObjectOptionsPopup::determineStartValues not implemented");
}

auto SetupObjectOptionsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupObjectOptionsPopup::onClose not implemented");
}

auto SetupObjectTogglePopup::create(EffectGameObject* p0, cocos2d::CCArray* p1, bool p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(EffectGameObject*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x336040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetupObjectTogglePopup::init(EffectGameObject* p0, cocos2d::CCArray* p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetupObjectTogglePopup*, EffectGameObject*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x3360f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetupObjectTogglePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupObjectTogglePopup::onClose not implemented");
}

auto SetupObjectTogglePopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupObjectTogglePopup::valueDidChange not implemented");
}

auto SetupOpacityPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x336840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupOpacityPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupOpacityPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3368f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupOpacityPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupOpacityPopup::determineStartValues not implemented");
}

auto SetupOpacityPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupOpacityPopup::onClose not implemented");
}

auto SetupOpacityPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetupOpacityPopup::textInputClosed not implemented");
}

auto SetupOpacityPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupOpacityPopup::textChanged not implemented");
}

auto SetupOptionsTriggerPopup::create(GameOptionsTrigger* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GameOptionsTrigger*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x340390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupOptionsTriggerPopup::init(GameOptionsTrigger* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupOptionsTriggerPopup*, GameOptionsTrigger*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x340440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupOptionsTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupOptionsTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupPersistentItemTriggerPopup::create(ItemTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(ItemTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36b630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupPersistentItemTriggerPopup::init(ItemTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupPersistentItemTriggerPopup*, ItemTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36b6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupPickupTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x340b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupPickupTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupPickupTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x340c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupPickupTriggerPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	throw std::runtime_error("SetupPickupTriggerPopup::onPlusButton not implemented");
}

auto SetupPickupTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupPickupTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupPlatformerEndPopup::create(EndTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EndTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32ce80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupPlatformerEndPopup::init(EndTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupPlatformerEndPopup*, EndTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x32cf40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupPlayerControlPopup::create(PlayerControlGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(PlayerControlGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x366020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupPlayerControlPopup::init(PlayerControlGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupPlayerControlPopup*, PlayerControlGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3660d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupPortalPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetupPortalPopup::keyBackClicked not implemented");
}

auto SetupPulsePopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x341420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupPulsePopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupPulsePopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3414d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupPulsePopup::show() -> decltype(show()) {
	throw std::runtime_error("SetupPulsePopup::show not implemented");
}

auto SetupPulsePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupPulsePopup::determineStartValues not implemented");
}

auto SetupPulsePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupPulsePopup::onClose not implemented");
}

auto SetupPulsePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupPulsePopup::textChanged not implemented");
}

auto SetupPulsePopup::colorValueChanged(cocos2d::ccColor3B p0) -> decltype(colorValueChanged(p0)) {
	throw std::runtime_error("SetupPulsePopup::colorValueChanged not implemented");
}

auto SetupPulsePopup::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("SetupPulsePopup::textInputOpened not implemented");
}

auto SetupPulsePopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	throw std::runtime_error("SetupPulsePopup::colorSelectClosed not implemented");
}

auto SetupRandAdvTriggerPopup::create(RandTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(RandTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x346250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupRandAdvTriggerPopup::addChance(int p0, int p1) -> decltype(addChance(p0, p1)) {
	using FunctionType = decltype(addChance(p0, p1))(*)(SetupRandAdvTriggerPopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x346ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupRandAdvTriggerPopup::addChanceToObject(RandTriggerGameObject* p0, int p1, int p2) -> decltype(addChanceToObject(p0, p1, p2)) {
	using FunctionType = decltype(addChanceToObject(p0, p1, p2))(*)(SetupRandAdvTriggerPopup*, RandTriggerGameObject*, int, int);
	static auto func = wrapFunction(base::get() + 0x346d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetupRandAdvTriggerPopup::init(RandTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupRandAdvTriggerPopup*, RandTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x346300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupRandAdvTriggerPopup::onAddChance(cocos2d::CCObject* sender) -> decltype(onAddChance(sender)) {
	using FunctionType = decltype(onAddChance(sender))(*)(SetupRandAdvTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x347ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupRandAdvTriggerPopup::onRemoveFromGroup(cocos2d::CCObject* sender) -> decltype(onRemoveFromGroup(sender)) {
	using FunctionType = decltype(onRemoveFromGroup(sender))(*)(SetupRandAdvTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x347a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupRandAdvTriggerPopup::removeGroupID(int p0) -> decltype(removeGroupID(p0)) {
	using FunctionType = decltype(removeGroupID(p0))(*)(SetupRandAdvTriggerPopup*, int);
	static auto func = wrapFunction(base::get() + 0x346de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupRandAdvTriggerPopup::removeGroupIDFromObject(RandTriggerGameObject* p0, int p1) -> decltype(removeGroupIDFromObject(p0, p1)) {
	using FunctionType = decltype(removeGroupIDFromObject(p0, p1))(*)(SetupRandAdvTriggerPopup*, RandTriggerGameObject*, int);
	static auto func = wrapFunction(base::get() + 0x346ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupRandAdvTriggerPopup::updateGroupIDButtons() -> decltype(updateGroupIDButtons()) {
	using FunctionType = decltype(updateGroupIDButtons())(*)(SetupRandAdvTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x346f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupRandAdvTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupRandAdvTriggerPopup::onClose not implemented");
}

auto SetupRandAdvTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupRandAdvTriggerPopup::textChanged not implemented");
}

auto SetupRandTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x348530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupRandTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupRandTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3485e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupRandTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupRandTriggerPopup::determineStartValues not implemented");
}

auto SetupRandTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupRandTriggerPopup::onClose not implemented");
}

auto SetupRandTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupRandTriggerPopup::textChanged not implemented");
}

auto SetupResetTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x367a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupResetTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupResetTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x367ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupReverbPopup::create(SFXTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(SFXTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x34d9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupReverbPopup::init(SFXTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupReverbPopup*, SFXTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x34daa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupReverbPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupReverbPopup::onClose not implemented");
}

auto SetupRotateCommandPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2188f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupRotateCommandPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupRotateCommandPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2189a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupRotateCommandPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	throw std::runtime_error("SetupRotateCommandPopup::updateInputNode not implemented");
}

auto SetupRotateCommandPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupRotateCommandPopup::valueDidChange not implemented");
}

auto SetupRotateCommandPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	throw std::runtime_error("SetupRotateCommandPopup::triggerValueFromSliderValue not implemented");
}

auto SetupRotateCommandPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	throw std::runtime_error("SetupRotateCommandPopup::triggerSliderValueFromValue not implemented");
}

auto SetupRotateCommandPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupRotateCommandPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupRotateGameplayPopup::create(RotateGameplayGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(RotateGameplayGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x349c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupRotateGameplayPopup::init(RotateGameplayGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupRotateGameplayPopup*, RotateGameplayGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x349cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupRotateGameplayPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	throw std::runtime_error("SetupRotateGameplayPopup::onPlusButton not implemented");
}

auto SetupRotateGameplayPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupRotateGameplayPopup::valueDidChange not implemented");
}

auto SetupRotatePopup::create(EnhancedGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EnhancedGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x34ac20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupRotatePopup::init(EnhancedGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupRotatePopup*, EnhancedGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x34acd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupRotatePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupRotatePopup::onClose not implemented");
}

auto SetupRotatePopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupRotatePopup::onCustomToggleTriggerValue not implemented");
}

auto SetupSequenceTriggerPopup::create(SequenceTriggerGameObject* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(SequenceTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x34b450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SetupSequenceTriggerPopup::init(SequenceTriggerGameObject* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SetupSequenceTriggerPopup*, SequenceTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x34b4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupSequenceTriggerPopup::onAddChance(cocos2d::CCObject* sender) -> decltype(onAddChance(sender)) {
	using FunctionType = decltype(onAddChance(sender))(*)(SetupSequenceTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34c5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupSequenceTriggerPopup::onChangeOrder(cocos2d::CCObject* sender) -> decltype(onChangeOrder(sender)) {
	using FunctionType = decltype(onChangeOrder(sender))(*)(SetupSequenceTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34c670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupSequenceTriggerPopup::onDeleteSelected(cocos2d::CCObject* sender) -> decltype(onDeleteSelected(sender)) {
	using FunctionType = decltype(onDeleteSelected(sender))(*)(SetupSequenceTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34c6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupSequenceTriggerPopup::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(SetupSequenceTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34c570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupSequenceTriggerPopup::updateGroupIDButtons() -> decltype(updateGroupIDButtons()) {
	using FunctionType = decltype(updateGroupIDButtons())(*)(SetupSequenceTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x34c110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetupSequenceTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupSequenceTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupSFXEditPopup::create(SFXTriggerGameObject* p0, cocos2d::CCArray* p1, bool p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(SFXTriggerGameObject*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x34f530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetupSFXEditPopup::init(SFXTriggerGameObject* p0, cocos2d::CCArray* p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetupSFXEditPopup*, SFXTriggerGameObject*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x34f5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SFXBrowserDelegate::sfxBrowserClosed(SFXBrowser* p0) -> decltype(sfxBrowserClosed(p0)) {
	throw std::runtime_error("SFXBrowserDelegate::sfxBrowserClosed not implemented");
}

auto SetupSFXPopup::create(SFXTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(SFXTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x34e1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupSFXPopup::init(SFXTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupSFXPopup*, SFXTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x34e260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupSFXPopup::pageChanged() -> decltype(pageChanged()) {
	throw std::runtime_error("SetupSFXPopup::pageChanged not implemented");
}

auto SetupSFXPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupSFXPopup::onClose not implemented");
}

auto SetupSFXPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	throw std::runtime_error("SetupSFXPopup::onPlusButton not implemented");
}

auto SetupSFXPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupSFXPopup::valueDidChange not implemented");
}

auto SetupSFXPopup::sfxObjectSelected(SFXInfoObject* p0) -> decltype(sfxObjectSelected(p0)) {
	throw std::runtime_error("SetupSFXPopup::sfxObjectSelected not implemented");
}

auto SetupSFXPopup::getActiveSFXID() -> decltype(getActiveSFXID()) {
	throw std::runtime_error("SetupSFXPopup::getActiveSFXID not implemented");
}

auto SetupSFXPopup::overridePlaySFX(SFXInfoObject* p0) -> decltype(overridePlaySFX(p0)) {
	throw std::runtime_error("SetupSFXPopup::overridePlaySFX not implemented");
}

auto SetupSFXPopup::sfxBrowserClosed(SFXBrowser* p0) -> decltype(sfxBrowserClosed(p0)) {
	throw std::runtime_error("SetupSFXPopup::sfxBrowserClosed not implemented");
}

auto SetupShaderEffectPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(EffectGameObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x34fe80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetupShaderEffectPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetupShaderEffectPopup*, EffectGameObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x34ff30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetupShaderEffectPopup::toggleGroup(int p0, bool p1) -> decltype(toggleGroup(p0, p1)) {
	throw std::runtime_error("SetupShaderEffectPopup::toggleGroup not implemented");
}

auto SetupShaderEffectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupShaderEffectPopup::onClose not implemented");
}

auto SetupShaderEffectPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	throw std::runtime_error("SetupShaderEffectPopup::updateDefaultTriggerValues not implemented");
}

auto SetupShaderEffectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupShaderEffectPopup::valueDidChange not implemented");
}

auto SetupShakePopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x357530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupShakePopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupShakePopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3575e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupShakePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupShakePopup::determineStartValues not implemented");
}

auto SetupShakePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupShakePopup::onClose not implemented");
}

auto SetupShakePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupShakePopup::textChanged not implemented");
}

auto SetupSmartBlockLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetupSmartBlockLayer::keyBackClicked not implemented");
}

auto SetupSmartBlockLayer::show() -> decltype(show()) {
	throw std::runtime_error("SetupSmartBlockLayer::show not implemented");
}

auto SetupSmartBlockLayer::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	throw std::runtime_error("SetupSmartBlockLayer::selectArtClosed not implemented");
}

auto SetupSmartTemplateLayer::create(GJSmartTemplate* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0x35a240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SetupSmartTemplateLayer::init(GJSmartTemplate* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SetupSmartTemplateLayer*, GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0x35a2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupSmartTemplateLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SetupSmartTemplateLayer::keyBackClicked not implemented");
}

auto SetupSmartTemplateLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("SetupSmartTemplateLayer::FLAlert_Clicked not implemented");
}

auto SetupSmartTemplateLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("SetupSmartTemplateLayer::textInputOpened not implemented");
}

auto SetupSmartTemplateLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	throw std::runtime_error("SetupSmartTemplateLayer::textInputClosed not implemented");
}

auto SetupSmartTemplateLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupSmartTemplateLayer::textChanged not implemented");
}

auto SongPlaybackDelegate::onPlayback(SongInfoObject* p0) -> decltype(onPlayback(p0)) {
	throw std::runtime_error("SongPlaybackDelegate::onPlayback not implemented");
}

auto SetupSongTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x35d280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupSongTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupSongTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x35d330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupSongTriggerPopup::pageChanged() -> decltype(pageChanged()) {
	throw std::runtime_error("SetupSongTriggerPopup::pageChanged not implemented");
}

auto SetupSongTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupSongTriggerPopup::onClose not implemented");
}

auto SetupSongTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupSongTriggerPopup::valueDidChange not implemented");
}

auto SetupSongTriggerPopup::onPlayback(SongInfoObject* p0) -> decltype(onPlayback(p0)) {
	throw std::runtime_error("SetupSongTriggerPopup::onPlayback not implemented");
}

auto SetupSpawnParticlePopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x366430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupSpawnParticlePopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupSpawnParticlePopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3664e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupSpawnPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x35e2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupSpawnPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupSpawnPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x35e380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupSpawnPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupSpawnPopup::onClose not implemented");
}

auto SetupStaticCameraPopup::create(CameraTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(CameraTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x35f710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupStaticCameraPopup::init(CameraTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupStaticCameraPopup*, CameraTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x35f7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupStaticCameraPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupStaticCameraPopup::valueDidChange not implemented");
}

auto SetupStaticCameraPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupStaticCameraPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupStopTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36d0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupStopTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupStopTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x36d170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupStopTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupStopTriggerPopup::onClose not implemented");
}

auto SetupStopTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupStopTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupTeleportPopup::create(TeleportPortalObject* p0, cocos2d::CCArray* p1, int p2, bool p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(TeleportPortalObject*, cocos2d::CCArray*, int, bool);
	static auto func = wrapFunction(base::get() + 0x35ff80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto SetupTeleportPopup::init(TeleportPortalObject* p0, cocos2d::CCArray* p1, int p2, bool p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(SetupTeleportPopup*, TeleportPortalObject*, cocos2d::CCArray*, int, bool);
	static auto func = wrapFunction(base::get() + 0x360030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto SetupTeleportPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupTeleportPopup::determineStartValues not implemented");
}

auto SetupTeleportPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	throw std::runtime_error("SetupTeleportPopup::updateDefaultTriggerValues not implemented");
}

auto SetupTeleportPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("SetupTeleportPopup::valueDidChange not implemented");
}

auto SetupTimerControlTriggerPopup::create(TimerTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(TimerTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3617b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupTimerControlTriggerPopup::init(TimerTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupTimerControlTriggerPopup*, TimerTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x361860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTimerControlTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("SetupTimerControlTriggerPopup::onCustomToggleTriggerValue not implemented");
}

auto SetupTimerEventTriggerPopup::create(TimerTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(TimerTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x361400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupTimerEventTriggerPopup::init(TimerTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupTimerEventTriggerPopup*, TimerTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3614b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTimerTriggerPopup::create(TimerTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(TimerTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x360e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupTimerTriggerPopup::init(TimerTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupTimerTriggerPopup*, TimerTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x360f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTimeWarpPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x361c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupTimeWarpPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupTimeWarpPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x361d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTimeWarpPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupTimeWarpPopup::determineStartValues not implemented");
}

auto SetupTimeWarpPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupTimeWarpPopup::onClose not implemented");
}

auto SetupTouchTogglePopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x362500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupTouchTogglePopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupTouchTogglePopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3625a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupTouchTogglePopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupTouchTogglePopup::determineStartValues not implemented");
}

auto SetupTouchTogglePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupTouchTogglePopup::onClose not implemented");
}

auto SetupTouchTogglePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	throw std::runtime_error("SetupTouchTogglePopup::textChanged not implemented");
}

auto SetupTransformPopup::create(TransformTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(TransformTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3635c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupTransformPopup::init(TransformTriggerGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupTransformPopup*, TransformTriggerGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x363670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupZoomTriggerPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x377a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupZoomTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupZoomTriggerPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x377b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupZoomTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	throw std::runtime_error("SetupZoomTriggerPopup::determineStartValues not implemented");
}

auto SetupZoomTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("SetupZoomTriggerPopup::onClose not implemented");
}

auto SFXBrowser::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x378110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SFXBrowser::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SFXBrowser*, int);
	static auto func = wrapFunction(base::get() + 0x3781b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SFXBrowser::setupList(SFXSearchResult* p0) -> decltype(setupList(p0)) {
	using FunctionType = decltype(setupList(p0))(*)(SFXBrowser*, SFXSearchResult*);
	static auto func = wrapFunction(base::get() + 0x379250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SFXBrowser::trySetupSFXBrowser() -> decltype(trySetupSFXBrowser()) {
	using FunctionType = decltype(trySetupSFXBrowser())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x379010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SFXBrowser::updatePageLabel() -> decltype(updatePageLabel()) {
	using FunctionType = decltype(updatePageLabel())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x379ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SFXBrowser::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("SFXBrowser::registerWithTouchDispatcher not implemented");
}

auto SFXBrowser::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SFXBrowser::keyBackClicked not implemented");
}

auto SFXBrowser::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	throw std::runtime_error("SFXBrowser::musicActionFinished not implemented");
}

auto SFXBrowser::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	throw std::runtime_error("SFXBrowser::musicActionFailed not implemented");
}

auto SFXBrowser::sortSelectClosed(SelectSFXSortLayer* p0) -> decltype(sortSelectClosed(p0)) {
	throw std::runtime_error("SFXBrowser::sortSelectClosed not implemented");
}

auto SFXBrowser::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	throw std::runtime_error("SFXBrowser::setTextPopupClosed not implemented");
}

auto SFXBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("SFXBrowser::cellPerformedAction not implemented");
}

auto SFXBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	throw std::runtime_error("SFXBrowser::getSelectedCellIdx not implemented");
}

auto SFXBrowser::shouldSnapToSelected() -> decltype(shouldSnapToSelected()) {
	throw std::runtime_error("SFXBrowser::shouldSnapToSelected not implemented");
}

auto SFXInfoObject::create(int p0, gd::string p1, int p2, int p3, int p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(int, gd::string, int, int, int);
	static auto func = wrapFunction(base::get() + 0x2891d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto SFXFolderObject::create(int p0, gd::string p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(int, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x2893e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SFXFolderObject::init(int p0, gd::string p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SFXFolderObject*, int, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x2894b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SFXSearchResult::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x289f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SFXSearchResult::getSelectedPage(int p0, int p1) -> decltype(getSelectedPage(p0, p1)) {
	using FunctionType = decltype(getSelectedPage(p0, p1))(*)(SFXSearchResult*, int, int);
	static auto func = wrapFunction(base::get() + 0x28a500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SFXSearchResult::updateObjects(AudioSortType p0) -> decltype(updateObjects(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AudioSortType>::func(&SFXSearchResult::updateObjects), this);
	using FunctionType = decltype(updateObjects(p0))(*)(SFXSearchResult*, AudioSortType);
	static auto func = wrapFunction(base::get() + 0x289ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SFXTriggerGameObject::customObjectSetup not implemented");
}

auto SFXTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SFXTriggerGameObject::getSaveString not implemented");
}

auto ShaderGameObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x391eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto ShaderGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShaderGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(ShaderGameObject*);
	static auto func = wrapFunction(base::get() + 0x391f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShaderGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("ShaderGameObject::customObjectSetup not implemented");
}

auto ShaderGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("ShaderGameObject::getSaveString not implemented");
}

auto ShaderLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x37b720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ShaderLayer::performCalculations() -> decltype(performCalculations()) {
	using FunctionType = decltype(performCalculations())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3836c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("ShaderLayer::update not implemented");
}

auto ShaderLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShaderLayer::init), this);
	using FunctionType = decltype(init())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x37b7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShaderLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShaderLayer::visit), this);
	using FunctionType = decltype(visit())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x383810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShardsPage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x384280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ShardsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShardsPage::init), this);
	using FunctionType = decltype(init())(*)(ShardsPage*);
	static auto func = wrapFunction(base::get() + 0x384320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShardsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("ShardsPage::registerWithTouchDispatcher not implemented");
}

auto ShardsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ShardsPage::keyBackClicked not implemented");
}

auto ShardsPage::show() -> decltype(show()) {
	throw std::runtime_error("ShardsPage::show not implemented");
}

auto ShareCommentLayer::create(gd::string p0, int p1, CommentType p2, int p3, gd::string p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(gd::string, int, CommentType, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x386370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto ShareCommentLayer::init(gd::string p0, int p1, CommentType p2, int p3, gd::string p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(ShareCommentLayer*, gd::string, int, CommentType, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x386490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto ShareCommentLayer::onClear(cocos2d::CCObject* sender) -> decltype(onClear(sender)) {
	using FunctionType = decltype(onClear(sender))(*)(ShareCommentLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x387320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareCommentLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ShareCommentLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x387750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareCommentLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(ShareCommentLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3874c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareCommentLayer::updateCharCountLabel() -> decltype(updateCharCountLabel()) {
	using FunctionType = decltype(updateCharCountLabel())(*)(ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x3879e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShareCommentLayer::updatePercentLabel() -> decltype(updatePercentLabel()) {
	using FunctionType = decltype(updatePercentLabel())(*)(ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x387410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShareCommentLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("ShareCommentLayer::registerWithTouchDispatcher not implemented");
}

auto ShareCommentLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareCommentLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x387780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShareCommentLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	throw std::runtime_error("ShareCommentLayer::textInputOpened not implemented");
}

auto ShareCommentLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ShareCommentLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(ShareCommentLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3877c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShareCommentLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ShareCommentLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(ShareCommentLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3878e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShareCommentLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ShareCommentLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(ShareCommentLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x387aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ShareCommentLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ShareCommentLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(ShareCommentLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x387ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ShareCommentLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&ShareCommentLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(ShareCommentLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x387b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShareLevelLayer::create(GJGameLevel* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x387e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto ShareLevelLayer::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(ShareLevelLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x387f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ShareLevelLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(ShareLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x388f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ShareLevelLayer::keyBackClicked not implemented");
}

auto ShareLevelSettingsLayer::create(GJGameLevel* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x389a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto ShareLevelSettingsLayer::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(ShareLevelSettingsLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x389b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ShareLevelSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ShareLevelSettingsLayer::keyBackClicked not implemented");
}

auto ShareLevelSettingsLayer::numberInputClosed(NumberInputLayer* p0) -> decltype(numberInputClosed(p0)) {
	throw std::runtime_error("ShareLevelSettingsLayer::numberInputClosed not implemented");
}

auto ShareListLayer::create(GJLevelList* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x25ee50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto ShareListLayer::init(GJLevelList* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(ShareListLayer*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x25ef00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ShareListLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ShareListLayer::keyBackClicked not implemented");
}

auto SimplePlayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x1f3e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SimplePlayer::createRobotSprite(int p0) -> decltype(createRobotSprite(p0)) {
	using FunctionType = decltype(createRobotSprite(p0))(*)(SimplePlayer*, int);
	static auto func = wrapFunction(base::get() + 0x1f45d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SimplePlayer::createSpiderSprite(int p0) -> decltype(createSpiderSprite(p0)) {
	using FunctionType = decltype(createSpiderSprite(p0))(*)(SimplePlayer*, int);
	static auto func = wrapFunction(base::get() + 0x1f4620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SimplePlayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SimplePlayer*, int);
	static auto func = wrapFunction(base::get() + 0x1f3f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SimplePlayer::setFrames(char const* p0, char const* p1, char const* p2, char const* p3, char const* p4) -> decltype(setFrames(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(setFrames(p0, p1, p2, p3, p4))(*)(SimplePlayer*, char const*, char const*, char const*, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x1f4dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto SimplePlayer::updateColors() -> decltype(updateColors()) {
	using FunctionType = decltype(updateColors())(*)(SimplePlayer*);
	static auto func = wrapFunction(base::get() + 0x1f46d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SimplePlayer::updatePlayerFrame(int p0, IconType p1) -> decltype(updatePlayerFrame(p0, p1)) {
	using FunctionType = decltype(updatePlayerFrame(p0, p1))(*)(SimplePlayer*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x1f49c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SimplePlayer::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&SimplePlayer::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(SimplePlayer*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1f4f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SimplePlayer::setColor(cocos2d::ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccColor3B const&>::func(&SimplePlayer::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(SimplePlayer*, cocos2d::ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1f46a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SlideInLayer::init() -> decltype(init()) {
	throw std::runtime_error("SlideInLayer::init not implemented");
}

auto SlideInLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("SlideInLayer::draw not implemented");
}

auto SlideInLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("SlideInLayer::ccTouchBegan not implemented");
}

auto SlideInLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("SlideInLayer::ccTouchMoved not implemented");
}

auto SlideInLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("SlideInLayer::ccTouchEnded not implemented");
}

auto SlideInLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("SlideInLayer::ccTouchCancelled not implemented");
}

auto SlideInLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("SlideInLayer::registerWithTouchDispatcher not implemented");
}

auto SlideInLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SlideInLayer::keyBackClicked not implemented");
}

auto SlideInLayer::customSetup() -> decltype(customSetup()) {
	throw std::runtime_error("SlideInLayer::customSetup not implemented");
}

auto SlideInLayer::enterLayer() -> decltype(enterLayer()) {
	throw std::runtime_error("SlideInLayer::enterLayer not implemented");
}

auto SlideInLayer::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	throw std::runtime_error("SlideInLayer::exitLayer not implemented");
}

auto SlideInLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	throw std::runtime_error("SlideInLayer::showLayer not implemented");
}

auto SlideInLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	throw std::runtime_error("SlideInLayer::hideLayer not implemented");
}

auto SlideInLayer::layerVisible() -> decltype(layerVisible()) {
	throw std::runtime_error("SlideInLayer::layerVisible not implemented");
}

auto SlideInLayer::layerHidden() -> decltype(layerHidden()) {
	throw std::runtime_error("SlideInLayer::layerHidden not implemented");
}

auto SlideInLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	throw std::runtime_error("SlideInLayer::enterAnimFinished not implemented");
}

auto SlideInLayer::disableUI() -> decltype(disableUI()) {
	throw std::runtime_error("SlideInLayer::disableUI not implemented");
}

auto SlideInLayer::enableUI() -> decltype(enableUI()) {
	throw std::runtime_error("SlideInLayer::enableUI not implemented");
}

auto Slider::create(cocos2d::CCNode* p0, cocos2d::SEL_MenuHandler p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x4d130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

Slider* Slider::create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler) {
		return Slider::create(target, handler, 1.f);
	}

Slider* Slider::create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler, float idk) {
		return Slider::create(target, handler, "sliderBar.png", "slidergroove.png", "sliderthumb.png", "sliderthumbsel.png", idk);
	}

SliderThumb* Slider::getThumb() {
		return m_touchLogic->m_thumb;
	}

auto Slider::getValue() -> decltype(getValue()) {
	using FunctionType = decltype(getValue())(*)(Slider*);
	static auto func = wrapFunction(base::get() + 0x4d4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto Slider::init(cocos2d::CCNode* p0, cocos2d::SEL_MenuHandler p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(Slider*, cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x4d1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

void Slider::setValue(float val) {
		this->getThumb()->setValue(val);
		this->updateBar();
	}

auto Slider::updateBar() -> decltype(updateBar()) {
	using FunctionType = decltype(updateBar())(*)(Slider*);
	static auto func = wrapFunction(base::get() + 0x4d590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto Slider::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("Slider::ccTouchBegan not implemented");
}

auto Slider::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("Slider::ccTouchMoved not implemented");
}

auto Slider::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("Slider::ccTouchEnded not implemented");
}

auto SliderThumb::create(cocos2d::CCNode* p0, cocos2d::SEL_MenuHandler p1, char const* p2, char const* p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x4c900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

float SliderThumb::getValue() {
		return (this->getScaleX() * m_length * .5f +
				(m_vertical ?
					this->getPositionY() :
					this->getPositionX())
			) / (this->getScaleX() * m_length);
	}

auto SliderThumb::setMaxOffset(float p0) -> decltype(setMaxOffset(p0)) {
	using FunctionType = decltype(setMaxOffset(p0))(*)(SliderThumb*, float);
	static auto func = wrapFunction(base::get() + 0x4ca90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SliderThumb::setValue(float p0) -> decltype(setValue(p0)) {
	using FunctionType = decltype(setValue(p0))(*)(SliderThumb*, float);
	static auto func = wrapFunction(base::get() + 0x4cbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SliderTouchLogic::create(cocos2d::CCNode* p0, cocos2d::SEL_MenuHandler p1, char const* p2, char const* p3, float p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x4ccc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto SliderTouchLogic::init(cocos2d::CCNode* p0, cocos2d::SEL_MenuHandler p1, char const* p2, char const* p3, float p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(SliderTouchLogic*, cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x4ce50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto SliderTouchLogic::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("SliderTouchLogic::ccTouchBegan not implemented");
}

auto SliderTouchLogic::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("SliderTouchLogic::ccTouchMoved not implemented");
}

auto SliderTouchLogic::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("SliderTouchLogic::ccTouchEnded not implemented");
}

auto SliderTouchLogic::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("SliderTouchLogic::registerWithTouchDispatcher not implemented");
}

auto SmartGameObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x397c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SmartGameObject::init(char const* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SmartGameObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x397cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SmartGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SmartGameObject::customObjectSetup not implemented");
}

auto SmartGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SmartGameObject::getSaveString not implemented");
}

auto SmartTemplateCell::loadFromObject(GJSmartTemplate* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(SmartTemplateCell*, GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0x8b020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SmartTemplateCell::updateBGColor(int p0) -> decltype(updateBGColor(p0)) {
	using FunctionType = decltype(updateBGColor(p0))(*)(SmartTemplateCell*, int);
	static auto func = wrapFunction(base::get() + 0x8b320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SmartTemplateCell::init() -> decltype(init()) {
	throw std::runtime_error("SmartTemplateCell::init not implemented");
}

auto SmartTemplateCell::draw() -> decltype(draw()) {
	throw std::runtime_error("SmartTemplateCell::draw not implemented");
}

auto SongCell::loadFromObject(SongObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(SongCell*, SongObject*);
	static auto func = wrapFunction(base::get() + 0x82cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SongCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongCell::init), this);
	using FunctionType = decltype(init())(*)(SongCell*);
	static auto func = wrapFunction(base::get() + 0x1da30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongCell::draw() -> decltype(draw()) {
	throw std::runtime_error("SongCell::draw not implemented");
}

auto SongInfoLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x38aba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SongInfoLayer::init(gd::string p0, gd::string p1, gd::string p2, gd::string p3, gd::string p4, gd::string p5, int p6, gd::string p7) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7))(*)(SongInfoLayer*, gd::string, gd::string, gd::string, gd::string, gd::string, gd::string, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x38ae50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto SongInfoLayer::onMenuMusic(cocos2d::CCObject* sender) -> decltype(onMenuMusic(sender)) {
	using FunctionType = decltype(onMenuMusic(sender))(*)(SongInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x38bd20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SongInfoLayer::onPracticeMusic(cocos2d::CCObject* sender) -> decltype(onPracticeMusic(sender)) {
	using FunctionType = decltype(onPracticeMusic(sender))(*)(SongInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x38bda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SongInfoLayer::showCustomMusicUnlockInfo() -> decltype(showCustomMusicUnlockInfo()) {
	using FunctionType = decltype(showCustomMusicUnlockInfo())(*)(SongInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x38baa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SongInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SongInfoLayer::keyBackClicked not implemented");
}

auto SongInfoObject::create(cocos2d::CCDictionary* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x287fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SongInfoObject::create(int songID, gd::string songName, gd::string artistName, int artistID, float filesize, gd::string youtubeVideo, gd::string youtubeChannel, gd::string url, int priority) -> decltype(create(songID, songName, artistName, artistID, filesize, youtubeVideo, youtubeChannel, url, priority)) {
	using FunctionType = decltype(create(songID, songName, artistName, artistID, filesize, youtubeVideo, youtubeChannel, url, priority))(*)(int, gd::string, gd::string, int, float, gd::string, gd::string, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x288650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(songID, songName, artistName, artistID, filesize, youtubeVideo, youtubeChannel, url, priority);
}

auto SongInfoObject::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x287f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SongInfoObject::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(SongInfoObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x288a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SongInfoObject::init(int songID, gd::string songName, gd::string artistName, int artistID, float filesize, gd::string youtubeVideo, gd::string youtubeChannel, gd::string url, int priority) -> decltype(init(songID, songName, artistName, artistID, filesize, youtubeVideo, youtubeChannel, url, priority)) {
	using FunctionType = decltype(init(songID, songName, artistName, artistID, filesize, youtubeVideo, youtubeChannel, url, priority))(*)(SongInfoObject*, int, gd::string, gd::string, int, float, gd::string, gd::string, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x288860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, songID, songName, artistName, artistID, filesize, youtubeVideo, youtubeChannel, url, priority);
}

auto SongInfoObject::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	throw std::runtime_error("SongInfoObject::encodeWithCoder not implemented");
}

auto SongInfoObject::canEncode() -> decltype(canEncode()) {
	throw std::runtime_error("SongInfoObject::canEncode not implemented");
}

auto SongOptionsLayer::create(CustomSongDelegate* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(CustomSongDelegate*);
	static auto func = wrapFunction(base::get() + 0x90140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SongOptionsLayer::init(CustomSongDelegate* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SongOptionsLayer*, CustomSongDelegate*);
	static auto func = wrapFunction(base::get() + 0x901e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SongOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("SongOptionsLayer::keyBackClicked not implemented");
}

auto SongSelectNode::audioNext(cocos2d::CCObject* p0) -> decltype(audioNext(p0)) {
	using FunctionType = decltype(audioNext(p0))(*)(SongSelectNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x92270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SongSelectNode::audioPrevious(cocos2d::CCObject* p0) -> decltype(audioPrevious(p0)) {
	using FunctionType = decltype(audioPrevious(p0))(*)(SongSelectNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x922b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SongSelectNode::init(int p0, bool p1, LevelSettingsObject* p2, SongSelectType p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCMenu* p6, bool p7) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7))(*)(SongSelectNode*, int, bool, LevelSettingsObject*, SongSelectType, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCMenu*, bool);
	static auto func = wrapFunction(base::get() + 0x91a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto SongSelectNode::onOpenCustomSong(cocos2d::CCObject* sender) -> decltype(onOpenCustomSong(sender)) {
	using FunctionType = decltype(onOpenCustomSong(sender))(*)(SongSelectNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x92500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SongSelectNode::onSongMode(cocos2d::CCObject* sender) -> decltype(onSongMode(sender)) {
	using FunctionType = decltype(onSongMode(sender))(*)(SongSelectNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x922f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SongSelectNode::onSongMode(int p0) -> decltype(onSongMode(p0)) {
	using FunctionType = decltype(onSongMode(p0))(*)(SongSelectNode*, int);
	static auto func = wrapFunction(base::get() + 0x92310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SongSelectNode::updateAudioLabel() -> decltype(updateAudioLabel()) {
	using FunctionType = decltype(updateAudioLabel())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0x92160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SongSelectNode::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("SongSelectNode::FLAlert_Clicked not implemented");
}

auto SongSelectNode::customSongLayerClosed() -> decltype(customSongLayerClosed()) {
	throw std::runtime_error("SongSelectNode::customSongLayerClosed not implemented");
}

auto SongSelectNode::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	throw std::runtime_error("SongSelectNode::songIDChanged not implemented");
}

auto SongSelectNode::getActiveSongID() -> decltype(getActiveSongID()) {
	throw std::runtime_error("SongSelectNode::getActiveSongID not implemented");
}

auto SongSelectNode::getSongFileName() -> decltype(getSongFileName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::getSongFileName), this);
	using FunctionType = decltype(getSongFileName())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0x92660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::getLevelSettings() -> decltype(getLevelSettings()) {
	throw std::runtime_error("SongSelectNode::getLevelSettings not implemented");
}

auto SongsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x38bfb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto SongsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(SongsLayer*);
	static auto func = wrapFunction(base::get() + 0x38c0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SongTriggerGameObject::customObjectSetup not implemented");
}

auto SongTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SongTriggerGameObject::getSaveString not implemented");
}

auto SpawnParticleGameObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3b8660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto SpawnParticleGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SpawnParticleGameObject::init), this);
	using FunctionType = decltype(init())(*)(SpawnParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x3b8700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SpawnParticleGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SpawnParticleGameObject::customObjectSetup not implemented");
}

auto SpawnParticleGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SpawnParticleGameObject::getSaveString not implemented");
}

auto SpawnTriggerGameObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3ae840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto SpawnTriggerGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SpawnTriggerGameObject::init), this);
	using FunctionType = decltype(init())(*)(SpawnTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x3ae8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SpawnTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("SpawnTriggerGameObject::triggerObject not implemented");
}

auto SpawnTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SpawnTriggerGameObject::customObjectSetup not implemented");
}

auto SpawnTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SpawnTriggerGameObject::getSaveString not implemented");
}

auto SpecialAnimGameObject::resetObject() -> decltype(resetObject()) {
	throw std::runtime_error("SpecialAnimGameObject::resetObject not implemented");
}

auto SpecialAnimGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("SpecialAnimGameObject::customObjectSetup not implemented");
}

auto SpecialAnimGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("SpecialAnimGameObject::getSaveString not implemented");
}

auto SpecialAnimGameObject::updateMainColor(cocos2d::ccColor3B const& p0) -> decltype(updateMainColor(p0)) {
	throw std::runtime_error("SpecialAnimGameObject::updateMainColor not implemented");
}

auto SpecialAnimGameObject::updateSecondaryColor(cocos2d::ccColor3B const& p0) -> decltype(updateSecondaryColor(p0)) {
	throw std::runtime_error("SpecialAnimGameObject::updateSecondaryColor not implemented");
}

auto SpecialAnimGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	throw std::runtime_error("SpecialAnimGameObject::updateSyncedAnimation not implemented");
}

auto SpriteAnimationManager::executeAnimation(gd::string p0) -> decltype(executeAnimation(p0)) {
	using FunctionType = decltype(executeAnimation(p0))(*)(SpriteAnimationManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SpriteAnimationManager::offsetCurrentAnimation(float p0) -> decltype(offsetCurrentAnimation(p0)) {
	using FunctionType = decltype(offsetCurrentAnimation(p0))(*)(SpriteAnimationManager*, float);
	static auto func = wrapFunction(base::get() + 0x4fc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SpriteAnimationManager::overridePrio() -> decltype(overridePrio()) {
	using FunctionType = decltype(overridePrio())(*)(SpriteAnimationManager*);
	static auto func = wrapFunction(base::get() + 0x4f7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SpriteAnimationManager::runAnimation(gd::string p0) -> decltype(runAnimation(p0)) {
	using FunctionType = decltype(runAnimation(p0))(*)(SpriteAnimationManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SpriteAnimationManager::stopAnimations() -> decltype(stopAnimations()) {
	using FunctionType = decltype(stopAnimations())(*)(SpriteAnimationManager*);
	static auto func = wrapFunction(base::get() + 0x4fa60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto StartPosObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3a7850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto StartPosObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StartPosObject::init), this);
	using FunctionType = decltype(init())(*)(StartPosObject*);
	static auto func = wrapFunction(base::get() + 0x3a7910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto StartPosObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("StartPosObject::customObjectSetup not implemented");
}

auto StartPosObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("StartPosObject::getSaveString not implemented");
}

auto StatsCell::loadFromObject(StatsObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(StatsCell*, StatsObject*);
	static auto func = wrapFunction(base::get() + 0x82230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto StatsCell::updateBGColor(int p0) -> decltype(updateBGColor(p0)) {
	using FunctionType = decltype(updateBGColor(p0))(*)(StatsCell*, int);
	static auto func = wrapFunction(base::get() + 0x7d560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto StatsCell::init() -> decltype(init()) {
	throw std::runtime_error("StatsCell::init not implemented");
}

auto StatsCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StatsCell::draw), this);
	using FunctionType = decltype(draw())(*)(StatsCell*);
	static auto func = wrapFunction(base::get() + 0x7d5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto StatsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3bb620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto StatsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StatsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(StatsLayer*);
	static auto func = wrapFunction(base::get() + 0x3bb730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto StatsObject::create(char const* p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, int);
	static auto func = wrapFunction(base::get() + 0x82070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto StatsObject::init(char const* p0, int p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(StatsObject*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x82120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SupportLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3bbb30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto SupportLayer::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCArray* p5) -> decltype(createToggleButton(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3, p4, p5))(*)(SupportLayer*, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3bc520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto SupportLayer::onLinks(cocos2d::CCObject* sender) -> decltype(onLinks(sender)) {
	using FunctionType = decltype(onLinks(sender))(*)(SupportLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3bce90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SupportLayer::onLowDetail(cocos2d::CCObject* sender) -> decltype(onLowDetail(sender)) {
	using FunctionType = decltype(onLowDetail(sender))(*)(SupportLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3bcc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SupportLayer::onRequestAccess(cocos2d::CCObject* sender) -> decltype(onRequestAccess(sender)) {
	using FunctionType = decltype(onRequestAccess(sender))(*)(SupportLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3bca70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SupportLayer::sendSupportMail() -> decltype(sendSupportMail()) {
	using FunctionType = decltype(sendSupportMail())(*)(SupportLayer*);
	static auto func = wrapFunction(base::get() + 0x3bcd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SupportLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SupportLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(SupportLayer*);
	static auto func = wrapFunction(base::get() + 0x3bbcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SupportLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&SupportLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(SupportLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x3bcbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SupportLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&SupportLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(SupportLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x3bcc20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SupportLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("SupportLayer::onClosePopup not implemented");
}

auto SupportLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SupportLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SupportLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3bd0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::create(TableViewDelegate* p0, TableViewDataSource* p1, TableViewCellDelegate* p2, cocos2d::CCRect p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(TableViewDelegate*, TableViewDataSource*, TableViewCellDelegate*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x4fe90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto TableView::deleteTableViewCell(TableViewCell* p0) -> decltype(deleteTableViewCell(p0)) {
	using FunctionType = decltype(deleteTableViewCell(p0))(*)(TableView*, TableViewCell*);
	static auto func = wrapFunction(base::get() + 0x50550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TableView::reloadData() -> decltype(reloadData()) {
	using FunctionType = decltype(reloadData())(*)(TableView*);
	static auto func = wrapFunction(base::get() + 0x50770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto TableView::onEnter() -> decltype(onEnter()) {
	throw std::runtime_error("TableView::onEnter not implemented");
}

auto TableView::onExit() -> decltype(onExit()) {
	throw std::runtime_error("TableView::onExit not implemented");
}

auto TableView::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("TableView::ccTouchBegan not implemented");
}

auto TableView::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("TableView::ccTouchMoved not implemented");
}

auto TableView::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("TableView::ccTouchEnded not implemented");
}

auto TableView::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("TableView::ccTouchCancelled not implemented");
}

auto TableView::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("TableView::registerWithTouchDispatcher not implemented");
}

auto TableView::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&TableView::scrollWheel), this);
	using FunctionType = decltype(scrollWheel(p0, p1))(*)(TableView*, float, float);
	static auto func = wrapFunction(base::get() + 0x50fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::scrllViewWillBeginDecelerating(CCScrollLayerExt* p0) -> decltype(scrllViewWillBeginDecelerating(p0)) {
	throw std::runtime_error("TableView::scrllViewWillBeginDecelerating not implemented");
}

auto TableView::scrollViewDidEndDecelerating(CCScrollLayerExt* p0) -> decltype(scrollViewDidEndDecelerating(p0)) {
	throw std::runtime_error("TableView::scrollViewDidEndDecelerating not implemented");
}

auto TableView::scrollViewTouchMoving(CCScrollLayerExt* p0) -> decltype(scrollViewTouchMoving(p0)) {
	throw std::runtime_error("TableView::scrollViewTouchMoving not implemented");
}

auto TableView::scrollViewDidEndMoving(CCScrollLayerExt* p0) -> decltype(scrollViewDidEndMoving(p0)) {
	throw std::runtime_error("TableView::scrollViewDidEndMoving not implemented");
}

auto TeleportPortalObject::create(char const* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, bool);
	static auto func = wrapFunction(base::get() + 0x3a7a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto TeleportPortalObject::getTeleportXOff(cocos2d::CCNode* p0) -> decltype(getTeleportXOff(p0)) {
	using FunctionType = decltype(getTeleportXOff(p0))(*)(TeleportPortalObject*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x3a7c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TeleportPortalObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	throw std::runtime_error("TeleportPortalObject::setPosition not implemented");
}

auto TeleportPortalObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	throw std::runtime_error("TeleportPortalObject::setRotation not implemented");
}

auto TeleportPortalObject::setStartPos(cocos2d::CCPoint p0) -> decltype(setStartPos(p0)) {
	throw std::runtime_error("TeleportPortalObject::setStartPos not implemented");
}

auto TeleportPortalObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("TeleportPortalObject::customObjectSetup not implemented");
}

auto TeleportPortalObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("TeleportPortalObject::getSaveString not implemented");
}

auto TeleportPortalObject::addToGroup(int p0) -> decltype(addToGroup(p0)) {
	throw std::runtime_error("TeleportPortalObject::addToGroup not implemented");
}

auto TeleportPortalObject::removeFromGroup(int p0) -> decltype(removeFromGroup(p0)) {
	throw std::runtime_error("TeleportPortalObject::removeFromGroup not implemented");
}

auto TeleportPortalObject::setRotation2(float p0) -> decltype(setRotation2(p0)) {
	throw std::runtime_error("TeleportPortalObject::setRotation2 not implemented");
}

auto TeleportPortalObject::addToGroup2(int p0) -> decltype(addToGroup2(p0)) {
	throw std::runtime_error("TeleportPortalObject::addToGroup2 not implemented");
}

auto TeleportPortalObject::removeFromGroup2(int p0) -> decltype(removeFromGroup2(p0)) {
	throw std::runtime_error("TeleportPortalObject::removeFromGroup2 not implemented");
}

auto TextAlertPopup::create(gd::string p0, float p1, float p2, int p3, gd::string p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(gd::string, float, float, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x211c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto TextAlertPopup::init(gd::string p0, float p1, float p2, int p3, gd::string p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(TextAlertPopup*, gd::string, float, float, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x211de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto TextAlertPopup::setAlertPosition(cocos2d::CCPoint p0, cocos2d::CCPoint p1) -> decltype(setAlertPosition(p0, p1)) {
	using FunctionType = decltype(setAlertPosition(p0, p1))(*)(TextAlertPopup*, cocos2d::CCPoint, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x212120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto TextArea::create(gd::string str, char const* font, float scale, float width, cocos2d::CCPoint anchor, float lineHeight, bool disableColor) -> decltype(create(str, font, scale, width, anchor, lineHeight, disableColor)) {
	using FunctionType = decltype(create(str, font, scale, width, anchor, lineHeight, disableColor))(*)(gd::string, char const*, float, float, cocos2d::CCPoint, float, bool);
	static auto func = wrapFunction(base::get() + 0x52250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(str, font, scale, width, anchor, lineHeight, disableColor);
}

auto TextArea::colorAllCharactersTo(cocos2d::ccColor3B p0) -> decltype(colorAllCharactersTo(p0)) {
	using FunctionType = decltype(colorAllCharactersTo(p0))(*)(TextArea*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x52850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TextArea::init(gd::string str, char const* font, float scale, float width, cocos2d::CCPoint anchor, float lineHeight, bool disableColor) -> decltype(init(str, font, scale, width, anchor, lineHeight, disableColor)) {
	using FunctionType = decltype(init(str, font, scale, width, anchor, lineHeight, disableColor))(*)(TextArea*, gd::string, char const*, float, float, cocos2d::CCPoint, float, bool);
	static auto func = wrapFunction(base::get() + 0x52350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, str, font, scale, width, anchor, lineHeight, disableColor);
}

auto TextArea::setString(gd::string p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(TextArea*, gd::string);
	static auto func = wrapFunction(base::get() + 0x52460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TextArea::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("TextArea::update not implemented");
}

auto TextArea::draw() -> decltype(draw()) {
	throw std::runtime_error("TextArea::draw not implemented");
}

auto TextArea::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("TextArea::setOpacity not implemented");
}

auto TextGameObject::create(cocos2d::CCTexture2D* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x147cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto TextGameObject::updateTextObject(gd::string p0, bool p1) -> decltype(updateTextObject(p0, p1)) {
	using FunctionType = decltype(updateTextObject(p0, p1))(*)(TextGameObject*, gd::string, bool);
	static auto func = wrapFunction(base::get() + 0x147d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto TextGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("TextGameObject::customObjectSetup not implemented");
}

auto TextGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("TextGameObject::getSaveString not implemented");
}

auto TextGameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	throw std::runtime_error("TextGameObject::updateTextKerning not implemented");
}

auto TextGameObject::getTextKerning() -> decltype(getTextKerning()) {
	throw std::runtime_error("TextGameObject::getTextKerning not implemented");
}

auto TimerTriggerGameObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3b4520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto TimerTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("TimerTriggerGameObject::triggerObject not implemented");
}

auto TimerTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("TimerTriggerGameObject::customObjectSetup not implemented");
}

auto TimerTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("TimerTriggerGameObject::getSaveString not implemented");
}

auto TopArtistsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3bd270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto TopArtistsLayer::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(TopArtistsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3bdcb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TopArtistsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TopArtistsLayer::init), this);
	using FunctionType = decltype(init())(*)(TopArtistsLayer*);
	static auto func = wrapFunction(base::get() + 0x3bd310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("TopArtistsLayer::registerWithTouchDispatcher not implemented");
}

auto TopArtistsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("TopArtistsLayer::keyBackClicked not implemented");
}

auto TopArtistsLayer::show() -> decltype(show()) {
	throw std::runtime_error("TopArtistsLayer::show not implemented");
}

auto TopArtistsLayer::loadListFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadListFinished(p0, p1)) {
	throw std::runtime_error("TopArtistsLayer::loadListFinished not implemented");
}

auto TopArtistsLayer::loadListFailed(char const* p0) -> decltype(loadListFailed(p0)) {
	throw std::runtime_error("TopArtistsLayer::loadListFailed not implemented");
}

auto TopArtistsLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	throw std::runtime_error("TopArtistsLayer::setupPageInfo not implemented");
}

auto TOSPopup::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x212240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto TOSPopup::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TOSPopup::init), this);
	using FunctionType = decltype(init())(*)(TOSPopup*);
	static auto func = wrapFunction(base::get() + 0x2122e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TOSPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("TOSPopup::keyBackClicked not implemented");
}

auto TransformTriggerGameObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3b1350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto TransformTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("TransformTriggerGameObject::triggerObject not implemented");
}

auto TransformTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("TransformTriggerGameObject::customObjectSetup not implemented");
}

auto TransformTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("TransformTriggerGameObject::getSaveString not implemented");
}

auto TriggerControlGameObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3b8110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto TriggerControlGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	throw std::runtime_error("TriggerControlGameObject::triggerObject not implemented");
}

auto TriggerControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("TriggerControlGameObject::customObjectSetup not implemented");
}

auto TriggerControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("TriggerControlGameObject::getSaveString not implemented");
}

auto TutorialLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3be0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto TutorialLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TutorialLayer::init), this);
	using FunctionType = decltype(init())(*)(TutorialLayer*);
	static auto func = wrapFunction(base::get() + 0x3be140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TutorialLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("TutorialLayer::keyBackClicked not implemented");
}

auto TutorialPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("TutorialPopup::keyBackClicked not implemented");
}

auto TutorialPopup::show() -> decltype(show()) {
	throw std::runtime_error("TutorialPopup::show not implemented");
}

auto UILayer::enableEditorMode() -> decltype(enableEditorMode()) {
	using FunctionType = decltype(enableEditorMode())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x3bf420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UILayer::handleKeypress(cocos2d::enumKeyCodes p0, bool p1) -> decltype(handleKeypress(p0, p1)) {
	using FunctionType = decltype(handleKeypress(p0, p1))(*)(UILayer*, cocos2d::enumKeyCodes, bool);
	static auto func = wrapFunction(base::get() + 0x3bf480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto UILayer::init(GJBaseGameLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(UILayer*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x3bec10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UILayer::onCheck(cocos2d::CCObject* sender) -> decltype(onCheck(sender)) {
	using FunctionType = decltype(onCheck(sender))(*)(UILayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3bfa10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto UILayer::onDeleteCheck(cocos2d::CCObject* sender) -> decltype(onDeleteCheck(sender)) {
	using FunctionType = decltype(onDeleteCheck(sender))(*)(UILayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3bfa50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto UILayer::onPause(cocos2d::CCObject* sender) -> decltype(onPause(sender)) {
	using FunctionType = decltype(onPause(sender))(*)(UILayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3bf9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto UILayer::resetAllButtons() -> decltype(resetAllButtons()) {
	using FunctionType = decltype(resetAllButtons())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x3bfad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UILayer::resetUINodeState() -> decltype(resetUINodeState()) {
	using FunctionType = decltype(resetUINodeState())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x3bf390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UILayer::toggleMenuVisibility(bool p0) -> decltype(toggleMenuVisibility(p0)) {
	using FunctionType = decltype(toggleMenuVisibility(p0))(*)(UILayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3bfa80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UILayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UILayer::draw), this);
	using FunctionType = decltype(draw())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x3c0de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UILayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("UILayer::ccTouchBegan not implemented");
}

auto UILayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("UILayer::ccTouchMoved not implemented");
}

auto UILayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("UILayer::ccTouchEnded not implemented");
}

auto UILayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("UILayer::ccTouchCancelled not implemented");
}

auto UILayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("UILayer::registerWithTouchDispatcher not implemented");
}

auto UILayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UILayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x3bf970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UILayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&UILayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(UILayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x3bf930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UILayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&UILayer::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(UILayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x3bf950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UIObjectSettingsPopup::create(UISettingsGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(UISettingsGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x367170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto UIObjectSettingsPopup::init(UISettingsGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(UIObjectSettingsPopup*, UISettingsGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x367220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto UIObjectSettingsPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	throw std::runtime_error("UIObjectSettingsPopup::onCustomToggleTriggerValue not implemented");
}

auto UIOptionsLayer::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x213db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto UIOptionsLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(UIOptionsLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x213e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UIOptionsLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	throw std::runtime_error("UIOptionsLayer::ccTouchBegan not implemented");
}

auto UIOptionsLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	throw std::runtime_error("UIOptionsLayer::ccTouchMoved not implemented");
}

auto UIOptionsLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	throw std::runtime_error("UIOptionsLayer::ccTouchEnded not implemented");
}

auto UIOptionsLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	throw std::runtime_error("UIOptionsLayer::ccTouchCancelled not implemented");
}

auto UIOptionsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	throw std::runtime_error("UIOptionsLayer::registerWithTouchDispatcher not implemented");
}

auto UIOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	throw std::runtime_error("UIOptionsLayer::onClose not implemented");
}

auto UIOptionsLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	throw std::runtime_error("UIOptionsLayer::valueDidChange not implemented");
}

auto UIOptionsLayer::getValue(int p0) -> decltype(getValue(p0)) {
	throw std::runtime_error("UIOptionsLayer::getValue not implemented");
}

auto UISaveLoadLayer::create(UIOptionsLayer* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(UIOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x215e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto UISaveLoadLayer::init(UIOptionsLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(UISaveLoadLayer*, UIOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x215eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UISettingsGameObject::init() -> decltype(init()) {
	throw std::runtime_error("UISettingsGameObject::init not implemented");
}

auto UISettingsGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	throw std::runtime_error("UISettingsGameObject::customObjectSetup not implemented");
}

auto UISettingsGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	throw std::runtime_error("UISettingsGameObject::getSaveString not implemented");
}

auto UndoObject::create(GameObject* p0, UndoCommand p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GameObject*, UndoCommand);
	static auto func = wrapFunction(base::get() + 0x24a4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto UndoObject::createWithArray(cocos2d::CCArray* p0, UndoCommand p1) -> decltype(createWithArray(p0, p1)) {
	using FunctionType = decltype(createWithArray(p0, p1))(*)(cocos2d::CCArray*, UndoCommand);
	static auto func = wrapFunction(base::get() + 0x24a760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto UndoObject::createWithTransformObjects(cocos2d::CCArray* p0, UndoCommand p1) -> decltype(createWithTransformObjects(p0, p1)) {
	using FunctionType = decltype(createWithTransformObjects(p0, p1))(*)(cocos2d::CCArray*, UndoCommand);
	static auto func = wrapFunction(base::get() + 0x24a580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto UndoObject::initWithTransformObjects(cocos2d::CCArray* p0, UndoCommand p1) -> decltype(initWithTransformObjects(p0, p1)) {
	using FunctionType = decltype(initWithTransformObjects(p0, p1))(*)(UndoObject*, cocos2d::CCArray*, UndoCommand);
	static auto func = wrapFunction(base::get() + 0x24a650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto UpdateAccountSettingsPopup::create(GJAccountSettingsLayer* p0, int p1, int p2, int p3, gd::string p4, gd::string p5, gd::string p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(GJAccountSettingsLayer*, int, int, int, gd::string, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x20a3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

auto UpdateAccountSettingsPopup::init(GJAccountSettingsLayer* p0, int p1, int p2, int p3, gd::string p4, gd::string p5, gd::string p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(UpdateAccountSettingsPopup*, GJAccountSettingsLayer*, int, int, int, gd::string, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x20a540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto UpdateAccountSettingsPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("UpdateAccountSettingsPopup::keyBackClicked not implemented");
}

auto UpdateAccountSettingsPopup::updateSettingsFinished() -> decltype(updateSettingsFinished()) {
	throw std::runtime_error("UpdateAccountSettingsPopup::updateSettingsFinished not implemented");
}

auto UpdateAccountSettingsPopup::updateSettingsFailed() -> decltype(updateSettingsFailed()) {
	throw std::runtime_error("UpdateAccountSettingsPopup::updateSettingsFailed not implemented");
}

auto UploadActionPopup::create(UploadPopupDelegate* p0, gd::string p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(UploadPopupDelegate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x20ac30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto UploadActionPopup::init(UploadPopupDelegate* p0, gd::string p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(UploadActionPopup*, UploadPopupDelegate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x20ad00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto UploadActionPopup::showFailMessage(gd::string p0) -> decltype(showFailMessage(p0)) {
	using FunctionType = decltype(showFailMessage(p0))(*)(UploadActionPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x20b1e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UploadActionPopup::showSuccessMessage(gd::string p0) -> decltype(showSuccessMessage(p0)) {
	using FunctionType = decltype(showSuccessMessage(p0))(*)(UploadActionPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x20b0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UploadActionPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("UploadActionPopup::keyBackClicked not implemented");
}

auto UploadListPopup::create(GJLevelList* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x2600f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto UploadListPopup::init(GJLevelList* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(UploadListPopup*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x260190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UploadListPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("UploadListPopup::keyBackClicked not implemented");
}

auto UploadListPopup::show() -> decltype(show()) {
	throw std::runtime_error("UploadListPopup::show not implemented");
}

auto UploadListPopup::listUploadFinished(GJLevelList* p0) -> decltype(listUploadFinished(p0)) {
	throw std::runtime_error("UploadListPopup::listUploadFinished not implemented");
}

auto UploadListPopup::listUploadFailed(GJLevelList* p0, int p1) -> decltype(listUploadFailed(p0, p1)) {
	throw std::runtime_error("UploadListPopup::listUploadFailed not implemented");
}

auto UploadPopup::create(GJGameLevel* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x3890f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto UploadPopup::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(UploadPopup*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x389190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UploadPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("UploadPopup::keyBackClicked not implemented");
}

auto UploadPopup::show() -> decltype(show()) {
	throw std::runtime_error("UploadPopup::show not implemented");
}

auto UploadPopup::levelUploadFinished(GJGameLevel* p0) -> decltype(levelUploadFinished(p0)) {
	throw std::runtime_error("UploadPopup::levelUploadFinished not implemented");
}

auto UploadPopup::levelUploadFailed(GJGameLevel* p0) -> decltype(levelUploadFailed(p0)) {
	throw std::runtime_error("UploadPopup::levelUploadFailed not implemented");
}

auto URLCell::loadFromObject(CCURLObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(URLCell*, CCURLObject*);
	static auto func = wrapFunction(base::get() + 0x8ca50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto URLCell::init() -> decltype(init()) {
	throw std::runtime_error("URLCell::init not implemented");
}

auto URLCell::draw() -> decltype(draw()) {
	throw std::runtime_error("URLCell::draw not implemented");
}

auto URLViewLayer::create(gd::string p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(gd::string, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2166a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto URLViewLayer::init(gd::string p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(URLViewLayer*, gd::string, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x216770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto VideoOptionsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2b3e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Optcall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto VideoOptionsLayer::onApply(cocos2d::CCObject* sender) -> decltype(onApply(sender)) {
	using FunctionType = decltype(onApply(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b50e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::updateResolution(int p0) -> decltype(updateResolution(p0)) {
	using FunctionType = decltype(updateResolution(p0))(*)(VideoOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b4ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto VideoOptionsLayer::updateTextureQuality(int p0) -> decltype(updateTextureQuality(p0)) {
	using FunctionType = decltype(updateTextureQuality(p0))(*)(VideoOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2b4de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Membercall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto VideoOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&VideoOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(VideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x2b3ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Thiscall),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto VideoOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("VideoOptionsLayer::keyBackClicked not implemented");
}

auto WorldLevelPage::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("WorldLevelPage::keyBackClicked not implemented");
}

auto WorldLevelPage::show() -> decltype(show()) {
	throw std::runtime_error("WorldLevelPage::show not implemented");
}

auto WorldSelectLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("WorldSelectLayer::onExit not implemented");
}

auto WorldSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("WorldSelectLayer::keyBackClicked not implemented");
}

auto WorldSelectLayer::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	throw std::runtime_error("WorldSelectLayer::scrollLayerWillScrollToPage not implemented");
}

auto WorldSelectLayer::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	throw std::runtime_error("WorldSelectLayer::scrollLayerScrolledToPage not implemented");
}

auto WorldSelectLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	throw std::runtime_error("WorldSelectLayer::scrollLayerMoved not implemented");
}
